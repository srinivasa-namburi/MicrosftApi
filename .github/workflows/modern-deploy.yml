name: Modern Deploy

# This workflow deploys to Azure using a service principal stored in the AZURE_CREDENTIALS secret.
#
# AZURE_CREDENTIALS Secret Format:
# The workflow supports both output formats from Azure CLI:
#
# Option 1: Output from 'az ad sp create-for-rbac' (recommended - paste directly):
#   {"appId":"...","password":"...","tenant":"...","subscriptionId":"..."}
#
# Option 2: GitHub Actions format (also supported):
#   {"clientId":"...","clientSecret":"...","tenantId":"...","subscriptionId":"..."}
#
# The subscriptionId field is optional - if omitted, it will use AZURE_SUBSCRIPTION_ID variable.
# The workflow automatically converts between formats, so use whichever is convenient.
#
# To set the secret:
#   gh secret set AZURE_CREDENTIALS --env dev --body '{"appId":"...","password":"...","tenant":"...","subscriptionId":"..."}'

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment name (matches GitHub environment)'
        required: true
        default: 'dev'

jobs:
  deploy:
    runs-on: self-hosted
    environment: ${{ github.event.inputs.environment }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'
      - name: Install Aspire CLI
        run: |
          # Install GA version of Aspire CLI
          curl -sSL https://aspire.dev/install.sh | bash -s -- --version 9.4.0
          # Add aspire to PATH for current shell
          export PATH="$HOME/.aspire/bin:$PATH"
          # Verify installation
          aspire --version
        
      - name: Aspire publish
        run: |
          # Ensure aspire is in PATH
          export PATH="$HOME/.aspire/bin:$PATH"
          # Set execute permissions for scripts
          chmod +x build/scripts/*.sh
          chmod +x build/scripts/pipeline-internal/*.sh
          build/scripts/pipeline-internal/build-modern-aspire-publish.sh out/publish
          # Post-publish fixes now handles all patching
          build/scripts/pipeline-internal/build-modern-post-publish-fixes.sh out/publish publish
      - name: Convert Azure credentials format
        id: convert-creds
        run: |
          # Convert from az ad sp create format (appId/password/tenant)
          # to azure/login format (clientId/clientSecret/tenantId/subscriptionId)
          echo "Converting Azure credentials to GitHub Actions format..."

          # Read the credentials secret
          CREDS='${{ secrets.AZURE_CREDENTIALS }}'

          # Parse fields (supporting both formats)
          CLIENT_ID=$(echo "$CREDS" | jq -r '.clientId // .appId')
          CLIENT_SECRET=$(echo "$CREDS" | jq -r '.clientSecret // .password')
          TENANT_ID=$(echo "$CREDS" | jq -r '.tenantId // .tenant')
          SUBSCRIPTION_ID=$(echo "$CREDS" | jq -r '.subscriptionId // empty')

          # Use subscription from variables if not in credentials
          if [ -z "$SUBSCRIPTION_ID" ]; then
            SUBSCRIPTION_ID="${AZURE_SUBSCRIPTION_ID:-}"
          fi

          # Create properly formatted credentials
          if [ -n "$SUBSCRIPTION_ID" ]; then
            FORMATTED_CREDS=$(jq -n \
              --arg clientId "$CLIENT_ID" \
              --arg clientSecret "$CLIENT_SECRET" \
              --arg tenantId "$TENANT_ID" \
              --arg subscriptionId "$SUBSCRIPTION_ID" \
              '{clientId: $clientId, clientSecret: $clientSecret, tenantId: $tenantId, subscriptionId: $subscriptionId}')
          else
            FORMATTED_CREDS=$(jq -n \
              --arg clientId "$CLIENT_ID" \
              --arg clientSecret "$CLIENT_SECRET" \
              --arg tenantId "$TENANT_ID" \
              '{clientId: $clientId, clientSecret: $clientSecret, tenantId: $tenantId}')
          fi

          # Store in output (masked)
          echo "azure-credentials<<EOF" >> $GITHUB_OUTPUT
          echo "$FORMATTED_CREDS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "âœ… Credentials converted successfully"
        env:
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ steps.convert-creds.outputs.azure-credentials }}
      - name: Validate AKS access (post-login)
        if: ${{ vars.DEPLOY_AKS != 'true' }}
        run: |
          set -euo pipefail

          echo "Validating Existing AKS Cluster Access:"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

          AKS_RG="${AKS_RESOURCE_GROUP:-${AZURE_RESOURCE_GROUP}}"
          AKS_NAME="${AKS_CLUSTER_NAME:-greenlight-aks-dev}"

          echo "  Cluster: $AKS_NAME"
          echo "  Resource Group: $AKS_RG"
          echo ""

          echo "  Checking cluster existence and permissions..."
          set +e
          AKS_SHOW_OUTPUT=$(az aks show --name "$AKS_NAME" --resource-group "$AKS_RG" --query "name" -o tsv 2>&1)
          AKS_SHOW_EXIT=$?
          set -e

          if [[ $AKS_SHOW_EXIT -eq 0 ]] && [[ -n "$AKS_SHOW_OUTPUT" ]]; then
            echo "  âœ… Cluster exists and accessible via Azure API"

            CLUSTER_MODE=$(az aks show --name "$AKS_NAME" --resource-group "$AKS_RG" --query "apiServerAccessProfile.enablePrivateCluster" -o tsv 2>/dev/null || echo "false")

            if [[ "$CLUSTER_MODE" == "true" ]]; then
              echo "  âš ï¸  Private cluster detected - API server not publicly accessible"
              echo "     Ensure GitHub Actions runners can reach the cluster via VNET connectivity"
            else
              echo "  âœ… Public cluster - API server is accessible"
            fi

            echo ""
            echo "  Testing credential retrieval..."
            if az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing >/dev/null 2>&1; then
              echo "  âœ… Successfully retrieved cluster credentials"

              echo ""
              echo "  Testing kubectl connectivity..."
              if timeout 10 kubectl cluster-info >/dev/null 2>&1; then
                echo "  âœ… Successfully connected to cluster API server"

                NAMESPACE="${AKS_NAMESPACE:-greenlight-${GITHUB_EVENT_INPUTS_ENVIRONMENT:-dev}}"
                if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
                  echo "  âœ… Namespace '$NAMESPACE' exists"
                else
                  echo "  â„¹ï¸  Namespace '$NAMESPACE' will be created during deployment"
                fi
              else
                if [[ "$CLUSTER_MODE" == "true" ]]; then
                  echo "  âŒ Cannot connect to private cluster API server"
                  echo "     GitHub Actions runners must have network access to private clusters"
                  exit 1
                else
                  echo "  âŒ Cannot connect to cluster API server (timeout)"
                  echo "     Possible issues: network/firewall or API server availability"
                  exit 1
                fi
              fi
            else
              echo "  âŒ Failed to retrieve cluster credentials"
              echo "     Ensure the service principal has required AKS roles"
              exit 1
            fi
          else
            echo "  âŒ Cluster does not exist or no access permissions"
            echo "     az aks show exit code: $AKS_SHOW_EXIT"
            echo "     az aks show output:"
            echo "$AKS_SHOW_OUTPUT"
            echo ""
            echo "     To create the cluster, set DEPLOY_AKS=true in your GitHub environment variables"
            exit 1
          fi

          echo ""
          echo "  AKS cluster validation completed"
          echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        env:
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
          AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}
          AKS_NAMESPACE: ${{ vars.AKS_NAMESPACE }}
          GITHUB_EVENT_INPUTS_ENVIRONMENT: ${{ github.event.inputs.environment }}
      - name: Deploy Azure Resources
        id: azure-deploy
        run: |
          set -euo pipefail

          # Verify critical tools are available (already in Ubuntu runner)
          echo "[GitHub] Verifying required tools..."
          for tool in ssh-keygen awk jq python3 az; do
            if ! command -v $tool >/dev/null 2>&1; then
              echo "[GitHub] ERROR: Required tool '$tool' not found"
              exit 1
            fi
            echo "[GitHub]   âœ… $tool: $(command -v $tool)"
          done

          # Clean up any existing outputs file
          rm -f azure-outputs.env

          # Optional AKS provisioning (idempotent) when DEPLOY_AKS=true
          if [ "${DEPLOY_AKS:-false}" = "true" ]; then
            echo "[GitHub] DEPLOY_AKS=true - ensuring AKS cluster exists before infra deployment"
            chmod +x build/scripts/provision-aks-cluster.sh

            AKS_RG="${AKS_RESOURCE_GROUP:-${AZURE_RESOURCE_GROUP}}"
            AKS_NAME="${AKS_CLUSTER_NAME:-aks-${AZURE_RESOURCE_GROUP}}"
            DEPLOYMENT_MODEL="${DEPLOYMENT_MODEL:-public}"

            # Provision cluster non-interactively (will no-op if exists)
            PROVISION_ARGS=()
            PROVISION_ARGS+=("$AKS_RG")
            PROVISION_ARGS+=("$AZURE_LOCATION")
            PROVISION_ARGS+=("$AKS_NAME")
            PROVISION_ARGS+=("--deployment-model" "$DEPLOYMENT_MODEL")

            # Add subnet parameters for private/hybrid modes
            if [[ "$DEPLOYMENT_MODEL" == "private" ]] || [[ "$DEPLOYMENT_MODEL" == "hybrid" ]]; then
              if [ -n "${AKS_SUBNET:-}" ]; then
                PROVISION_ARGS+=("--subnet-id" "$AKS_SUBNET")
              fi
            fi

            echo "[GitHub] Running AKS provisioning script..."
            ACCEPT_DEFAULTS=true \
            AKS_DIAGNOSTICLOGS="${AKS_DIAGNOSTICLOGS:-false}" \
            build/scripts/provision-aks-cluster.sh "${PROVISION_ARGS[@]}"

            AKS_EXIT_CODE=$?
            if [ $AKS_EXIT_CODE -ne 0 ]; then
              echo "[GitHub] âŒ ERROR: AKS provisioning failed with exit code $AKS_EXIT_CODE"
              echo "[GitHub] Cannot continue without AKS cluster - aborting deployment"
              exit 1
            fi

            echo "[GitHub] âœ… AKS cluster provisioned successfully"

            # Capture workload identity variables if summary exists
            if [ -f "aks-provision-summary.json" ]; then
              echo "[GitHub] Capturing workload identity values from provisioning summary"
              WI_CLIENT_ID=$(jq -r '.workloadIdentity.clientId // empty' aks-provision-summary.json || true)
              WI_PRINCIPAL_ID=$(jq -r '.workloadIdentity.principalId // empty' aks-provision-summary.json || true)
              WI_RESOURCE_ID=$(jq -r '.workloadIdentity.resourceId // empty' aks-provision-summary.json || true)
              WI_NAME=$(echo "$WI_RESOURCE_ID" | sed 's|.*/||' || true)

              if [ -n "$WI_CLIENT_ID" ]; then
                echo "WORKLOAD_IDENTITY_CLIENT_ID=$WI_CLIENT_ID" >> $GITHUB_ENV
                echo "WORKLOAD_IDENTITY_PRINCIPAL_ID=$WI_PRINCIPAL_ID" >> $GITHUB_ENV
                echo "WORKLOAD_IDENTITY_NAME=$WI_NAME" >> $GITHUB_ENV
                echo "[GitHub] Updated environment with workload identity values"
              fi
            fi
          else
            echo "[GitHub] DEPLOY_AKS not enabled (DEPLOY_AKS=${DEPLOY_AKS:-false}) - expecting cluster to pre-exist"
          fi

          # Set up paths
          SCRIPTS_DIR="build/scripts/pipeline-internal"
          PUB_DIR="out/publish"

          # Make scripts executable
          chmod +x "$SCRIPTS_DIR"/*.sh
          chmod +x build/scripts/*.sh

          # Run deploy-stage fixes (principal type, subscription scope, role alignment)
          echo "[GitHub] Applying deploy-stage fixes..."
          WORKLOAD_IDENTITY_PRINCIPAL_ID="${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" \
          WORKLOAD_IDENTITY_NAME="${WORKLOAD_IDENTITY_NAME:-}" \
            "$SCRIPTS_DIR/build-modern-post-publish-fixes.sh" "$PUB_DIR" deploy

          # Deploy Azure resources (script will write outputs to file)
          export AZURE_OUTPUT_FILE="azure-outputs.env"
          "$SCRIPTS_DIR/build-modern-deploy-azure.sh" "$PUB_DIR" "$AZURE_RESOURCE_GROUP" "$AZURE_LOCATION"

          # Capture outputs for next steps
          echo "[GitHub] Capturing Azure deployment outputs..."

          if [ -f "azure-outputs.env" ]; then
            echo "[GitHub] Found azure-outputs.env file:"
            cat azure-outputs.env

            # Source the file to load variables
            source azure-outputs.env

            # Set as GitHub outputs for next steps
            while IFS= read -r line; do
              if [[ "$line" =~ ^AZURE_OUTPUT_([^=]+)=(.*)$ ]]; then
                var_name="${BASH_REMATCH[1]}"
                var_value="${BASH_REMATCH[2]}"
                echo "${var_name}=${var_value}" >> $GITHUB_OUTPUT
                # Don't echo sensitive values
                if [[ "$var_name" == *"Connection"* ]] || [[ "$var_name" == *"Password"* ]] || [[ "$var_name" == *"Key"* ]] || [[ "$var_name" == *"Endpoint"* ]]; then
                  echo "[GitHub] Set output: $var_name (sensitive - redacted)"
                else
                  echo "[GitHub] Set output: $var_name"
                fi
              fi
            done < azure-outputs.env
          else
            echo "[GitHub] WARNING: No azure-outputs.env file found"
            touch azure-outputs.env
          fi
        env:
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
          AZURE_PRINCIPAL_ID: ${{ vars.AZURE_PRINCIPAL_ID }}
          WORKLOAD_IDENTITY_PRINCIPAL_ID: ${{ vars.WORKLOAD_IDENTITY_PRINCIPAL_ID }}
          WORKLOAD_IDENTITY_NAME: ${{ vars.WORKLOAD_IDENTITY_NAME }}
          AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}
          AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
          DEPLOY_AKS: ${{ vars.DEPLOY_AKS }}
          DEPLOYMENT_MODEL: ${{ vars.DEPLOYMENT_MODEL }}
          AKS_SUBNET: ${{ vars.AKS_SUBNET }}
          AKS_DIAGNOSTICLOGS: ${{ vars.AKS_DIAGNOSTICLOGS }}
      - name: Build and Push Docker Images to ACR
        run: |
          set -euo pipefail

          # Determine ACR name
          ACR_NAME="${AZURE_CONTAINER_REGISTRY_NAME:-${ACR_NAME:-acr$(echo $AZURE_RESOURCE_GROUP | tr -d '-')}}"
          echo "[GitHub] Building and pushing images to ACR: $ACR_NAME"

          # Export variables for the script
          export AZURE_RESOURCE_GROUP="$AZURE_RESOURCE_GROUP"
          export AKS_CLUSTER_NAME="${AKS_CLUSTER_NAME:-aks-$AZURE_RESOURCE_GROUP}"
          export WORKLOAD_IDENTITY_PRINCIPAL_ID="${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}"
          export BUILD_BUILDNUMBER="${GITHUB_RUN_NUMBER}-${GITHUB_SHA:0:7}"

          # Use optimized build with cached base image (1-2 min builds)
          if [ -f "build/scripts/pipeline-internal/build-modern-build-push-images-optimized.sh" ]; then
            echo "[GitHub] Using optimized build with cached base image (fastest)"
            build/scripts/pipeline-internal/build-modern-build-push-images-optimized.sh \
              "$ACR_NAME" \
              "$(pwd)"
          elif [ -f "build/scripts/pipeline-internal/build-modern-build-push-images-parallel.sh" ]; then
            echo "[GitHub] Using parallel build script (fast fallback)"
            build/scripts/pipeline-internal/build-modern-build-push-images-parallel.sh \
              "$ACR_NAME" \
              "$(pwd)"
          else
            echo "[GitHub] ERROR: Build scripts not found"
            exit 1
          fi

          # Export ACR endpoint
          echo "AZURE_CONTAINER_REGISTRY_ENDPOINT=${ACR_NAME}.azurecr.io" >> $GITHUB_ENV
        env:
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AZURE_CONTAINER_REGISTRY_NAME: ${{ vars.AZURE_CONTAINER_REGISTRY_NAME }}
          ACR_NAME: ${{ vars.ACR_NAME }}
          AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
          WORKLOAD_IDENTITY_PRINCIPAL_ID: ${{ vars.WORKLOAD_IDENTITY_PRINCIPAL_ID }}
      - name: Configure AKS credentials
        run: |
          AKS_RG="${AKS_RESOURCE_GROUP:-$AZURE_RESOURCE_GROUP}"
          AKS_NAME="${AKS_CLUSTER_NAME:-greenlight-aks-dev}"
          echo "[GitHub Actions] Retrieving credentials for AKS: $AKS_NAME in RG: $AKS_RG"
          az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing
          kubectl cluster-info

          # Get ACR endpoint if available
          ACR_NAME="${AZURE_CONTAINER_REGISTRY_NAME:-${ACR_NAME:-acr$(echo $AZURE_RESOURCE_GROUP | tr -d '-')}}"
          ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --query loginServer -o tsv 2>/dev/null || echo "")
          if [ -n "$ACR_LOGIN_SERVER" ]; then
            echo "AZURE_CONTAINER_REGISTRY_ENDPOINT=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
            echo "[GitHub Actions] Using ACR: $ACR_LOGIN_SERVER"
            # Log into ACR for image pulls
            az acr login --name "$ACR_NAME" 2>/dev/null || true
          fi
        env:
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}
          AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
          ACR_NAME: ${{ vars.ACR_NAME }}
          AZURE_CONTAINER_REGISTRY_NAME: ${{ vars.AZURE_CONTAINER_REGISTRY_NAME }}
      - name: Deploy to AKS with Helm
        run: |
          # Set up paths
          SCRIPTS_DIR="build/scripts/pipeline-internal"
          PUB_DIR="out/publish"

          # Load Azure deployment outputs
          echo "[GitHub] Loading Azure deployment outputs..."
          if [ -f "azure-outputs.env" ]; then
            echo "[GitHub] Found azure-outputs.env file:"
            cat azure-outputs.env
            source azure-outputs.env
            echo "[GitHub] Loaded $(grep -c '^AZURE_OUTPUT_' azure-outputs.env || echo 0) Azure outputs"
          else
            echo "[GitHub] WARNING: No azure-outputs.env file found"
          fi

          # ðŸ©µ FIX: Map Azure outputs to Helm variable names Rajesh
          echo "[GitHub] Mapping Azure outputs for Helm..."
          export AZURE_OUTPUT_DOCING_BLOBENDPOINT="$AZURE_OUTPUT_DOCING_BLOBENDPOINT"
          export AZURE_OUTPUT_SQLDOCGEN_SQLSERVERFQDN="$AZURE_OUTPUT_SQLDOCGEN_SQLSERVERFQDN"
          export AZURE_OUTPUT_ORLEANS_STORAGE_TABLEENDPOINT="$AZURE_OUTPUT_ORLEANS_STORAGE_TABLEENDPOINT"
          export AZURE_OUTPUT_ORLEANS_STORAGE_BLOBENDPOINT="$AZURE_OUTPUT_ORLEANS_STORAGE_BLOBENDPOINT"
          export AZURE_OUTPUT_AISEARCH_CONNECTIONSTRING="$AZURE_OUTPUT_AISEARCH_CONNECTIONSTRING"
          export AZURE_OUTPUT_INSIGHTS_APPINSIGHTSCONNECTIONSTRING="$AZURE_OUTPUT_INSIGHTS_APPINSIGHTSCONNECTIONSTRING"

          echo "[GitHub] Verifying mapped environment variables..."
          env | grep -E 'DOCING_|SQLSERVER|ORLEANS_|AISEARCH_|APPINSIGHTS_' || echo "No mapped vars found"


          # Pass configuration as environment variables to Helm
          export PVICO_OPENAI_CONNECTIONSTRING="${PVICO_OPENAI_CONNECTIONSTRING:-}"
          export PVICO_ENTRA_CREDENTIALS="${PVICO_ENTRA_CREDENTIALS:-}"
          export HOSTNAME_OVERRIDE="${HOSTNAME_OVERRIDE:-}"
          export PVICO_AZUREMAPS_KEY="${PVICO_AZUREMAPS_KEY:-}"
          export KUBERNETES_RESOURCES_CONFIG="${KUBERNETES_RESOURCES_CONFIG:-}"

          # Make scripts executable
          chmod +x build/scripts/*.sh
          chmod +x "$SCRIPTS_DIR"/*.sh

          # Inject workload identity service account if configured
          if [ -n "${WORKLOAD_IDENTITY_CLIENT_ID:-}" ]; then
            echo "[GitHub] Injecting workload identity service account..."
            AZURE_TENANT_ID="${AZURE_TENANT_ID:-$(az account show --query tenantId -o tsv)}"
            WORKLOAD_IDENTITY_CLIENT_ID="${WORKLOAD_IDENTITY_CLIENT_ID}" \
            AZURE_TENANT_ID="$AZURE_TENANT_ID" \
              "$SCRIPTS_DIR/build-modern-add-wi-serviceaccount.sh" "$PUB_DIR" "$AKS_NAMESPACE" "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-greenlight-app}" || echo "[GitHub] ServiceAccount injection skipped"
          fi

          # âœ… Export variables so child process (Helm script) can see them
          export DOCING_BLOB_EP SQLSERVER_FQDN ORLEANS_TABLE_EP ORLEANS_BLOB_EP AISEARCH_CS APPINSIGHTS_CS
          
          # ðŸ§¾ Debug log of what weâ€™re passing
          echo "[DEBUG] Passing the following env vars into Helm script Rajesh:"
          echo "  DOCING_BLOB_EP=$DOCING_BLOB_EP"
          echo "  SQLSERVER_FQDN=$SQLSERVER_FQDN"
          echo "  ORLEANS_TABLE_EP=$ORLEANS_TABLE_EP"
          echo "  ORLEANS_BLOB_EP=$ORLEANS_BLOB_EP"
          echo "  AISEARCH_CS=$AISEARCH_CS"
          echo "  APPINSIGHTS_CS=$APPINSIGHTS_CS"
          
          # Double-check visibility in current shell
          echo "[DEBUG] env | grep verification:"
          env | grep -E 'DOCING_|SQLSERVER|ORLEANS_|AISEARCH_|APPINSIGHTS_'
          
          # ðŸš€ Run the Helm deployment script
          echo "[DEBUG] Executing: build/scripts/build-modern-helm-deploy-clean.sh \"$PUB_DIR\" \"$HELM_RELEASE\" \"$AKS_NAMESPACE\""
          build/scripts/build-modern-helm-deploy-clean.sh "$PUB_DIR" "$HELM_RELEASE" "$AKS_NAMESPACE"

        env:
          HELM_RELEASE: ${{ vars.HELM_RELEASE }}
          AKS_NAMESPACE: ${{ vars.AKS_NAMESPACE }}
          PVICO_OPENAI_CONNECTIONSTRING: ${{ secrets.PVICO_OPENAI_CONNECTIONSTRING }}
          PVICO_ENTRA_CREDENTIALS: ${{ secrets.PVICO_ENTRA_CREDENTIALS }}
          HOSTNAME_OVERRIDE: ${{ vars.HOSTNAME_OVERRIDE }}
          PVICO_AZUREMAPS_KEY: ${{ secrets.PVICO_AZUREMAPS_KEY }}
          KUBERNETES_RESOURCES_CONFIG: ${{ vars.KUBERNETES_RESOURCES_CONFIG }}
          WORKLOAD_IDENTITY_CLIENT_ID: ${{ vars.WORKLOAD_IDENTITY_CLIENT_ID }}
          WORKLOAD_IDENTITY_SERVICE_ACCOUNT: ${{ vars.WORKLOAD_IDENTITY_SERVICE_ACCOUNT }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ vars.AZURE_CLIENT_SECRET }}
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}


          # Azure outputs are loaded from azure-outputs.env file directly
      - name: Expose endpoints and setup Front Door
        run: |
          set -euo pipefail

          SCRIPTS_DIR="build/scripts/pipeline-internal"
          chmod +x "$SCRIPTS_DIR"/*.sh

          # Ensure we have cluster context
          AKS_RG="${AKS_RESOURCE_GROUP:-$AZURE_RESOURCE_GROUP}"
          AKS_NAME="${AKS_CLUSTER_NAME:-greenlight-aks-dev}"
          az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing

          # Expose services based on deployment model
          DEPLOYMENT_MODEL="${DEPLOYMENT_MODEL:-public}"
          echo "[GitHub] Configuring service endpoints for $DEPLOYMENT_MODEL deployment..."

          DISABLE_EXPOSEDENDPOINTS="${DISABLE_EXPOSEDENDPOINTS:-false}" \
            "$SCRIPTS_DIR/build-modern-expose-endpoints.sh" "${AKS_NAMESPACE}" "$DEPLOYMENT_MODEL"

          # Setup Azure Front Door only for public and hybrid modes
          if [[ "$DEPLOYMENT_MODEL" == "public" ]] || [[ "$DEPLOYMENT_MODEL" == "hybrid" ]]; then
            echo "[GitHub] Creating Azure Front Door for $DEPLOYMENT_MODEL deployment..."
            DISABLE_EXPOSEDENDPOINTS="${DISABLE_EXPOSEDENDPOINTS:-false}" \
              "$SCRIPTS_DIR/build-modern-afd-setup.sh" "$AZURE_RESOURCE_GROUP" "$AZURE_LOCATION" "greenlight-${ENVIRONMENT}" "${AKS_NAMESPACE}"
          else
            echo "[GitHub] Skipping Azure Front Door setup for private deployment"
          fi
        env:
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
          AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}
          AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
          AKS_NAMESPACE: ${{ vars.AKS_NAMESPACE }}
          DEPLOYMENT_MODEL: ${{ vars.DEPLOYMENT_MODEL }}
          DISABLE_EXPOSEDENDPOINTS: ${{ vars.DISABLE_EXPOSEDENDPOINTS }}
          ENVIRONMENT: ${{ github.event.inputs.environment }}
      - name: Run DB SetupManager job
        run: |
          set -euo pipefail

          SCRIPTS_DIR="build/scripts/pipeline-internal"
          chmod +x "$SCRIPTS_DIR"/*.sh

          # Ensure we have cluster context
          AKS_RG="${AKS_RESOURCE_GROUP:-$AZURE_RESOURCE_GROUP}"
          # AKS_NAME="greenlight-aks-dev" - Rajesh
          AKS_NAME="greenlight-aks-dev"
          az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing

          # Run job from inside cluster context with longer backoff for workload identity token propagation
          "$SCRIPTS_DIR/build-modern-run-db-setup-job.sh" "${AKS_NAMESPACE}" 120
        env:
          AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
          AKS_RESOURCE_GROUP: ${{ vars.AKS_RESOURCE_GROUP }}
          AKS_CLUSTER_NAME: ${{ vars.AKS_CLUSTER_NAME }}
          AKS_NAMESPACE: ${{ vars.AKS_NAMESPACE }}
