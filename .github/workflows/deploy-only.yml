name: deploy-only

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy-only:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: src
    env:
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      AZURE_ENV_NAME: ${{ vars.AZURE_ENV_NAME }}
      AZURE_RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      AZURE_LOCATION: ${{ vars.AZURE_LOCATION }}
      AZURE_CLOUD: ${{ vars.AZURE_CLOUD }}
      AZURE_CAE_WORKLOAD_TYPE: ${{ vars.AZURE_CAE_WORKLOAD_TYPE }}
      HOSTNAMEOVERRIDE: ${{ vars.HOSTNAMEOVERRIDE }}
      MEMORY_BACKEND: ${{ vars.MEMORY_BACKEND }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate deployment parameters (no provisioning)
        run: |
          # Ensure that only one of AZURE_RESOURCE_GROUP or AZURE_ENV_NAME is provided.
          if [ -n "${AZURE_RESOURCE_GROUP}" ] && [ -n "${AZURE_ENV_NAME}" ]; then
            echo "Error: Both AZURE_RESOURCE_GROUP and AZURE_ENV_NAME are defined. Please provide only AZURE_RESOURCE_GROUP."
            exit 1
          fi

          # If only AZURE_ENV_NAME is provided, set AZURE_RESOURCE_GROUP to "rg-<AZURE_ENV_NAME>"
          if [ -z "${AZURE_RESOURCE_GROUP}" ] && [ -n "${AZURE_ENV_NAME}" ]; then
            AZURE_RESOURCE_GROUP="rg-${AZURE_ENV_NAME}"
            echo "Setting AZURE_RESOURCE_GROUP to ${AZURE_RESOURCE_GROUP} based on AZURE_ENV_NAME."
            echo "AZURE_RESOURCE_GROUP=${AZURE_RESOURCE_GROUP}" >> $GITHUB_ENV
          fi

          # If neither is provided, exit with an error.
          if [ -z "${AZURE_RESOURCE_GROUP}" ]; then
            echo "Error: Either AZURE_RESOURCE_GROUP or AZURE_ENV_NAME must be defined."
            exit 1
          fi

          # Set AZURE_ENV_NAME to AZURE_RESOURCE_GROUP, but remove "rg-" prefix if present.
          AZURE_ENV_NAME=$(echo "${AZURE_RESOURCE_GROUP}" | sed 's/^rg-//')
          echo "AZURE_ENV_NAME=${AZURE_ENV_NAME}" >> $GITHUB_ENV

          # Default MEMORY_BACKEND if not set (deployment-time config only)
          if [ -z "${MEMORY_BACKEND}" ]; then
            echo "No MEMORY_BACKEND specified, defaulting to 'aisearch'"
            MEMORY_BACKEND="aisearch"
            echo "MEMORY_BACKEND=${MEMORY_BACKEND}" >> $GITHUB_ENV
          fi

          echo "Memory backend selected: ${MEMORY_BACKEND}"

      - name: Rewrite Azure Credentials to old format if necessary
        run: |
          echo "Original AZURE_CREDENTIALS:"
          echo "${AZURE_CREDENTIALS}" | jq '.'

          if ! echo "${AZURE_CREDENTIALS}" | jq -e 'has("clientSecret")' > /dev/null; then
            AZURE_CREDENTIALS_REWRITTEN=$(echo "${AZURE_CREDENTIALS}" | jq -c --arg subscriptionId "${AZURE_SUBSCRIPTION_ID}" '{ clientId: .appId, displayName: .displayName, clientSecret: .password, tenantId: .tenant, subscriptionId: $subscriptionId }')
          else
            AZURE_CREDENTIALS_REWRITTEN=$(echo "${AZURE_CREDENTIALS}" | jq -c --arg subscriptionId "${AZURE_SUBSCRIPTION_ID}" '. + {subscriptionId: $subscriptionId}')
          fi
          echo "AZURE_CREDENTIALS_REWRITTEN=${AZURE_CREDENTIALS_REWRITTEN}" >> $GITHUB_ENV
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login with Azure CLI (Client Credentials)
        uses: Azure/login@v2
        with:
          creds: ${{ env.AZURE_CREDENTIALS_REWRITTEN }}
          environment: ${{ vars.AZURE_CLOUD }}

      - name: Verify Resource Group exists (no create)
        run: |
          echo "Validating Resource Group exists: ${AZURE_RESOURCE_GROUP}..."
          az account set --subscription "${AZURE_SUBSCRIPTION_ID}"
          exists=$(az group exists --name "${AZURE_RESOURCE_GROUP}")
          if [ "$exists" != "true" ]; then
            echo "Error: Resource group ${AZURE_RESOURCE_GROUP} does not exist. Please provision infrastructure before running this workflow."
            exit 1
          fi

      - name: Use DotNet SDK 9.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.202

      - name: Install WASM Tools workload
        run: dotnet workload install wasm-tools

      - name: Install AZD
        uses: Azure/setup-azd@v2

      - name: Set up infra folder (preserve AZD environment)
        run: |
          rm -rf infra
          cp -r infra.public infra

      - name: Set execute permission on .sh and .ps1 scripts in the ./deploy folder
        run: chmod ugo+x deploy/*.sh deploy/*.ps1

      - name: Activate azure-ci.yaml for CI/CD deployment
        run: |
          rm -f azure.yaml
          cp azure-ci.yaml azure.yaml

      - name: Log in with Azure Developer CLI (Client Credentials)
        if: ${{ env.AZURE_CREDENTIALS != '' }}
        run: |
          info=$(echo "${AZURE_CREDENTIALS}" | jq -r '.')
          client_id=$(echo "${info}" | jq -r '.appId // .clientId')
          client_secret=$(echo "${info}" | jq -r '.password // .clientSecret')
          tenant_id=$(echo "${info}" | jq -r '.tenant // .tenantId')
          azd config set cloud.name ${AZURE_CLOUD}
          echo "Current AZD cloud name: $(az cloud show --query name -o tsv)"
          azd auth login --client-id "${client_id}" --client-secret "${client_secret}" --tenant-id "${tenant_id}"
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
          AZURE_CLOUD: ${{ vars.AZURE_CLOUD }}

      - name: Initialize/select AZD environment (no provisioning)
        env:
          AZD_INITIAL_ENVIRONMENT_CONFIG: ${{ secrets.AZD_INITIAL_ENVIRONMENT_CONFIG }}
        run: |
          # Attempt to select the environment; if it doesn't exist locally, create the local env without provisioning resources.
          set -e
          azd env select -n "${AZURE_ENV_NAME}" || azd env new "${AZURE_ENV_NAME}" --subscription "${AZURE_SUBSCRIPTION_ID}" --location "${AZURE_LOCATION}"

      - name: Create appsettings.Production.json file
        run: |
          cp Microsoft.Greenlight.AppHost/appsettings.json Microsoft.Greenlight.AppHost/appsettings.Production.json
          jq --arg openai_planner "${openai_planner}" --arg azure_maps_key "${ServiceConfiguration__AzureMaps__Key}" '
            .ConnectionStrings = (.ConnectionStrings // {}) |
            .ConnectionStrings["openai-planner"] = $openai_planner |
            .ServiceConfiguration.AzureMaps = (.ServiceConfiguration.AzureMaps // {}) |
            .ServiceConfiguration.AzureMaps.Key = $azure_maps_key' \
            Microsoft.Greenlight.AppHost/appsettings.Production.json > Microsoft.Greenlight.AppHost/appsettings.Production.json.tmp
          mv Microsoft.Greenlight.AppHost/appsettings.Production.json.tmp Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "*****************************************************************************************"
          cat Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "*****************************************************************************************"
        env:
          openai_planner: ${{ secrets.PVICO_OPENAI_CONNECTIONSTRING }}
          ServiceConfiguration__AzureMaps__Key: ${{ secrets.PVICO_AZUREMAPS_KEY }}

      - name: Add AzureAd configuration to appsettings.Production.json
        run: |
          if [ -z "${PVICO_ENTRA_CREDENTIALS}" ]; then
            echo "PVICO_ENTRA_CREDENTIALS is not set or is empty. Skipping AzureAd configuration."
            exit 0
          fi
          appsettings=$(cat Microsoft.Greenlight.AppHost/appsettings.Production.json)
          azureAdConfig=$(echo "${PVICO_ENTRA_CREDENTIALS}")
          merged=$(echo "${appsettings}" | jq --argjson azureAdConfig "${azureAdConfig}" '. + {AzureAd: $azureAdConfig}')
          echo "${merged}" > Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "*****************************************************************************************"
          cat Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "*****************************************************************************************"
        env:
          PVICO_ENTRA_CREDENTIALS: ${{ secrets.PVICO_ENTRA_CREDENTIALS }}

      - name: Add HostNameOverride configuration to appsettings.Production.json
        if: ${{ env.HOSTNAMEOVERRIDE != '' }}
        run: |
          echo "Adding HostNameOverride configuration..."
          appsettings=$(cat Microsoft.Greenlight.AppHost/appsettings.Production.json)
          merged=$(echo "${appsettings}" | jq --argjson hostNameOverride "${HOSTNAMEOVERRIDE}" '
            .ServiceConfiguration = (.ServiceConfiguration // {}) + {HostNameOverride: $hostNameOverride}
          ')
          echo "${merged}" > Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "Updated appsettings.Production.json:"
          cat Microsoft.Greenlight.AppHost/appsettings.Production.json
        env:
          HOSTNAMEOVERRIDE: ${{ env.HOSTNAMEOVERRIDE }}

      - name: Configure Memory Backend
        run: |
          echo "Configuring memory backend: ${MEMORY_BACKEND}"
          appsettings=$(cat Microsoft.Greenlight.AppHost/appsettings.Production.json)
          usePostgresMemory="false"
          if [ "${MEMORY_BACKEND}" == "postgres" ]; then
            usePostgresMemory="true"
            echo "Setting UsePostgresMemory to true (using PostgreSQL backend)"
          else
            echo "Setting UsePostgresMemory to false (using AI Search backend)"
          fi
          updated=$(echo "${appsettings}" | jq --argjson usePostgresMemory "$usePostgresMemory" '
            .ServiceConfiguration.GreenlightServices.Global.UsePostgresMemory = $usePostgresMemory
          ')
          echo "${updated}" > Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "Updated UsePostgresMemory setting to: $usePostgresMemory"
          echo "*****************************************************************************************"
          cat Microsoft.Greenlight.AppHost/appsettings.Production.json | grep -A 3 "UsePostgresMemory"
          echo "*****************************************************************************************"
        env:
          MEMORY_BACKEND: ${{ env.MEMORY_BACKEND }}

      - name: Configure Azure SignalR usage
        if: env.ENABLE_AZURE_SIGNALR != ''
        run: |
          echo "Configuring Azure SignalR usage based on ENABLE_AZURE_SIGNALR: ${ENABLE_AZURE_SIGNALR}"
          appsettings=$(cat Microsoft.Greenlight.AppHost/appsettings.Production.json)
          useAzureSignalR=$(echo "${ENABLE_AZURE_SIGNALR}" | tr '[:upper:]' '[:lower:]')
          updated=$(echo "${appsettings}" | jq --argjson useAzureSignalR $([ "$useAzureSignalR" = "false" ] && echo "false" || echo "true") '
            .ServiceConfiguration.GreenlightServices.Scalability.UseAzureSignalR = $useAzureSignalR
          ')
          echo "${updated}" > Microsoft.Greenlight.AppHost/appsettings.Production.json
          echo "Updated UseAzureSignalR setting to: $([ "$useAzureSignalR" = "false" ] && echo "false" || echo "true")"
          echo "*****************************************************************************************"
          cat Microsoft.Greenlight.AppHost/appsettings.Production.json | grep -A 3 "UseAzureSignalR"
          echo "*****************************************************************************************"
        env:
          ENABLE_AZURE_SIGNALR: ${{ vars.ENABLE_AZURE_SIGNALR }}

      - name: Deploy db setup manager first
        run: |
          export SKIP_POSTDEPLOY=true
          azd deploy db-setupmanager --no-prompt
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          AZURE_CAE_WORKLOAD_TYPE: ${{ vars.AZURE_CAE_WORKLOAD_TYPE }}

      - name: Deploy Rest of Application
        run: |
          export SKIP_POSTDEPLOY=false
          azd deploy --no-prompt
        env:
          AZURE_RESOURCE_GROUP: ${{ env.AZURE_RESOURCE_GROUP }}
          AZURE_CAE_WORKLOAD_TYPE: ${{ vars.AZURE_CAE_WORKLOAD_TYPE }}
          PVICO_OPENAI_CONNECTIONSTRING: ${{ secrets.PVICO_OPENAI_CONNECTIONSTRING }}
          PVICO_OPENAI_RESOURCEGROUP: ${{ vars.PVICO_OPENAI_RESOURCEGROUP }}
