#!/usr/bin/env bash
set -euo pipefail

# Deploy Azure Bicep infrastructure from Aspire 9.4 publish output.
# This script handles both subscription-scoped and resource-group-scoped deployments.
# Usage: build/scripts/build-modern-deploy-azure.sh <publish-output-dir> <resource-group> <location>

# Disable color output for CI/CD environments
export TERM=dumb
export NO_COLOR=1

# Enable verbose output only if DEBUG is set
if [[ "${DEBUG:-}" == "true" ]]; then set -x; fi

OUT_DIR=${1:-out/publish}
RESOURCE_GROUP=${2:?Missing resource group}
LOCATION=${3:?Missing location}

# Tools
if ! command -v az >/dev/null 2>&1; then
  echo "[modern] Error: Azure CLI is not installed" >&2
  exit 1
fi

echo "[modern] Deploying Azure infrastructure from Aspire publish"
echo "[modern] Output directory: $OUT_DIR"
echo "[modern] Resource group: $RESOURCE_GROUP"
echo "[modern] Location: $LOCATION"

# Check if main.bicep exists
MAIN_BICEP="$OUT_DIR/main.bicep"
if [[ ! -f "$MAIN_BICEP" ]]; then
  echo "[modern] No Azure infrastructure to deploy - main.bicep not found"
  echo "[modern] This is expected for Kubernetes-only deployments"
  exit 0
fi

echo "[modern] Found Aspire-generated Azure infrastructure: $MAIN_BICEP"

# Check if the Bicep template expects administratorPassword parameter
# Aspire 9.4+ uses Azure AD authentication exclusively, older deployments may need passwords
NEEDS_PASSWORD=false
if grep -q "param administratorPassword" "$MAIN_BICEP" 2>/dev/null; then
  NEEDS_PASSWORD=true
  echo "[modern] Detected password parameter in Bicep template (pre-9.4 or custom deployment)"

  # Deterministic Postgres admin password unless provided
  if [[ -z "${POSTGRES_ADMIN_PASSWORD:-}" ]]; then
    SUBSCRIPTION_ID=$(az account show --query id -o tsv 2>/dev/null || echo "unknown-subscription")
    SEED="${SUBSCRIPTION_ID}-${RESOURCE_GROUP}-pgadmin-secret"
    # sha256 first 20 chars + complex suffix
    if command -v shasum >/dev/null 2>&1; then
      HASH=$(echo -n "$SEED" | shasum -a 256 | cut -c1-20)
    else
      HASH=$(printf %s "$SEED" | openssl dgst -sha256 -r | cut -d' ' -f1 | cut -c1-20)
    fi
    POSTGRES_ADMIN_PASSWORD="${HASH}Aa1!"
    echo "[modern] Generated deterministic Postgres password (redacted)."
  else
    echo "[modern] Using provided POSTGRES_ADMIN_PASSWORD (redacted)."
  fi
else
  echo "[modern] No password parameter detected - using Aspire 9.4+ Azure AD authentication"
fi

# Check if main.bicep is subscription-scoped
IS_SUBSCRIPTION_SCOPED=false
if grep -q "targetScope.*=.*'subscription'" "$MAIN_BICEP" 2>/dev/null; then
  IS_SUBSCRIPTION_SCOPED=true
  echo "[modern] Detected subscription-scoped Bicep template"
fi

# Create deployment name with timestamp
DEPLOYMENT_NAME="aspire-infra-$(date +%s)"

# Decide which principal to use for role assignment (prefer workload identity principal if supplied via variable group)
if [[ -n "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" ]]; then
  echo "[modern] Using workload identity principal for role assignments: $WORKLOAD_IDENTITY_PRINCIPAL_ID"
  AZURE_PRINCIPAL_ID="$WORKLOAD_IDENTITY_PRINCIPAL_ID"
  # For SQL Server role assignments, we need the managed identity name
  if [[ -n "${WORKLOAD_IDENTITY_NAME:-}" ]]; then
    AZURE_PRINCIPAL_NAME="$WORKLOAD_IDENTITY_NAME"
    echo "[modern] Workload identity name: $AZURE_PRINCIPAL_NAME"
  fi
else
  echo "[modern] Using service principal identity for role assignments (WORKLOAD_IDENTITY_PRINCIPAL_ID not set)"
fi

# Deployment approach based on scope and permissions
DEPLOYMENT_SUCCESS=false

if [[ "$IS_SUBSCRIPTION_SCOPED" == true ]]; then
  echo "[modern] Attempting subscription-scoped deployment..."

  # Build parameters for subscription-scoped template
  PARAMS="resourceGroupName=$RESOURCE_GROUP location=$LOCATION"

  if [[ -n "${AZURE_SUBNET_PE:-}" ]]; then
    PARAMS="$PARAMS peSubnet=${AZURE_SUBNET_PE}"
  fi

  # Workload identity parameters removed - not generated by AppHost when using PublishAsExisting()
  # The principalId parameter handles the workload identity reference

  if [[ -n "${AZURE_PRINCIPAL_ID:-}" ]]; then
    PARAMS="$PARAMS principalId=$AZURE_PRINCIPAL_ID"
    # Add principalName if we have it (required by role alignment script for SQL Server)
    if [[ -n "${AZURE_PRINCIPAL_NAME:-}" ]]; then
      PARAMS="$PARAMS principalName=$AZURE_PRINCIPAL_NAME"
    fi
  fi
  if [[ "$NEEDS_PASSWORD" == true ]]; then
    PARAMS="$PARAMS administratorPassword=$POSTGRES_ADMIN_PASSWORD"
  fi

  # Try subscription-scoped deployment first (for customers with full permissions)
  if az deployment sub create \
    --name "$DEPLOYMENT_NAME" \
    --location "$LOCATION" \
    --template-file "$MAIN_BICEP" \
    --parameters $PARAMS \
    --output none 2>/dev/null; then

    echo "[modern] Subscription-scoped deployment succeeded"
    DEPLOYMENT_SUCCESS=true
  else
    echo "[modern] Subscription-scoped deployment failed - likely insufficient permissions"
    echo "[modern] Converting to resource group scope for compatibility..."

    # Run the scope fix script to convert to resource group scope
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ -f "$SCRIPT_DIR/build-modern-fix-subscription-scope.sh" ]]; then
      "$SCRIPT_DIR/build-modern-fix-subscription-scope.sh" "$OUT_DIR"
    fi

    # Ensure resource group exists (friendly gesture)
    if ! az group show --name "$RESOURCE_GROUP" >/dev/null 2>&1; then
      echo "[modern] Resource group $RESOURCE_GROUP does not exist."
      echo "[modern] Attempting to create resource group $RESOURCE_GROUP in $LOCATION..."
      if az group create --name "$RESOURCE_GROUP" --location "$LOCATION" >/dev/null 2>&1; then
        echo "[modern] Resource group $RESOURCE_GROUP created successfully."
      else
        echo "[modern] Warning: Failed to create resource group $RESOURCE_GROUP."
        echo "[modern] The service principal may not have subscription-level permissions."
        echo "[modern] Please ensure the resource group exists before running this script."
        exit 1
      fi
    fi

    # Try resource group-scoped deployment
    echo "[modern] Attempting resource group-scoped deployment..."
  fi
fi

# If not subscription-scoped or subscription deployment failed, try resource group scope
if [[ "$DEPLOYMENT_SUCCESS" == false ]]; then
  # Ensure resource group exists first
  if ! az group show --name "$RESOURCE_GROUP" >/dev/null 2>&1; then
    echo "[modern] Resource group $RESOURCE_GROUP does not exist."
    echo "[modern] Attempting to create resource group $RESOURCE_GROUP in $LOCATION..."
    if az group create --name "$RESOURCE_GROUP" --location "$LOCATION" >/dev/null 2>&1; then
      echo "[modern] Resource group $RESOURCE_GROUP created successfully."
    else
      echo "[modern] Error: Resource group $RESOURCE_GROUP does not exist and could not be created."
      echo "[modern] Please create the resource group manually or grant subscription-level permissions."
      exit 1
    fi
  fi

  # Build parameters for resource group-scoped template
  # Even though marked as unused after conversion, Bicep still expects these parameters
  PARAMS="location=$LOCATION"

  if [[ -n "${AZURE_SUBNET_PE:-}" ]]; then
    PARAMS="$PARAMS peSubnet=${AZURE_SUBNET_PE}"
  fi

  # Workload identity parameters removed - not generated by AppHost when using PublishAsExisting()
  # The principalId parameter handles the workload identity reference

  # Pass principalId if available
  if [[ -n "${AZURE_PRINCIPAL_ID:-}" ]]; then
    PARAMS="$PARAMS principalId=$AZURE_PRINCIPAL_ID"
    # Add principalName if we have it (required by role alignment script for SQL Server)
    if [[ -n "${AZURE_PRINCIPAL_NAME:-}" ]]; then
      PARAMS="$PARAMS principalName=$AZURE_PRINCIPAL_NAME"
    fi
  else
    echo "[modern] ERROR: AZURE_PRINCIPAL_ID is required for role assignments"
    echo "[modern] Please ensure the service principal ID is provided via environment variable"
    echo "[modern] In Azure DevOps, use 'addSpnToEnvironment: true' in AzureCLI task"
    exit 1
  fi
  # Resource group name is still required even if unused
  PARAMS="$PARAMS resourceGroupName=$RESOURCE_GROUP"
  if [[ "$NEEDS_PASSWORD" == true ]]; then
    PARAMS="$PARAMS administratorPassword=$POSTGRES_ADMIN_PASSWORD"
  fi

  # Deploy at resource group scope
if az deployment group create \
    --name "$DEPLOYMENT_NAME" \
    --resource-group "$RESOURCE_GROUP" \
    --template-file "$MAIN_BICEP" \
    --parameters $PARAMS \
    --output none; then

    echo "[modern] Resource group-scoped deployment succeeded"
    DEPLOYMENT_SUCCESS=true
  else
    echo "[modern] ERROR: Deployment failed at both subscription and resource group scope"
    echo "[modern] Please check the Azure portal for deployment details: $DEPLOYMENT_NAME"
    exit 1
  fi
fi

# If configured, apply CostControl tags post-deployment using Azure CLI merge semantics
# Ref: az tag update --operation Merge (https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/tag-resources-cli#apply-tags)
if [[ "${COSTCONTROL_IGNORE:-false}" == "true" ]] || [[ -f "$OUT_DIR/.apply_costcontrol_tags_post_deploy" ]]; then
  echo "[modern] Applying CostControl=ignore tags to deployed resources (post-deploy)â€¦"
  # Tag the resource group
  RG_ID=$(az group show -n "$RESOURCE_GROUP" --query id -o tsv 2>/dev/null || echo "")
  if [[ -n "$RG_ID" ]]; then
    az tag update --resource-id "$RG_ID" --operation Merge --tags CostControl=ignore ManagedBy=Aspire >/dev/null 2>&1 || true
  fi
  # Tag each resource in the group (merge to preserve existing tags)
  az resource list -g "$RESOURCE_GROUP" --query "[].id" -o tsv | while read -r rid; do
    if [[ -n "$rid" ]]; then
      az tag update --resource-id "$rid" --operation Merge --tags CostControl=ignore ManagedBy=Aspire >/dev/null 2>&1 || true
    fi
  done
  echo "[modern] Post-deployment tagging complete."
fi

# If configured, apply SecurityControl overrides to storage accounts (enable public network access and add SecurityControl=ignore tags)
if [[ "${SECURITYCONTROL_IGNORE:-false}" == "true" ]] || [[ -f "$OUT_DIR/.apply_securitycontrol_overrides_post_deploy" ]]; then
  # Find all storage accounts in the resource group
  STORAGE_ACCOUNTS=$(az storage account list -g "$RESOURCE_GROUP" --query "[].name" -o tsv 2>/dev/null || echo "")

  if [[ -n "$STORAGE_ACCOUNTS" ]]; then
    while read -r storage_name; do
      if [[ -n "$storage_name" ]]; then
        # Enable public network access
        az storage account update -n "$storage_name" -g "$RESOURCE_GROUP" --public-network-access Enabled --default-action Allow --bypass AzureServices >/dev/null 2>&1 || true

        # Add SecurityControl=ignore tag to the storage account
        STORAGE_ID=$(az storage account show -n "$storage_name" -g "$RESOURCE_GROUP" --query id -o tsv 2>/dev/null || echo "")
        if [[ -n "$STORAGE_ID" ]]; then
          az tag update --resource-id "$STORAGE_ID" --operation Merge --tags SecurityControl=ignore >/dev/null 2>&1 || true
        fi
      fi
    done <<< "$STORAGE_ACCOUNTS"
  fi
fi

# Grant RBAC for storage (blob + table) to pipeline identity if storage endpoints are present
grant_storage_roles() {
  local rg="$RESOURCE_GROUP"
  local principal_id="${AZURE_PRINCIPAL_ID:-}"
  if [[ -z "$principal_id" ]]; then
    echo "[modern] WARNING: No principal ID available for role assignments; skipping storage role grants"
    return 0
  fi

  # Prefer explicit endpoints from outputs
  local blob_ep="${AZURE_OUTPUT_orleansStorageBlobEndpoint:-${AZURE_OUTPUT_docingBlobEndpoint:-}}"
  local table_ep="${AZURE_OUTPUT_orleansStorageTableEndpoint:-${AZURE_OUTPUT_docingTableEndpoint:-}}"

  # Derive storage account name from endpoint, e.g., https://docingxyz.blob.core.windows.net/
  local acct=""
  if [[ -n "$blob_ep" ]]; then
    acct=$(echo "$blob_ep" | sed -E 's#https?://([^\.]+)\..*#\1#')
  elif [[ -n "$table_ep" ]]; then
    acct=$(echo "$table_ep" | sed -E 's#https?://([^\.]+)\..*#\1#')
  fi

  if [[ -z "$acct" ]]; then
    echo "[modern] INFO: No storage endpoints found in outputs; skipping storage role grants"
    return 0
  fi

  echo "[modern] Granting storage roles on account: $acct"
  local scope
  scope=$(az storage account show -g "$rg" -n "$acct" --query id -o tsv 2>/dev/null || echo "")
  if [[ -z "$scope" ]]; then
    echo "[modern] WARNING: Could not resolve storage account $acct in $rg; skipping role grants"
    return 0
  fi

  # Roles needed for Orleans + blob usage
  local roles=(
    "Storage Blob Data Contributor"
    "Storage Table Data Contributor"
  )
  for role in "${roles[@]}"; do
    echo "[modern] Assigning role '$role' to principal $principal_id on $scope"
    az role assignment create --assignee "$principal_id" --role "$role" --scope "$scope" >/dev/null 2>&1 || true
  done
}

# Export connection strings as environment variables for Helm deployment
echo "[modern] Extracting deployment outputs for Helm configuration..."

# Get deployment outputs based on scope
if [[ "$IS_SUBSCRIPTION_SCOPED" == true ]] && az deployment sub show --name "$DEPLOYMENT_NAME" >/dev/null 2>&1; then
  OUTPUTS=$(az deployment sub show --name "$DEPLOYMENT_NAME" --query properties.outputs -o json 2>/dev/null || echo "{}")
else
  OUTPUTS=$(az deployment group show --name "$DEPLOYMENT_NAME" --resource-group "$RESOURCE_GROUP" --query properties.outputs -o json 2>/dev/null || echo "{}")
fi

# Export key outputs as environment variables for Helm to use
if [[ "$OUTPUTS" != "{}" ]]; then
  # Create an output file for ADO pipeline to consume
  OUTPUT_FILE="${AZURE_OUTPUT_FILE:-azure-outputs.env}"
  echo "[modern] Writing outputs to: $OUTPUT_FILE"
  > "$OUTPUT_FILE"  # Clear/create file

  # Parse and export connection strings with normalized UPPER_SNAKE_CASE names
  for key in $(echo "$OUTPUTS" | jq -r 'keys[]'); do
    VALUE=$(echo "$OUTPUTS" | jq -r ".${key}.value // empty")
    if [[ -n "$VALUE" ]]; then
      # Normalize key to UPPER_SNAKE_CASE to match Helm expectations
      # Convert to uppercase and ensure underscores are preserved
      NORMALIZED_KEY=$(echo "$key" | tr '[:lower:]' '[:upper:]')

      export "AZURE_OUTPUT_${NORMALIZED_KEY}=${VALUE}"

      # Also write to file for persistence across ADO tasks
      echo "AZURE_OUTPUT_${NORMALIZED_KEY}=${VALUE}" >> "$OUTPUT_FILE"

      # Don't echo sensitive values, just indicate they're set
      if [[ "$key" == *"Connection"* ]] || [[ "$key" == *"Password"* ]] || [[ "$key" == *"Key"* ]] || [[ "$key" == *"Endpoint"* ]]; then
        echo "[modern] Exported: AZURE_OUTPUT_${NORMALIZED_KEY} (sensitive - redacted)"
      else
        echo "[modern] Exported: AZURE_OUTPUT_${NORMALIZED_KEY}=${VALUE}"
      fi
    fi
  done
  echo "[modern] Wrote $(echo "$OUTPUTS" | jq -r 'keys | length') outputs to $OUTPUT_FILE"
else
  echo "[modern] Warning: No deployment outputs found - Helm may need manual configuration"
fi

echo "[modern] Azure infrastructure deployment complete"

# Post-deployment: ensure RBAC for storage endpoints (Orleans/Table/Blob)
grant_storage_roles

# SQL permissions are handled by Bicep template rewriting
# The workload identity is set as SQL Server admin directly in the Bicep templates
sql_permissions_info() {
  echo "[modern] SQL permissions are handled by Bicep template rewriting"
  echo "[modern] The workload identity is set as SQL Server admin directly in the templates"
  echo "[modern] No post-deployment SQL permission grants needed"
}

# Post-deployment: SQL permissions info
sql_permissions_info

# SQL permissions are now handled by Bicep template rewriting during post-publish fixes
# The workload identity is set as SQL Server admin directly in the Bicep templates
echo "[modern] SQL permissions are managed by Bicep template rewriting"

# Output summary
echo ""
echo "========================================="
echo "Azure Infrastructure Deployment Summary"
echo "========================================="
echo "  Resource Group: $RESOURCE_GROUP"
echo "  Location: $LOCATION"
echo "  Deployment: $DEPLOYMENT_NAME"
echo "  Template: $MAIN_BICEP"
echo "  Status: SUCCESS"
echo ""
echo "Next: Deploy Kubernetes workloads using Helm"
echo "The Helm deployment script will use the exported AZURE_OUTPUT_* variables"
echo "========================================="
