trigger: none

parameters:
  - name: environment
    displayName: 'Target Environment'
    type: string
    default: 'dev'
  - name: variableGroup
    displayName: 'Variable Group Name (optional - auto-derived from environment)'
    type: string
    default: 'auto'

variables:
  - name: computedVariableGroup
    ${{ if eq(parameters.variableGroup, 'auto') }}:
      value: greenlight-ado${{ parameters.environment }}
    ${{ else }}:
      value: ${{ parameters.variableGroup }}
  - name: environmentSuffix
    value: ${{ parameters.environment }}
  - name: computedNamespace
    value: greenlight-${{ parameters.environment }}
  - name: computedHelmRelease
    value: greenlight-${{ parameters.environment }}
  - name: computedResourcePrefix
    value: greenlight-${{ parameters.environment }}
  - group: ${{ variables.computedVariableGroup }}

stages:
  - stage: deploy
    displayName: Build, Publish, and Deploy (${{ parameters.environment }})
    jobs:
      - job: deploy
        pool:
          name: "ipsenergy-v6ds-pool"
        variables:
          - name: GREENLIGHT_ENVIRONMENT
            value: ${{ parameters.environment }}
          - name: GREENLIGHT_VARIABLE_GROUP
            value: ${{ variables.computedVariableGroup }}
          - name: GREENLIGHT_NAMESPACE
            value: ${{ variables.computedNamespace }}
          - name: GREENLIGHT_HELM_RELEASE
            value: ${{ variables.computedHelmRelease }}
          - name: GREENLIGHT_RESOURCE_PREFIX
            value: ${{ variables.computedResourcePrefix }}
        steps:
          - checkout: self
            fetchDepth: 1

          - script: |
                set -euo pipefail
                echo "========================================="
                echo "Pipeline Configuration Validation"
                echo "========================================="
                echo ""
                echo "Environment Settings:"
                echo "  Environment: $(GREENLIGHT_ENVIRONMENT)"
                echo "  Variable Group: $(GREENLIGHT_VARIABLE_GROUP)"
                echo "  Target Namespace: $(GREENLIGHT_NAMESPACE)"
                echo "  Helm Release: $(GREENLIGHT_HELM_RELEASE)"
                echo "  Resource Prefix: $(GREENLIGHT_RESOURCE_PREFIX)"
                echo ""

                echo "Infrastructure Configuration:"
                # Check if required Azure infrastructure variables are set
                if [ -n "${AZURE_RESOURCE_GROUP:-}" ]; then
                  echo "  ✅ Azure Resource Group: ${AZURE_RESOURCE_GROUP}"
                else
                  echo "  ❌ AZURE_RESOURCE_GROUP not set in variable group"
                  exit 1
                fi

                # Check AKS configuration (can be computed from defaults)
                AKS_CLUSTER_NAME_COMPUTED="${AKS_CLUSTER_NAME:-aks-${AZURE_RESOURCE_GROUP}}"
                AKS_RESOURCE_GROUP_COMPUTED="${AKS_RESOURCE_GROUP:-${AZURE_RESOURCE_GROUP}}"

                if [ -n "${AKS_CLUSTER_NAME:-}" ]; then
                  echo "  ✅ AKS Cluster: ${AKS_CLUSTER_NAME} (explicit)"
                else
                  echo "  ℹ️  AKS Cluster: ${AKS_CLUSTER_NAME_COMPUTED} (computed default)"
                fi

                if [ -n "${AKS_RESOURCE_GROUP:-}" ]; then
                  echo "  ✅ AKS Resource Group: ${AKS_RESOURCE_GROUP} (explicit)"
                else
                  echo "  ℹ️  AKS Resource Group: ${AKS_RESOURCE_GROUP_COMPUTED} (computed default)"
                fi

                if [ -n "${AZURE_LOCATION:-}" ]; then
                  echo "  ✅ Azure Location: ${AZURE_LOCATION}"
                else
                  echo "  ❌ AZURE_LOCATION not set in variable group"
                  exit 1
                fi

                echo ""
                echo "Required Secrets Validation:"

                # Check mandatory secret: PVICO_ENTRA_CREDENTIALS
                if [ -z "${PVICO_ENTRA_CREDENTIALS:-}" ]; then
                  echo "  ❌ CRITICAL ERROR: PVICO_ENTRA_CREDENTIALS is not set!"
                  echo "     This secret is MANDATORY for Azure AD authentication."
                  echo "     Please configure it in the variable group: ${{ variables.computedVariableGroup }}"
                  echo ""
                  echo "     Expected format: JSON object with AzureAd configuration including:"
                  echo "     - TenantId, ClientId, ClientSecret, Instance, Domain, Scopes"
                  exit 1
                else
                  echo "  ✅ PVICO_ENTRA_CREDENTIALS is configured (mandatory)"
                  # Validate it's valid JSON
                  if ! echo "$PVICO_ENTRA_CREDENTIALS" | jq empty 2>/dev/null; then
                    echo "     ⚠️  Warning: PVICO_ENTRA_CREDENTIALS is not valid JSON"
                  fi
                fi

                echo ""
                echo "Optional Secrets:"

                # Check optional secrets
                if [ -n "${PVICO_OPENAI_CONNECTIONSTRING:-}" ]; then
                  echo "  ✅ PVICO_OPENAI_CONNECTIONSTRING is configured (optional)"
                else
                  echo "  ℹ️  PVICO_OPENAI_CONNECTIONSTRING is not set (optional - AI features will be unavailable)"
                fi

                if [ -n "${PVICO_AZUREMAPS_KEY:-}" ]; then
                  echo "  ✅ PVICO_AZUREMAPS_KEY is configured (optional)"
                else
                  echo "  ℹ️  PVICO_AZUREMAPS_KEY is not set (optional - Azure Maps features will be unavailable)"
                fi

                echo ""
                echo "Networking Mode Configuration:"
                DEPLOYMENT_MODEL="${DEPLOYMENT_MODEL:-public}"
                echo "  Deployment Model: $DEPLOYMENT_MODEL"

                # Check subnet configuration for private/hybrid modes (only when provisioning new cluster)
                if [[ "$DEPLOYMENT_MODEL" == "private" ]] || [[ "$DEPLOYMENT_MODEL" == "hybrid" ]]; then
                  echo ""
                  echo "Private/Hybrid Networking Requirements:"

                  # AKS subnet only required when DEPLOY_AKS=true
                  if [ "${DEPLOY_AKS:-false}" == "true" ]; then
                    if [ -n "${AKS_SUBNET:-}" ]; then
                      echo "  ✅ AKS_SUBNET is configured (cluster provisioning)"
                      echo "     ${AKS_SUBNET}"
                    else
                      echo "  ❌ AKS_SUBNET not set (REQUIRED when DEPLOY_AKS=true for $DEPLOYMENT_MODEL mode)"
                      echo "     Expected format: /subscriptions/{id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/snet-aks"
                      exit 1
                    fi
                  else
                    echo "  ℹ️  AKS_SUBNET not required (DEPLOY_AKS=false - using existing cluster)"
                  fi

                  if [ -n "${AZURE_SUBNET_PE:-}" ]; then
                    echo "  ✅ AZURE_SUBNET_PE is configured"
                    echo "     ${AZURE_SUBNET_PE}"
                  else
                    echo "  ⚠️  AZURE_SUBNET_PE not set (recommended for private endpoints)"
                    echo "     Expected format: /subscriptions/{id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/snet-pe"
                    echo "     Private endpoints will be skipped if not configured"
                  fi

                  # Check PostgreSQL subnet if using postgres backend
                  if [[ "${MEMORY_BACKEND:-aisearch}" == "postgres" ]]; then
                    if [ -n "${AZURE_SUBNET_POSTGRES:-}" ]; then
                      echo "  ✅ AZURE_SUBNET_POSTGRES is configured (postgres backend)"
                      echo "     ${AZURE_SUBNET_POSTGRES}"
                    else
                      echo "  ⚠️  AZURE_SUBNET_POSTGRES not set (required for postgres in $DEPLOYMENT_MODEL mode)"
                      echo "     Expected format: /subscriptions/{id}/resourceGroups/{rg}/providers/Microsoft.Network/virtualNetworks/{vnet}/subnets/snet-postgres"
                    fi
                  fi

                  echo ""
                  echo "  Mode Summary: $DEPLOYMENT_MODEL deployment will use:"
                  if [[ "$DEPLOYMENT_MODEL" == "hybrid" ]]; then
                    echo "    - Azure Front Door for public access"
                    echo "    - Internal load balancers in VNET"
                    echo "    - Private endpoints for Azure services"
                  else
                    echo "    - NO public endpoints (no Front Door)"
                    echo "    - Internal services only"
                    echo "    - Private endpoints for Azure services"
                  fi
                fi

                echo ""
                echo "Reminder: AKS cluster access validation will run after CLI tooling installs"
            displayName: Validate Variables and Pipeline Settings
            env:
              # Map variables from variable group for validation
              AZURE_RESOURCE_GROUP: $(AZURE_RESOURCE_GROUP)
              AZURE_LOCATION: $(AZURE_LOCATION)
              AKS_CLUSTER_NAME: $(AKS_CLUSTER_NAME)
              AKS_RESOURCE_GROUP: $(AKS_RESOURCE_GROUP)
              AKS_NAMESPACE: $(AKS_NAMESPACE)
              DEPLOY_AKS: $(DEPLOY_AKS)
              ENVIRONMENT_NAME: ${{ parameters.environment }}
              DEPLOYMENT_MODEL: $(DEPLOYMENT_MODEL)
              AKS_SUBNET: $(AKS_SUBNET)
              AZURE_SUBNET_PE: $(AZURE_SUBNET_PE)
              AZURE_SUBNET_POSTGRES: $(AZURE_SUBNET_POSTGRES)
              MEMORY_BACKEND: $(MEMORY_BACKEND)
              # Map secret variables from variable group for validation
              PVICO_ENTRA_CREDENTIALS: $(PVICO_ENTRA_CREDENTIALS)
              PVICO_OPENAI_CONNECTIONSTRING: $(PVICO_OPENAI_CONNECTIONSTRING)
              PVICO_AZUREMAPS_KEY: $(PVICO_AZUREMAPS_KEY)
          - script: |
              set -euo pipefail
              echo "[Init] Checking/installing required CLI tools (az, jq, kubectl, helm)"

              detect_pkg() {
                if command -v apt-get >/dev/null 2>&1; then echo apt; return; fi
                if command -v yum >/dev/null 2>&1; then echo yum; return; fi
                if command -v zypper >/dev/null 2>&1; then echo zypper; return; fi
                if command -v apk >/dev/null 2>&1; then echo apk; return; fi
                echo none
              }

              PKG=$(detect_pkg)
              echo "[Init] Package manager: $PKG"

              if ! command -v az >/dev/null 2>&1; then
                echo "[Init] Installing Azure CLI..."
                case "$PKG" in
                  apt)
                    curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash ;;
                  yum)
                    sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc || true
                    sudo sh -c 'echo -e "[azure-cli]\nname=Azure CLI\nbaseurl=https://packages.microsoft.com/yumrepos/azure-cli\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" > /etc/yum.repos.d/azure-cli.repo'
                    sudo yum install -y azure-cli ;;
                  zypper)
                    sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc || true
                    sudo zypper addrepo https://packages.microsoft.com/yumrepos/azure-cli azure-cli || true
                    sudo zypper refresh && sudo zypper install -y azure-cli ;;
                  apk)
                    echo "[Init] Alpine not supported by official installer; consider switching agent image" && exit 1 ;;
                  *)
                    echo "[Init] Unknown OS for Azure CLI install" && exit 1 ;;
                esac
              else
                echo "[Init] az already installed: $(az --version | head -n1)"
              fi

              if ! command -v jq >/dev/null 2>&1; then
                echo "[Init] Installing jq..."
                case "$PKG" in
                  apt) sudo apt-get update -y && sudo apt-get install -y jq ;;
                  yum) sudo yum install -y epel-release jq || sudo yum install -y jq ;;
                  zypper) sudo zypper install -y jq ;;
                  apk) sudo apk add --no-cache jq ;;
                esac
              else
                echo "[Init] jq already installed: $(jq --version)"
              fi

              if ! command -v kubectl >/dev/null 2>&1; then
                echo "[Init] Installing kubectl..."
                KVER=$(curl -Ls https://dl.k8s.io/release/stable.txt)
                curl -LO "https://dl.k8s.io/release/${KVER}/bin/linux/amd64/kubectl"
                sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
                rm -f kubectl
              else
                echo "[Init] kubectl already installed: $(kubectl version --client --short 2>/dev/null || echo present)"
              fi

              if ! command -v helm >/dev/null 2>&1; then
                echo "[Init] Installing Helm..."
                curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
              else
                echo "[Init] helm already installed: $(helm version --short)"
              fi

              if ! command -v docker >/dev/null 2>&1; then
                echo "[Init] Installing Docker..."
                curl -fsSL https://get.docker.com | sudo sh
                sudo systemctl start docker || true
                sudo usermod -aG docker $USER || true
                echo "[Init] Docker installed, permissions will be handled later in pipeline"
              else
                echo "[Init] docker already installed: $(docker --version 2>/dev/null || echo present)"
              fi

              echo "[Init] Adding azure-devops az extension..."
              az extension add -n azure-devops -y >/dev/null 2>&1 || true
            displayName: Install CLI dependencies (az, jq, kubectl, helm)

          - task: AzureCLI@2
            displayName: Validate AKS access (post-tooling)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                set -euo pipefail

                if [ "${DEPLOY_AKS:-false}" == "true" ]; then
                  echo "ℹ️  Skipping AKS validation - DEPLOY_AKS=true (cluster will be created/updated)"
                  exit 0
                fi

                echo "Validating Existing AKS Cluster Access (post-tooling):"
                echo "────────────────────────────────────────"

                AKS_RG="${AKS_RESOURCE_GROUP:-${AZURE_RESOURCE_GROUP}}"
                AKS_NAME="${AKS_CLUSTER_NAME:-aks-${AZURE_RESOURCE_GROUP}}"

                echo "  Cluster: $AKS_NAME"
                echo "  Resource Group: $AKS_RG"
                echo ""

                resolve_subscription() {
                  local value="$1"
                  if [[ -z "$value" ]]; then
                    echo ""
                    return
                  fi

                  # Ignore literal pipeline placeholders like $(AKS_SUBSCRIPTION_ID)
                  if [[ "$value" == *'$('* ]]; then
                    echo ""
                    return
                  fi

                  echo "$value" | tr -d '\r'
                }

                AKS_SUBSCRIPTION_OVERRIDE=$(resolve_subscription "${AKS_SUBSCRIPTION_ID:-}")
                AKS_SUBSCRIPTION_FALLBACK=$(resolve_subscription "${AZURE_SUBSCRIPTION_ID:-}")

                AKS_SUBSCRIPTION="${AKS_SUBSCRIPTION_OVERRIDE:-$AKS_SUBSCRIPTION_FALLBACK}"
                SUBSCRIPTION_ARG=""
                if [[ -n "$AKS_SUBSCRIPTION" ]]; then
                  SUBSCRIPTION_ARG="--subscription $AKS_SUBSCRIPTION"
                fi

                echo "  Checking cluster existence and permissions..."
                if [[ -n "$AKS_SUBSCRIPTION_OVERRIDE" ]]; then
                  echo "    Using subscription override: $AKS_SUBSCRIPTION"
                elif [[ -n "$AKS_SUBSCRIPTION_FALLBACK" ]]; then
                  echo "    No AKS-specific subscription provided; falling back to AZURE_SUBSCRIPTION_ID: $AKS_SUBSCRIPTION"
                else
                  echo "    Using default subscription context (no override provided)"
                fi

                set +e
                AKS_SHOW_OUTPUT=$(az aks show $SUBSCRIPTION_ARG --name "$AKS_NAME" --resource-group "$AKS_RG" --query "name" -o tsv 2>&1)
                AKS_SHOW_EXIT=$?
                set -e

                if [[ $AKS_SHOW_EXIT -eq 0 ]] && [[ -n "$AKS_SHOW_OUTPUT" ]]; then
                  echo "  ✅ Cluster exists and accessible via Azure API"
                  
                  CLUSTER_MODE=$(az aks show $SUBSCRIPTION_ARG --name "$AKS_NAME" --resource-group "$AKS_RG" --query "apiServerAccessProfile.enablePrivateCluster" -o tsv 2>/dev/null || echo "false")

                  if [[ "$CLUSTER_MODE" == "true" ]]; then
                    echo "  ⚠️  Private cluster detected - API server not publicly accessible"
                    echo "     Ensure pipeline agents can reach the cluster via VNET connectivity or private endpoints"
                  else
                    echo "  ✅ Public cluster - API server is accessible"
                  fi

                  echo ""
                  echo "  Testing credential retrieval..."
                  if az aks get-credentials $SUBSCRIPTION_ARG --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing >/dev/null 2>&1; then
                    echo "  ✅ Successfully retrieved cluster credentials"

                    echo ""
                    echo "  Testing kubectl connectivity..."
                    if timeout 10 kubectl cluster-info >/dev/null 2>&1; then
                      echo "  ✅ Successfully connected to cluster API server"

                      NAMESPACE="${AKS_NAMESPACE:-greenlight-${ENVIRONMENT_NAME:-dev}}"
                      if kubectl get namespace "$NAMESPACE" >/dev/null 2>&1; then
                        echo "  ✅ Namespace '$NAMESPACE' exists"
                      else
                        echo "  ℹ️  Namespace '$NAMESPACE' will be created during deployment"
                      fi
                    else
                      if [[ "$CLUSTER_MODE" == "true" ]]; then
                        echo "  ❌ Cannot connect to private cluster API server"
                        echo "     This is expected from public agents. Use a connected self-hosted agent or private endpoint."
                        exit 1
                      else
                        echo "  ❌ Cannot connect to cluster API server (timeout)"
                        echo "     Possible issues: network/firewall or API server availability"
                        exit 1
                      fi
                    fi
                  else
                    echo "  ❌ Failed to retrieve cluster credentials"
                    echo "     Ensure the service principal has one of these roles:"
                    echo "     - Azure Kubernetes Service Cluster User Role"
                    echo "     - Azure Kubernetes Service RBAC Cluster Admin"
                    exit 1
                  fi
                else
                  echo "  ❌ Cluster does not exist or no access permissions"
                  echo "     az aks show exit code: $AKS_SHOW_EXIT"
                  echo "     az aks show output:" 
                  echo "$AKS_SHOW_OUTPUT"
                  echo ""
                  echo "     Checked parameters:"
                  echo "       --name $AKS_NAME"
                  echo "       --resource-group $AKS_RG"
                  if [[ -n "$AKS_SUBSCRIPTION" ]]; then
                    echo "       --subscription $AKS_SUBSCRIPTION"
                  else
                    echo "       --subscription (default context)"
                  fi
                  echo ""
                  echo "     To create the cluster, set DEPLOY_AKS=true in your variable group"
                  exit 1
                fi

                echo ""
                echo "  AKS cluster validation completed"
                echo "  ────────────────────────────────────────"
            env:
              AZURE_RESOURCE_GROUP: $(AZURE_RESOURCE_GROUP)
              AKS_CLUSTER_NAME: $(AKS_CLUSTER_NAME)
              AKS_RESOURCE_GROUP: $(AKS_RESOURCE_GROUP)
              AKS_NAMESPACE: $(AKS_NAMESPACE)
              DEPLOY_AKS: $(DEPLOY_AKS)
              ENVIRONMENT_NAME: ${{ parameters.environment }}
              AKS_SUBSCRIPTION_ID: $(AKS_SUBSCRIPTION_ID)
              AZURE_SUBSCRIPTION_ID: $(AZURE_SUBSCRIPTION_ID)

          - task: UseDotNet@2
            inputs:
              packageType: "sdk"
              version: "9.0.x"

          - script: |
              dotnet --info
            displayName: Verify .NET SDK

          - script: |
              curl -sSL https://aspire.dev/install.sh | bash
              export PATH="$HOME/.aspire/bin:$PATH"
              aspire --version
            displayName: Install Aspire CLI


          - script: |
              set -e
              export PATH="$HOME/.aspire/bin:$PATH"
              chmod +x build/scripts/*.sh
              chmod +x build/scripts/pipeline-internal/*.sh

              # Set default KUBERNETES_RESOURCES_CONFIG if not provided or invalid
              if [ -z "${KUBERNETES_RESOURCES_CONFIG:-}" ] || ! echo "${KUBERNETES_RESOURCES_CONFIG}" | jq empty 2>/dev/null; then
                echo "[Pipeline] KUBERNETES_RESOURCES_CONFIG not set or invalid, using system defaults"
                export KUBERNETES_RESOURCES_CONFIG='[
                  {
                    "name": "silo",
                    "requests": { "cpu": "500m", "memory": "512Mi" },
                    "limits": { "cpu": "2000m", "memory": "2048Mi" },
                    "replicas": { "min": 2, "max": 10 }
                  },
                  {
                    "name": "api-main",
                    "requests": { "cpu": "250m", "memory": "256Mi" },
                    "limits": { "cpu": "1000m", "memory": "1024Mi" },
                    "replicas": { "min": 1, "max": 1 }
                  },
                  {
                    "name": "web-docgen",
                    "requests": { "cpu": "250m", "memory": "256Mi" },
                    "limits": { "cpu": "1000m", "memory": "1024Mi" },
                    "replicas": { "min": 2, "max": 10 }
                  },
                  {
                    "name": "mcpserver-core",
                    "requests": { "cpu": "100m", "memory": "128Mi" },
                    "limits": { "cpu": "500m", "memory": "512Mi" },
                    "replicas": { "min": 1, "max": 5 }
                  },
                  {
                    "name": "mcpserver-flow",
                    "requests": { "cpu": "250m", "memory": "256Mi" },
                    "limits": { "cpu": "500m", "memory": "512Mi" },
                    "replicas": { "min": 1, "max": 1 }
                  }
                ]'
              else
                echo "[Pipeline] Using KUBERNETES_RESOURCES_CONFIG from variable group"
                export KUBERNETES_RESOURCES_CONFIG="${KUBERNETES_RESOURCES_CONFIG}"
              fi

              echo "[Pipeline] Running aspire publish to $(Pipeline.Workspace)/publish"
              build/scripts/pipeline-internal/build-modern-aspire-publish.sh "$(Pipeline.Workspace)/publish"
              if [ ! -d "$(Pipeline.Workspace)/publish" ] || [ -z "$(ls -A $(Pipeline.Workspace)/publish 2>/dev/null)" ]; then
                echo "[Pipeline] ERROR: Aspire publish did not generate any output"
                exit 1
              fi
            displayName: Aspire publish
            env:
              KUBERNETES_RESOURCES_CONFIG: $(KUBERNETES_RESOURCES_CONFIG)

          - task: AzureCLI@2
            displayName: Deploy Azure Resources
            name: azureDeploy
            env:
              AZURE_RESOURCE_GROUP: $(AZURE_RESOURCE_GROUP)
              AZURE_LOCATION: $(AZURE_LOCATION)
              AKS_RESOURCE_GROUP: $(AKS_RESOURCE_GROUP)
              AKS_CLUSTER_NAME: $(AKS_CLUSTER_NAME)
              AKS_NAMESPACE: $(AKS_NAMESPACE)
              DEPLOY_AKS: $(DEPLOY_AKS)
              DEPLOYMENT_MODEL: $(DEPLOYMENT_MODEL)
              AKS_SUBNET: $(AKS_SUBNET)
              AZURE_SUBNET_PE: $(AZURE_SUBNET_PE)
              WORKLOAD_IDENTITY_PRINCIPAL_ID: $(WORKLOAD_IDENTITY_PRINCIPAL_ID)
              WORKLOAD_IDENTITY_CLIENT_ID: $(WORKLOAD_IDENTITY_CLIENT_ID)
              WORKLOAD_IDENTITY_NAME: $(WORKLOAD_IDENTITY_NAME)
              WORKLOAD_IDENTITY_SERVICE_ACCOUNT: $(WORKLOAD_IDENTITY_SERVICE_ACCOUNT)
              ENVIRONMENT_NAME: ${{ parameters.environment }}
              GREENLIGHT_NAMESPACE: $(GREENLIGHT_NAMESPACE)
              VARIABLE_GROUP_NAME: $(VARIABLE_GROUP_NAME)
              ADO_ORG_URL: $(System.CollectionUri)
              ADO_PROJECT: $(System.TeamProject)
              AKS_DIAGNOSTICLOGS: $(AKS_DIAGNOSTICLOGS)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                      set -euo pipefail

                      # Clean up any existing azure-outputs.env file from previous runs
                      if [ -f "$(Pipeline.Workspace)/azure-outputs.env" ]; then
                        echo "[ADO] Removing existing azure-outputs.env from previous run"
                        rm -f "$(Pipeline.Workspace)/azure-outputs.env"
                      fi

                      # Validate AKS cluster networking mode compatibility
                      AKS_RG="${AKS_RESOURCE_GROUP:-$(AZURE_RESOURCE_GROUP)}"
                      AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                      DEPLOYMENT_MODEL="${DEPLOYMENT_MODEL:-public}"

                      # Check existing cluster compatibility (only if not provisioning new)
                      if [ "${DEPLOY_AKS:-false}" != "true" ]; then
                        echo "[ADO] Validating existing AKS cluster networking compatibility..."
                        chmod +x $(Build.SourcesDirectory)/build/scripts/pipeline-internal/validate-aks-networking.sh
                        if ! $(Build.SourcesDirectory)/build/scripts/pipeline-internal/validate-aks-networking.sh \
                          "$AKS_RG" "$AKS_NAME" "$DEPLOYMENT_MODEL"; then
                          echo "[ADO] ❌ AKS cluster networking mode is incompatible with DEPLOYMENT_MODEL=$DEPLOYMENT_MODEL"
                          exit 1
                        fi
                      fi

                      # Optional AKS provisioning (idempotent) when DEPLOY_AKS=true
                      if [ "${DEPLOY_AKS:-false}" = "true" ]; then
                        echo "[ADO] DEPLOY_AKS=true - ensuring AKS cluster exists before infra deployment"
                        chmod +x $(Build.SourcesDirectory)/build/scripts/provision-aks-cluster.sh
                        chmod +x $(Build.SourcesDirectory)/build/scripts/pipeline-internal/build-modern-update-wi-variable-group.sh
                        # Provision cluster non-interactively (will no-op if exists)
                        # Pass AKS_DIAGNOSTICLOGS if configured in variable group
                        PROVISION_ARGS=()
                        PROVISION_ARGS+=("$AKS_RG")
                        PROVISION_ARGS+=("$(AZURE_LOCATION)")
                        PROVISION_ARGS+=("$AKS_NAME")
                        PROVISION_ARGS+=("--deployment-model" "${DEPLOYMENT_MODEL:-public}")

                        # Add subnet parameters for private/hybrid modes
                        if [[ "$DEPLOYMENT_MODEL" == "private" ]] || [[ "$DEPLOYMENT_MODEL" == "hybrid" ]]; then
                          if [ -n "${AKS_SUBNET:-}" ]; then
                            PROVISION_ARGS+=("--subnet-id" "$AKS_SUBNET")
                          fi
                        fi

                        ACCEPT_DEFAULTS=true \
                        AKS_DIAGNOSTICLOGS="${AKS_DIAGNOSTICLOGS:-false}" \
                        $(Build.SourcesDirectory)/build/scripts/provision-aks-cluster.sh "${PROVISION_ARGS[@]}" || echo "[ADO] AKS provisioning step completed (or skipped)"
                        # Capture workload identity variables if summary exists
                        if [ -f "aks-provision-summary.json" ]; then
                          echo "[ADO] Capturing workload identity values from provisioning summary"
                          WI_CLIENT_ID=$(jq -r '.workloadIdentity.clientId // empty' aks-provision-summary.json || true)
                          WI_PRINCIPAL_ID=$(jq -r '.workloadIdentity.principalId // empty' aks-provision-summary.json || true)
                          WI_RESOURCE_ID=$(jq -r '.workloadIdentity.resourceId // empty' aks-provision-summary.json || true)
                          WI_OIDC_ISSUER=$(jq -r '.workloadIdentity.oidcIssuer // empty' aks-provision-summary.json || true)
                          WI_FED_SUBJECT=$(jq -r '.workloadIdentity.federatedSubject // empty' aks-provision-summary.json || true)
                          # Extract identity name from resource ID (last segment)
                          WI_NAME=$(echo "$WI_RESOURCE_ID" | sed 's|.*/||' || true)
                          if [ -n "$WI_CLIENT_ID" ]; then
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_CLIENT_ID]$WI_CLIENT_ID"
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_PRINCIPAL_ID]$WI_PRINCIPAL_ID"
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_RESOURCE_ID]$WI_RESOURCE_ID"
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_NAME]$WI_NAME"
                            echo "##vso[task.setvariable variable=AKS_OIDC_ISSUER]$WI_OIDC_ISSUER"
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_FEDERATED_SUBJECT]$WI_FED_SUBJECT"
                            echo "[ADO] Updated pipeline variables with workload identity values"
                            # Persist back to variable group for future runs
                            if [ -n "${VARIABLE_GROUP_NAME:-}" ] && [ -n "${ADO_ORG_URL:-}" ] && [ -n "${ADO_PROJECT:-}" ]; then
                              $(Build.SourcesDirectory)/build/scripts/pipeline-internal/build-modern-update-wi-variable-group.sh "${VARIABLE_GROUP_NAME:-$(GREENLIGHT_VARIABLE_GROUP)}" "${ADO_ORG_URL}" "${ADO_PROJECT}" || echo "[ADO] Variable group sync failed (non-fatal)"
                            fi
                          fi
                        fi
                      else
                        echo "[ADO] DEPLOY_AKS not enabled (DEPLOY_AKS=$DEPLOY_AKS) - expecting cluster to pre-exist"
                      fi

                      # Set up paths
                      SCRIPTS_DIR="$(Build.SourcesDirectory)/build/scripts/pipeline-internal"
                      PUB_DIR="$(Pipeline.Workspace)/publish"
                      echo "[ADO] Using scripts from: $SCRIPTS_DIR"
                      echo "[ADO] Using publish output from: $PUB_DIR"

                      # Make scripts executable
                      chmod +x "$SCRIPTS_DIR"/*.sh

                      # Ensure a deterministic workload identity exists before we rewrite Bicep templates
                      # Check if variable is empty or contains unexpanded ADO syntax
                      if [ -z "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" ] || [[ "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" == "\$(WORKLOAD_IDENTITY_PRINCIPAL_ID)" ]]; then
                        echo "[ADO] Workload identity values not present - creating deterministic identity for this environment"
                        ENV_RG="$(AZURE_RESOURCE_GROUP)"
                        AKS_RG="${AKS_RESOURCE_GROUP:-$ENV_RG}"
                        AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                        NAMESPACE="${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}"
                        # Check if SERVICE_ACCOUNT contains unexpanded ADO syntax
                        if [[ "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" == "\$(WORKLOAD_IDENTITY_SERVICE_ACCOUNT)" ]] || [ -z "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" ]; then
                          SERVICE_ACCOUNT="greenlight-app"
                        else
                          SERVICE_ACCOUNT="$WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
                        fi
                        WI_BASE_NAME="${ENV_RG:-${ENVIRONMENT_NAME:-$NAMESPACE}}"
                        WI_NAME=$(echo "uami-${WI_BASE_NAME}" | tr '[:upper:]' '[:lower:]')
                        WI_NAME=$(echo "$WI_NAME" | tr -c 'a-z0-9-' '-' | sed 's/-\{2,\}/-/g; s/^-//; s/-$//' | cut -c1-120)
                        WI_OUTPUT_FILE="$(Pipeline.Workspace)/workload-identity-bootstrap.env"
                        AZURE_LOCATION="$(AZURE_LOCATION)" \
                        WORKLOAD_IDENTITY_NAME="$WI_NAME" \
                        OUTPUT_FILE="$WI_OUTPUT_FILE" \
                          "$SCRIPTS_DIR/build-modern-setup-workload-identity.sh" "$ENV_RG" "$AKS_RG" "$AKS_NAME" "$NAMESPACE" "$SERVICE_ACCOUNT" || {
                            echo "[ADO] WARNING: Workload identity setup during bootstrap returned non-zero (continuing)"
                          }
                        if [ -f "$WI_OUTPUT_FILE" ]; then
                          # Load results and promote to pipeline variables for downstream scripts
                          # First unset any literal ADO syntax that came from env section
                          unset WORKLOAD_IDENTITY_PRINCIPAL_ID WORKLOAD_IDENTITY_CLIENT_ID WORKLOAD_IDENTITY_NAME WORKLOAD_IDENTITY_SERVICE_ACCOUNT
                          # Now source the file with real values
                          source "$WI_OUTPUT_FILE" || true
                          if [ -n "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" ]; then
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_PRINCIPAL_ID]$WORKLOAD_IDENTITY_PRINCIPAL_ID"
                            export WORKLOAD_IDENTITY_PRINCIPAL_ID="$WORKLOAD_IDENTITY_PRINCIPAL_ID"
                          fi
                          if [ -n "${WORKLOAD_IDENTITY_CLIENT_ID:-}" ]; then
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_CLIENT_ID]$WORKLOAD_IDENTITY_CLIENT_ID"
                            export WORKLOAD_IDENTITY_CLIENT_ID="$WORKLOAD_IDENTITY_CLIENT_ID"
                          fi
                          if [ -n "${WORKLOAD_IDENTITY_NAME:-}" ]; then
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_NAME]$WORKLOAD_IDENTITY_NAME"
                            export WORKLOAD_IDENTITY_NAME="$WORKLOAD_IDENTITY_NAME"
                          fi
                          if [ -n "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" ]; then
                            echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_SERVICE_ACCOUNT]$WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
                            export WORKLOAD_IDENTITY_SERVICE_ACCOUNT="$WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
                          fi
                        else
                          echo "[ADO] WARNING: workload identity bootstrap file not generated"
                        fi
                      fi

                      # Run deploy-stage fixes (principal type, subscription scope, role alignment)
                      echo "[ADO] Applying deploy-stage fixes (principals, scopes, roles)..."
                      WORKLOAD_IDENTITY_PRINCIPAL_ID="${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" \
                      WORKLOAD_IDENTITY_NAME="${WORKLOAD_IDENTITY_NAME:-}" \
                        "$SCRIPTS_DIR/build-modern-post-publish-fixes.sh" "$PUB_DIR" deploy

                      # Export principal ID and name - with addSpnToEnvironment, it's in servicePrincipalId variable
                      # Check if variable is set and not an unexpanded ADO syntax
                      if [ -n "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" ] && [[ "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" != "\$(WORKLOAD_IDENTITY_PRINCIPAL_ID)" ]]; then
                        export AZURE_PRINCIPAL_ID="$WORKLOAD_IDENTITY_PRINCIPAL_ID"
                        export AZURE_PRINCIPAL_NAME="${WORKLOAD_IDENTITY_NAME:-}"
                        echo "[ADO] Using workload identity principal for role assignments: $AZURE_PRINCIPAL_ID"
                        if [ -n "${WORKLOAD_IDENTITY_NAME:-}" ]; then
                          echo "[ADO] Workload identity name: $WORKLOAD_IDENTITY_NAME"
                        else
                          echo "[ADO] WARNING: WORKLOAD_IDENTITY_NAME not set - SQL role assignments may fail"
                        fi
                      elif [ -n "${servicePrincipalId:-}" ]; then
                        export AZURE_PRINCIPAL_ID="$servicePrincipalId"
                        echo "[ADO] Using service principal for role assignments: $servicePrincipalId"
                      else
                        echo "[ADO] ERROR: No principal ID available (service principal or workload identity)"
                        exit 1
                      fi

                      # Deploy Azure resources (script will write outputs to file)
                      export AZURE_OUTPUT_FILE="$(Pipeline.Workspace)/azure-outputs.env"
                      "$SCRIPTS_DIR/build-modern-deploy-azure.sh" "$PUB_DIR" "$(AZURE_RESOURCE_GROUP)" "$(AZURE_LOCATION)"

                      # Workload identity setup handled below in a dedicated section (single source of truth)

                      # Capture outputs and save them for next task
                        echo "[ADO] Capturing Azure deployment outputs for Helm..."

                      # Check if the deployment script already created the output file
                      if [ -f "$(Pipeline.Workspace)/azure-outputs.env" ]; then
                        echo "[ADO] Found azure-outputs.env file from deployment script"

                        # Source the file to load variables into environment and export them for subprocesses
                        set -a  # automatically export all variables
                        source "$(Pipeline.Workspace)/azure-outputs.env"
                        set +a  # disable automatic export

                        # Count the outputs
                        OUTPUT_COUNT=$(grep -c "^AZURE_OUTPUT_" "$(Pipeline.Workspace)/azure-outputs.env" || echo 0)
                        echo "[ADO] Loaded $OUTPUT_COUNT Azure outputs from file (sensitive values not printed)"

                        # Also set them as pipeline variables for downstream tasks (without isOutput=true so they're available in same job)
                        while IFS= read -r line; do
                          if [[ "$line" =~ ^AZURE_OUTPUT_([^=]+)=(.*)$ ]]; then
                            var_name="AZURE_OUTPUT_${BASH_REMATCH[1]}"
                            var_value="${BASH_REMATCH[2]}"
                            echo "##vso[task.setvariable variable=$var_name]$var_value"
                            # Don't echo sensitive values
                            if [[ "$var_name" == *"Connection"* ]] || [[ "$var_name" == *"Password"* ]] || [[ "$var_name" == *"Key"* ]] || [[ "$var_name" == *"Endpoint"* ]]; then
                              echo "[ADO] Set pipeline variable: $var_name (sensitive - redacted)"
                            else
                              echo "[ADO] Set pipeline variable: $var_name"
                            fi
                          fi
                        done < "$(Pipeline.Workspace)/azure-outputs.env"
                      else
                        echo "[ADO] ERROR: No azure-outputs.env file found after deployment!"
                        echo "[ADO] The deployment script should have created this file with Azure outputs"
                        # Create empty file to avoid downstream errors
                        touch "$(Pipeline.Workspace)/azure-outputs.env"
                      fi

                      # ------------------------------------------------------------------
                      # Workload Identity setup (configure SA + federated credential + roles)
                      # ------------------------------------------------------------------
                      echo "[ADO] Setting up Workload Identity for AKS access to Azure..."
                      chmod +x $(Build.SourcesDirectory)/build/scripts/pipeline-internal/build-modern-setup-workload-identity.sh
                      ENV_RG="$(AZURE_RESOURCE_GROUP)"
                      AKS_RG="${AKS_RESOURCE_GROUP:-$ENV_RG}"
                      AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                      NAMESPACE="${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}"
                      # Check if SERVICE_ACCOUNT contains unexpanded ADO syntax
                      if [[ "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" == "\$(WORKLOAD_IDENTITY_SERVICE_ACCOUNT)" ]] || [ -z "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" ]; then
                        SERVICE_ACCOUNT="greenlight-app"
                      else
                        SERVICE_ACCOUNT="$WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
                      fi
                      WI_BASE_NAME="${ENV_RG:-${ENVIRONMENT_NAME:-$NAMESPACE}}"
                      WI_NAME=$(echo "uami-${WI_BASE_NAME}" | tr '[:upper:]' '[:lower:]')
                      WI_NAME=$(echo "$WI_NAME" | tr -c 'a-z0-9-' '-' | sed 's/-\{2,\}/-/g; s/^-//; s/-$//' | cut -c1-120)
                      AZURE_LOCATION="$(AZURE_LOCATION)" \
                      WORKLOAD_IDENTITY_NAME="$WI_NAME" \
                      $(Build.SourcesDirectory)/build/scripts/pipeline-internal/build-modern-setup-workload-identity.sh "$ENV_RG" "$AKS_RG" "$AKS_NAME" "$NAMESPACE" "$SERVICE_ACCOUNT" || {
                        echo "[ADO] WARNING: Workload Identity setup script returned non-zero (continuing)"
                      }
                      # Export workload identity variables for downstream tasks and sync to variable group
                      if [ -f "workload-identity-config.env" ]; then
                        source workload-identity-config.env || true
                        # Set as pipeline variables for other tasks to use
                        if [ -n "${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}" ]; then
                          echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_PRINCIPAL_ID]$WORKLOAD_IDENTITY_PRINCIPAL_ID"
                        fi
                        if [ -n "${WORKLOAD_IDENTITY_CLIENT_ID:-}" ]; then
                          echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_CLIENT_ID]$WORKLOAD_IDENTITY_CLIENT_ID"
                        fi
                        if [ -n "${WORKLOAD_IDENTITY_NAME:-}" ]; then
                          echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_NAME]$WORKLOAD_IDENTITY_NAME"
                        fi
                        if [ -n "${WORKLOAD_IDENTITY_SERVICE_ACCOUNT:-}" ]; then
                          echo "##vso[task.setvariable variable=WORKLOAD_IDENTITY_SERVICE_ACCOUNT]$WORKLOAD_IDENTITY_SERVICE_ACCOUNT"
                        fi
                        # If a variable group is configured, sync WI values back for future runs
                        if [ -n "${VARIABLE_GROUP_NAME:-}" ] && [ -n "${ADO_ORG_URL:-}" ] && [ -n "${ADO_PROJECT:-}" ]; then
                          chmod +x $(Build.SourcesDirectory)/build/scripts/pipeline-internal/build-modern-update-wi-variable-group.sh
                          $(Build.SourcesDirectory)/build/scripts/pipeline-internal/build-modern-update-wi-variable-group.sh "${VARIABLE_GROUP_NAME:-$(GREENLIGHT_VARIABLE_GROUP)}" "${ADO_ORG_URL}" "${ADO_PROJECT}" || echo "[ADO] Variable group WI sync failed (non-fatal)"
                        fi
                      fi

          - task: AzureCLI@2
            displayName: Build and Push Docker Images to ACR
            env:
              # Pass System.AccessToken for Azure Artifacts authentication (internal builds only)
              # The build script checks INTERNAL_MICROSOFT and only uses this when set to 'true'
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                      set -euo pipefail

                      echo "[ADO] .NET SDK version:"
                      dotnet --version

                      SCRIPTS_DIR="$(Build.SourcesDirectory)/build/scripts/pipeline-internal"
                      chmod +x "$SCRIPTS_DIR"/*.sh

                      # Determine ACR login server/name (favor explicit endpoint)
                      if [ -n "${AZURE_CONTAINER_REGISTRY_ENDPOINT:-}" ]; then
                        ACR_LOGIN_SERVER="$AZURE_CONTAINER_REGISTRY_ENDPOINT"
                        ACR_NAME="${AZURE_CONTAINER_REGISTRY_ENDPOINT%%.azurecr.io}"
                        ACR_NAME="${ACR_NAME##https://}"
                      else
                        ACR_NAME="${AZURE_CONTAINER_REGISTRY_NAME:-${ACR_NAME:-acr$(echo $(AZURE_RESOURCE_GROUP) | tr -d '-')}}"
                        ACR_LOGIN_SERVER="${ACR_NAME}.azurecr.io"
                      fi

                      echo "[ADO] Building and pushing images to ACR: $ACR_NAME ($ACR_LOGIN_SERVER)"

                      # Export variables for helper script
                      export AZURE_RESOURCE_GROUP="$(AZURE_RESOURCE_GROUP)"
                      export AKS_RESOURCE_GROUP="${AKS_RESOURCE_GROUP:-$(AZURE_RESOURCE_GROUP)}"
                      export AKS_CLUSTER_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                      export WORKLOAD_IDENTITY_PRINCIPAL_ID="${WORKLOAD_IDENTITY_PRINCIPAL_ID:-}"
                      export BUILD_BUILDNUMBER="$(Build.BuildNumber)"
                      # Pass INTERNAL_MICROSOFT flag (must be explicitly set to 'true' in variable group for internal builds)
                      export INTERNAL_MICROSOFT="${INTERNAL_MICROSOFT:-}"

                      # Run parallel container build/push using Docker with per-project Dockerfiles
                      "$SCRIPTS_DIR/build-modern-build-push-images-parallel.sh" "$ACR_NAME" "$(Build.SourcesDirectory)"

                      # Export endpoint for downstream tasks
                      echo "##vso[task.setvariable variable=AZURE_CONTAINER_REGISTRY_ENDPOINT]${ACR_LOGIN_SERVER}"
                      echo "[ADO] Exported ACR endpoint: ${ACR_LOGIN_SERVER}"

          - task: AzureCLI@2
            displayName: Deploy to AKS with Helm
            env:
              # Surface the ACR endpoint discovered during the build step to this task's environment
              AZURE_CONTAINER_REGISTRY_ENDPOINT: $(AZURE_CONTAINER_REGISTRY_ENDPOINT)
              # Map secret variables from variable group for deployment script access
              PVICO_ENTRA_CREDENTIALS: $(PVICO_ENTRA_CREDENTIALS)
              PVICO_OPENAI_CONNECTIONSTRING: $(PVICO_OPENAI_CONNECTIONSTRING)
              PVICO_AZUREMAPS_KEY: $(PVICO_AZUREMAPS_KEY)
              # Azure resource outputs loaded from azure-outputs.env file (auto-generated by deployment step)
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                      set -euo pipefail

                      # Set up paths
                      SCRIPTS_DIR="$(Build.SourcesDirectory)/build/scripts/pipeline-internal"
                      PUB_DIR="$(Pipeline.Workspace)/publish"

                      # Get AKS cluster details
                      AKS_RG="${AKS_RESOURCE_GROUP:-$(AZURE_RESOURCE_GROUP)}"
                      AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"

                      echo "[ADO] Retrieving credentials for AKS: $AKS_NAME in RG: $AKS_RG"
                      az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing
                      kubectl cluster-info

                      # Load Azure deployment outputs from previous task
                      echo "[ADO] Loading Azure deployment outputs (without printing values)..."

                      # First try to load from file (primary method)
                      OUTPUTS_LOADED=0
                      if [ -f "$(Pipeline.Workspace)/azure-outputs.env" ]; then
                        echo "[ADO] Found azure-outputs.env file"
                        # Export each variable so child scripts can access them
                        while IFS='=' read -r key value; do
                          if [[ "$key" == AZURE_OUTPUT_* ]]; then
                            export "$key=$value"
                            echo "[ADO] Exported from file: $key"
                            OUTPUTS_LOADED=$((OUTPUTS_LOADED + 1))
                          fi
                        done < "$(Pipeline.Workspace)/azure-outputs.env"
                        echo "[ADO] Loaded $OUTPUTS_LOADED Azure outputs from file"
                      else
                        echo "[ADO] WARNING: No Azure outputs file found at $(Pipeline.Workspace)/azure-outputs.env"
                      fi

                      # File loading is now the primary and only method (normalized keys)

                      # Validate that critical Azure outputs are available - fail fast if not
                      echo "[ADO] Validating required Azure outputs..."
                      MISSING_OUTPUTS=()

                      # Check critical outputs that are required for deployment
                      if [ -z "${AZURE_OUTPUT_DOCING_BLOBENDPOINT:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_DOCING_BLOBENDPOINT")
                      fi
                      if [ -z "${AZURE_OUTPUT_SQLDOCGEN_SQLSERVERFQDN:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_SQLDOCGEN_SQLSERVERFQDN")
                      fi
                      if [ -z "${AZURE_OUTPUT_ORLEANS_STORAGE_BLOBENDPOINT:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_ORLEANS_STORAGE_BLOBENDPOINT")
                      fi
                      if [ -z "${AZURE_OUTPUT_ORLEANS_STORAGE_TABLEENDPOINT:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_ORLEANS_STORAGE_TABLEENDPOINT")
                      fi
                      if [ -z "${AZURE_OUTPUT_AISEARCH_CONNECTIONSTRING:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_AISEARCH_CONNECTIONSTRING")
                      fi
                      if [ -z "${AZURE_OUTPUT_INSIGHTS_APPINSIGHTSCONNECTIONSTRING:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_INSIGHTS_APPINSIGHTSCONNECTIONSTRING")
                      fi
                      if [ -z "${AZURE_OUTPUT_EVENTHUB_EVENTHUBSENDPOINT:-}" ]; then
                        MISSING_OUTPUTS+=("AZURE_OUTPUT_EVENTHUB_EVENTHUBSENDPOINT")
                      fi

                      # Only counting file outputs now
                      if [ ${#MISSING_OUTPUTS[@]} -gt 0 ]; then
                        echo "[ADO] ❌ CRITICAL ERROR: Required Azure outputs are missing!"
                        echo "[ADO] Missing outputs:"
                        for output in "${MISSING_OUTPUTS[@]}"; do
                          echo "[ADO]   - $output"
                        done
                        echo ""
                        echo "[ADO] This indicates the Azure deployment step failed to export resource outputs."
                        echo "[ADO] Deploying with placeholder values would result in broken applications."
                        echo "[ADO] Please check:"
                        echo "[ADO]   1. Azure resource deployment succeeded"
                        echo "[ADO]   2. Bicep templates have correct output declarations"
                        echo "[ADO]   3. build-modern-fix-aspire-outputs.sh ran successfully"
                        echo "[ADO]   4. build-modern-deploy-azure.sh exported outputs correctly"
                        exit 1
                      else
                        echo "[ADO] ✅ All required Azure outputs are available"
                        echo "[ADO] Total Azure outputs loaded from file: $OUTPUTS_LOADED"
                      fi

                      # Prefer the pipeline-provided ACR endpoint; if missing, derive and sanitize from resource group
                      if [ -n "${AZURE_CONTAINER_REGISTRY_ENDPOINT:-}" ]; then
                        echo "[ADO] Using ACR from pipeline var: ${AZURE_CONTAINER_REGISTRY_ENDPOINT}"
                      else
                        # Derive ACR name consistently with the build step (remove hyphens, force lowercase)
                        RG_SANITIZED="$(echo "$(AZURE_RESOURCE_GROUP)" | tr -d '-' | tr '[:upper:]' '[:lower:]')"
                        ACR_NAME="${AZURE_CONTAINER_REGISTRY_NAME:-${ACR_NAME:-acr${RG_SANITIZED}}}"
                        ACR_LOGIN_SERVER=$(az acr show --name "$ACR_NAME" --resource-group "$(AZURE_RESOURCE_GROUP)" --query loginServer -o tsv 2>/dev/null || echo "")
                        if [ -n "$ACR_LOGIN_SERVER" ]; then
                          export AZURE_CONTAINER_REGISTRY_ENDPOINT="$ACR_LOGIN_SERVER"
                          echo "[ADO] Using ACR discovered via az: $ACR_LOGIN_SERVER"
                          # Log into ACR for image pulls (best-effort in case pulls need it)
                          az acr login --name "$ACR_NAME" 2>/dev/null || true
                        else
                          echo "[ADO] WARNING: Could not resolve ACR login server; Helm will fall back to image names without registry"
                        fi
                      fi

                      # Pass configuration as environment variables to Helm
                      export PVICO_OPENAI_CONNECTIONSTRING="${PVICO_OPENAI_CONNECTIONSTRING:-}"
                      export PVICO_ENTRA_CREDENTIALS="${PVICO_ENTRA_CREDENTIALS:-}"
                      export HOSTNAME_OVERRIDE="${HOSTNAME_OVERRIDE:-}"
                      export PVICO_AZUREMAPS_KEY="${PVICO_AZUREMAPS_KEY:-}"
                      export KUBERNETES_RESOURCES_CONFIG="${KUBERNETES_RESOURCES_CONFIG:-}"

                      # Export BUILD_BUILDNUMBER for image tagging (sanitize dots to dashes to match container tags)
                      export BUILD_BUILDNUMBER="$(echo "$(Build.BuildNumber)" | tr '.' '-')"

                      # Azure AD configuration for authentication
                      export AZURE_AD_TENANT_ID="${AZURE_AD_TENANT_ID:-$(az account show --query tenantId -o tsv)}"
                      export AZURE_AD_CLIENT_ID="${AZURE_AD_CLIENT_ID:-}"
                      export AZURE_AD_INSTANCE="${AZURE_AD_INSTANCE:-https://login.microsoftonline.com/}"
                      export AZURE_AD_SCOPES="${AZURE_AD_SCOPES:-api://greenlight/.default}"

                      # Make scripts executable
                      chmod +x "$SCRIPTS_DIR"/*.sh
                      chmod +x "$(Build.SourcesDirectory)/build/scripts"/*.sh

                      # Deploy with Helm (script will use AZURE_OUTPUT_* and other env vars)
                      echo "[ADO] Starting Helm deployment..."
                      # Use clean Helm deployment approach (no template modifications)
                      echo "[ADO] Using clean Helm deployment - eliminates template corruption"
                      # Defer DB SetupManager job to end of pipeline for stability
                      export DB_SETUP_JOB_MODE=postpone
                      "$(Build.SourcesDirectory)/build/scripts/build-modern-helm-deploy-clean.sh" "$PUB_DIR" "${HELM_RELEASE:-$(GREENLIGHT_HELM_RELEASE)}" "${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}"
                      echo "[ADO] Clean deployment completed - workload identity handled via Helm values"

          - task: AzureCLI@2
            displayName: Apply Kubernetes resource configuration
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |-
                      set -euo pipefail
                      SCRIPTS_DIR="$(Build.SourcesDirectory)/build/scripts/pipeline-internal"
                      chmod +x "$SCRIPTS_DIR"/*.sh
                      # Ensure we have cluster context
                      AKS_RG="${AKS_RESOURCE_GROUP:-$(AZURE_RESOURCE_GROUP)}"
                      AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                      az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing

                      # Apply resource configuration if provided
                      if [[ -n "${KUBERNETES_RESOURCES_CONFIG:-}" ]]; then
                        echo "[ADO] Applying KUBERNETES_RESOURCES_CONFIG via kubectl patch"
                        "$SCRIPTS_DIR/build-modern-apply-k8s-resources.sh" "${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}" || {
                          echo "[ADO] WARNING: Failed to apply some resource configurations (non-fatal)"
                        }
                      else
                        echo "[ADO] No KUBERNETES_RESOURCES_CONFIG provided, using Aspire defaults"
                      fi
            env:
              KUBERNETES_RESOURCES_CONFIG: $(KUBERNETES_RESOURCES_CONFIG)
              ENABLE_SPOTNODES: $(ENABLE_SPOTNODES)
              AZURE_RESOURCE_GROUP: $(AZURE_RESOURCE_GROUP)
              AKS_RESOURCE_GROUP: $(AKS_RESOURCE_GROUP)
              AKS_CLUSTER_NAME: $(AKS_CLUSTER_NAME)
              AKS_NAMESPACE: $(AKS_NAMESPACE)
              ENVIRONMENT_NAME: ${{ parameters.environment }}
              GREENLIGHT_NAMESPACE: $(GREENLIGHT_NAMESPACE)

          - task: AzureCLI@2
            displayName: Expose endpoints (AKS LB) and setup Front Door (public)
            condition: and(succeeded(), ne(variables.DISABLE_EXPOSEDENDPOINTS, 'true'))
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                      set -euo pipefail
                      echo "[ADO] DISABLE_EXPOSEDENDPOINTS=${DISABLE_EXPOSEDENDPOINTS:-}"
                      SCRIPTS_DIR="$(Build.SourcesDirectory)/build/scripts/pipeline-internal"
                      chmod +x "$SCRIPTS_DIR"/*.sh
                      # Ensure we have cluster context
                      AKS_RG="${AKS_RESOURCE_GROUP:-$(AZURE_RESOURCE_GROUP)}"
                      AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                      az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing

                      # Expose services based on deployment model
                      DEPLOYMENT_MODEL="${DEPLOYMENT_MODEL:-public}"
                      echo "[ADO] Configuring service endpoints for $DEPLOYMENT_MODEL deployment..."

                      DISABLE_EXPOSEDENDPOINTS="${DISABLE_EXPOSEDENDPOINTS:-false}" \
                        "$SCRIPTS_DIR/build-modern-expose-endpoints.sh" "${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}" "$DEPLOYMENT_MODEL"

                      # Setup Azure Front Door only for public and hybrid modes
                      if [[ "$DEPLOYMENT_MODEL" == "public" ]] || [[ "$DEPLOYMENT_MODEL" == "hybrid" ]]; then
                        echo "[ADO] Creating Azure Front Door for $DEPLOYMENT_MODEL deployment..."
                        DISABLE_EXPOSEDENDPOINTS="${DISABLE_EXPOSEDENDPOINTS:-false}" \
                          "$SCRIPTS_DIR/build-modern-afd-setup.sh" "$(AZURE_RESOURCE_GROUP)" "$(AZURE_LOCATION)" "$(GREENLIGHT_RESOURCE_PREFIX)" "${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}"
                      else
                        echo "[ADO] Skipping Azure Front Door setup for private deployment"
                        echo "[ADO] Private deployments do not create public endpoints"
                      fi

          - task: AzureCLI@2
            displayName: Run DB SetupManager job (post-deploy)
            timeoutInMinutes: 15
            inputs:
              azureSubscription: $(AZURE_SERVICE_CONNECTION)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              inlineScript: |
                      set -euo pipefail
                      SCRIPTS_DIR="$(Build.SourcesDirectory)/build/scripts/pipeline-internal"
                      chmod +x "$SCRIPTS_DIR"/*.sh
                      # Ensure we have cluster context
                      AKS_RG="${AKS_RESOURCE_GROUP:-$(AZURE_RESOURCE_GROUP)}"
                      AKS_NAME="${AKS_CLUSTER_NAME:-aks-$(AZURE_RESOURCE_GROUP)}"
                      az aks get-credentials --resource-group "$AKS_RG" --name "$AKS_NAME" --overwrite-existing
                      # Run job from inside cluster context with longer backoff for workload identity token propagation
                      "$SCRIPTS_DIR/build-modern-run-db-setup-job.sh" "${AKS_NAMESPACE:-$(GREENLIGHT_NAMESPACE)}" 120
