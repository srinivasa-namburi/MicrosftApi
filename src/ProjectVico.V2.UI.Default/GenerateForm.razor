@attribute [Authorize]
@using System.Text.Json;
@using ProjectVico.V2.Shared.Contracts.DTO
@using ProjectVico.V2.Web.Shared.ServiceClients
@using ProjectVico.V2.UI.US.NuclearLicensing

@inject NavigationManager Navigation
@inject IDocumentGenerationApiClient DocumentGenerationApiClient

@code
{
    [Parameter]
    public string? DocumentProcessName { get; set; }

    private readonly string _defaultJsonValue = @"
{
  ""textField1"": ""Text Field 1"",
  ""textField2"": ""Text Field 2"",
  ""arrayField"": [
    ""Array Item 1"",
    ""Array Item 2"",
    ""Array Item 3""
  ],
  ""dateFieldUtc"": ""2021-09-01T00:00:00Z""
}".Trim();

    private readonly GenericDocumentGenerationRequest documentGenerationRequest = new GenericDocumentGenerationRequest(){};

    private bool _showGeneratedDocument = false;
    private MudForm _documentGenerationRequestForm;
    private readonly DocumentGenerationRequestFluentValidator _documentGenerationRequestValidator = new DocumentGenerationRequestFluentValidator();
}

<PageTitle>Generate New Generic Document</PageTitle>

<MudText Typo="Typo.h4" GutterBottom="true">Generate New Generic Document for @DocumentProcessName</MudText>
<MudText Typo="Typo.body1" Class="mb-4" GutterBottom="true">
    To start the document generation process, please fill in as much detail as you can about your project in the following form. <br />
    For the JSON field, please fill in the JSON object that will be used to generate the document. An example has been provided as a default.
</MudText>

<MudForm Model="@documentGenerationRequest" @ref="@_documentGenerationRequestForm" Validation="@(_documentGenerationRequestValidator.ValidateValue)" ValidationDelay="0">
    <MudCard>
        <MudCardContent>
            <MudText Typo="Typo.h6">Report Information</MudText>
            <MudTextField @bind-Value="documentGenerationRequest.DocumentTitle"
                          For="@(() => documentGenerationRequest.DocumentTitle)"
                          Immediate="true"
                          Label="Document title"
                          Variant="Variant.Filled"
                          Margin="Margin.Normal"
                          HelperText="Enter a working title for your document." />
        </MudCardContent>
        <MudCardContent>
            <MudTextField @bind-Value="documentGenerationRequest.StringifiedJson"
                          For="@(() => documentGenerationRequest.StringifiedJson)"
                          Immediate="true"
                          OnlyValidateIfDirty="true"
                          Label="Stringified JSON"
                          Lines="8"
                          AutoGrow="true"
                          MaxLines="12"
                          Variant="Variant.Filled"
                          Margin="Margin.Normal"
                          HelperText="Provide a brief history of your plant’s operation, including operational dates, outages, and any significant performance data." />

        </MudCardContent>

        <MudCardActions>
            <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick=ReportSubmitClick>Generate Document</MudButton>
        </MudCardActions>
    </MudCard>
</MudForm>

@code {

    protected override async Task OnInitializedAsync()
    {
        documentGenerationRequest.StringifiedJson = _defaultJsonValue;
        documentGenerationRequest.DocumentProcessName = DocumentProcessName!;
    }
    
    private async Task ReportSubmitClick()
    {
        _showGeneratedDocument = true;
        documentGenerationRequest.Id = Guid.NewGuid();

        // Set the projected start date from the date picker (convert DateTime to DateOnly)

        if (string.IsNullOrEmpty(documentGenerationRequest.DocumentTitle))
        {
            documentGenerationRequest.DocumentTitle = $@"{DocumentProcessName} + {documentGenerationRequest.Id.ToString()}";
        }

        if (string.IsNullOrEmpty(documentGenerationRequest.StringifiedJson))
        {
            documentGenerationRequest.StringifiedJson = _defaultJsonValue;
        }

        var generateDocumentDto = new GenerateDocumentDTO
            {
                DocumentProcessName = documentGenerationRequest.DocumentProcessName,
                DocumentTitle = documentGenerationRequest.DocumentTitle,
                AuthorOid = documentGenerationRequest.AuthorOid,
                Id = documentGenerationRequest.Id,
                RequestAsJson = JsonSerializer.Serialize(documentGenerationRequest)
            };

        await DocumentGenerationApiClient.GenerateDocumentAsync(generateDocumentDto);
        await InvokeAsync(StateHasChanged);

        Navigation.NavigateTo($"/docs/{documentGenerationRequest.Id}");
    }



    // ---------------------- INPUT VALIDATION ------------------------------------------------------------------------

    /// <summary>
    /// A standard AbstractValidator which contains multiple rules and can be shared with the back end API
    /// </summary>
    /// <typeparam name="DocumentGenerationRequest"></typeparam>
    public class DocumentGenerationRequestFluentValidator : AbstractValidator<GenericDocumentGenerationRequest>
    {
        public DocumentGenerationRequestFluentValidator()
        {
            // Report Information rules
            RuleFor(x => x.DocumentTitle)
                .NotEmpty()
                .Length(1, 100)
                .WithName("Document title");

            // Plant Details rules
            RuleFor(x => x.StringifiedJson)
                .NotEmpty();
        }

        private async Task<bool> IsUniqueAsync(string email)
        {
            // Simulates a long running http call
            await Task.Delay(2000);
            return email.ToLower() != "test@test.com";
        }

        public Func<object, string, Task<IEnumerable<string>>> ValidateValue => async (model, propertyName) =>
        {
            var result = await ValidateAsync(ValidationContext<GenericDocumentGenerationRequest>.CreateWithOptions((GenericDocumentGenerationRequest)model, x => x.IncludeProperties(propertyName)));
            if (result.IsValid)
                return Array.Empty<string>();
            return result.Errors.Select(e => e.ErrorMessage);
        };
    }



}