@using BlazorMonaco.Editor
@inject IJSRuntime JS

<StandaloneCodeEditor @ref="monacoEditor"
                      Id="my-code-editor"
                      ConstructionOptions="EditorConstructionOptions"
                      OnDidChangeModelContent="HandleContentChanged"
                      OnDidInit="HandleEditorInit"
                      CssClass="standaloneEditorDefaultCss" />

<style>
    .standaloneEditorDefaultCss {
        height: @HeightStyle;
        width: @WidthStyle;
    }
</style>

@code {
    private StandaloneCodeEditor? monacoEditor;
    private bool _currentDarkMode;

    /// <summary>
    /// For use within normal component hierarchy
    /// </summary>
    [CascadingParameter(Name = "IsDarkMode")] public bool CascadingIsDarkMode { get; set; }

    /// <summary>
    /// For direct parameter passing (from dialogs)
    /// </summary>
    [Parameter] public bool? IsDarkMode { get; set; }

    [Parameter] public string Value { get; set; } = string.Empty;
    /// <summary>
    /// Height of the editor (default: 400px)
    /// </summary>
    [Parameter] public string HeightStyle { get; set; } = "400px";
    /// <summary>
    /// Width of the editor (default: 100%)
    /// </summary>
    [Parameter] public string WidthStyle { get; set; } = "100%";

    [Parameter] public string EditorTheme { get; set; } = "vs-light";
    /// <summary>
    /// Event to be raised when the value of the editor changes
    /// </summary>
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    /// <summary>
    /// Event to be raised when the content of the editor changes
    /// </summary>
    [Parameter] public EventCallback OnContentChanged { get; set; }

    // Use either the direct parameter or the cascading value
    private bool EffectiveIsDarkMode => IsDarkMode ?? CascadingIsDarkMode;

    protected override async Task OnParametersSetAsync()
    {
        if (_currentDarkMode != EffectiveIsDarkMode && monacoEditor != null)
        {
            _currentDarkMode = EffectiveIsDarkMode;
            await monacoEditor.UpdateOptions(new EditorUpdateOptions() { Theme = EffectiveIsDarkMode ? "vs-dark" : "vs-light" });
        }
    }

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                AutomaticLayout = true,
                Language = "plaintext",
                Theme = EffectiveIsDarkMode ? "vs-dark" : "vs-light",
                Value = Value,
            };
    }

    private async Task HandleContentChanged()
    {
        var currentValue = await monacoEditor.GetValue();
        if (Value != currentValue)
        {
            Value = currentValue;
            await ValueChanged.InvokeAsync(currentValue);
        }

        // Optional: raise an event to notify the dialog to re-check variables
        if (OnContentChanged.HasDelegate)
            await OnContentChanged.InvokeAsync();
    }

    private async Task HandleEditorInit()
    {
        await FocusAndSetCursorToTop();
    }

    private async Task FocusAndSetCursorToTop()
    {
        await monacoEditor.Focus();
        await monacoEditor.SetPosition(new BlazorMonaco.Position() { Column = 1, LineNumber = 1 }, "initial-focus");
    }
}
