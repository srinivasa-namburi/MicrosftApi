@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime

@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Chat
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Commands
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events
@using Microsoft.Greenlight.Web.Shared.Auth

@implements IAsyncDisposable

@if (ConversationId.HasValue)
{
    var containerClass = IsDarkMode ? "chat-container dark-mode" : "chat-container";

        <MudPaper Class="@containerClass" Elevation="0">
            <div class="chat-header">
                <MudIcon Icon="@Icons.Material.Filled.Chat" Class="mr-2" />
                <h2 class="chat-header-title">
                    @(string.IsNullOrEmpty(DocumentProcessName) ? "Conversation" : $"Conversation with {DocumentProcessName}")
                </h2>
                @if (ChatMessages.Any())
                {
                        <MudTooltip Text="Scroll to bottom">
                            <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward"
                                           Color="Color.Inherit"
                                           OnClick="ScrollMessagesToBottom"
                                           Size="Size.Small" />
                        </MudTooltip>
                }
            </div>

            <div @ref="_messagesContainer" class="messages-container">
                @if (!ChatMessages.Any())
                {
                        <div class="empty-state">
                            <MudIcon Icon="@Icons.Material.Outlined.ChatBubbleOutline" Size="Size.Large" Class="mb-4" />
                            <MudText Typo="Typo.body1">No messages yet. Start the conversation!</MudText>
                        </div>
                }
                else
                {
                        <div>
                            @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedUtc))
                            {
                                    <ChatMessageDisplay ChatMessage="@chatMessage" CurrentUser="CurrentUser" />
                            }
                        </div>
                }
            </div>

            <div class="input-container">
                @if (CurrentUser == null)
                {
                        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Width="100%" Height="56px" Animation="Animation.Pulse" />
                }
                else
                {
                        <div class="chat-input-row">
                            <MudTextField @ref="_mudChatTextField" T="string"
                                          OnKeyDown="OnChatTextKeyDown"
                                          ValueChanged="OnChatTextFieldUpdated"
                                          Immediate="false"
                                          DebounceInterval="100"
                                          Lines="2"
                                          MaxLines="6"
                                          AutoGrow="true"
                                          AutoFocus="true"
                                          FullWidth="true"
                                          Placeholder="Type a message..."
                                          Variant="Variant.Outlined"
                                          AdornmentColor="Color.Primary"
                                          AdornmentIcon="@Icons.Material.Filled.Send" />
                            <MudIconButton Icon="@Icons.Material.Filled.Send"
                                           Color="Color.Primary"
                                           OnClick="@(() => SendMessage())"
                                           Size="Size.Medium"
                                           Class="mb-1" />
                        </div>
                }
            </div>
        </MudPaper>
}
else
{
        <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="my-4">
            <MudText>No conversation loaded</MudText>
        </MudAlert>
}

@code {
    [CascadingParameter] public AuthenticationState? AuthenticationState { get; set; }
    [CascadingParameter] public HubConnection? HubConnection { get; set; }
    [CascadingParameter] public bool IsDarkMode { get; set; }

    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string? DocumentProcessName { get; set; }
    [Parameter] public Guid? ExternalReferenceId { get; set; }
    [Parameter] public bool InternalConversationIdCreate { get; set; } = false;

    private MudTextField<string>? _mudChatTextField;
    private bool _chatTextLastKeyWasEnter = false;
    private ElementReference _messagesContainer;
    private string _currentMessage = string.Empty;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private UserInfoDTO? CurrentUser { get; set; }
    private bool _isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        if (!ConversationId.HasValue && InternalConversationIdCreate)
        {
            ConversationId = Guid.NewGuid();
        }

        if (ConversationId.HasValue && !string.IsNullOrEmpty(DocumentProcessName))
        {
            try
            {
                _isLoading = true;
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var userInfo = UserInfo.FromClaimsPrincipal(authState.User);
                CurrentUser = await AuthorizationApiClient.GetUserInfoAsync(userInfo.UserId);

                // This also creates the conversation if it doesn't exist
                ChatMessages = await ChatApiClient.GetChatMessagesAsync(ConversationId.Value, DocumentProcessName);

                await StartHubConnections();
            }
            finally
            {
                _isLoading = false;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            HubConnection = new HubConnectionBuilder()
                .WithUrl($"{apiAddress}/hubs/notification-hub", options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithStatefulReconnect()
                .WithAutomaticReconnect()
                .Build();
        }

        HubConnection.On<ChatMessageResponseReceived>(
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        HubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

        await HubConnection.SendAsync("AddToGroup", ConversationId);
    }

    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        HubConnection.Remove("ReceiveChatMessageResponseReceivedNotification");
        HubConnection.Remove("ReceiveProcessChatMessageReceivedNotification");

        await HubConnection.SendAsync("RemoveFromGroup", ConversationId);
    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            existingMessage.State = obj.ChatMessageDto.State;
            if (existingMessage.Message.Length < obj.ChatMessageDto.Message.Length)
            {
                existingMessage.Message = obj.ChatMessageDto.Message;
            }
        }
        else
        {
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private void OnChatTextKeyDown(KeyboardEventArgs e)
    {
        _chatTextLastKeyWasEnter = e is { Key: "Enter", ShiftKey: false };
    }

    private async Task OnChatTextFieldUpdated(string chatText)
    {
        _currentMessage = chatText;

        if (string.IsNullOrWhiteSpace(chatText))
        {
            return;
        }

        if (_chatTextLastKeyWasEnter)
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_currentMessage))
        {
            return;
        }

        var chatMessage = new ChatMessageDTO
        {
            ConversationId = ConversationId!.Value,
            Id = Guid.NewGuid(),
            Message = _currentMessage,
            CreatedUtc = DateTime.UtcNow,
            Source = ChatMessageSource.User,
            UserId = CurrentUser!.ProviderSubjectId,
            UserFullName = CurrentUser!.FullName
        };

        await ProcessMessage(chatMessage);
    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        var index = ChatMessages.FindLastIndex(x => x.CreatedUtc < chatMessageDto.CreatedUtc);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        _chatTextLastKeyWasEnter = false;
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            _currentMessage = string.Empty;
            await _mudChatTextField.Clear();
            await _mudChatTextField.SetText("");
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await ChatApiClient.SendChatMessageAsync(chatMessageDto);
            await _mudChatTextField.FocusAsync();
        }
    }

    private async Task ScrollMessagesToBottom()
    {
        await JSRuntime.InvokeVoidAsyncIgnoreErrors("scrollToBottom", _messagesContainer);
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }
    }
}
