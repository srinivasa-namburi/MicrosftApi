@using Microsoft.Greenlight.Shared.Contracts.Chat
@using System.Timers
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events

@implements IAsyncDisposable

@code {
    [Parameter] public ChatMessageDTO ChatMessage { get; set; }
    [Parameter] public UserInfoDTO CurrentUser { get; set; }
    [Parameter] public List<ContentReferenceItemInfo> ConversationReferences { get; set; } = new();
    [Parameter] public bool IsContextEditMode { get; set; } = false;
    [Parameter] public EventCallback<string> OnContentSuggestionSelected { get; set; }

    // Direct parameter for dark mode (used when component is in a dialog)
    [Parameter] public bool IsDarkMode { get; set; }

    // For use within normal component hierarchy
    [CascadingParameter(Name = "IsDarkMode")]
    public bool CascadingIsDarkMode { get; set; }

    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    // Use either direct or cascading parameter
    private bool EffectiveIsDarkMode => IsDarkMode || CascadingIsDarkMode;

    private Timer? _timer;
    private bool _showTypingIndicator = true;
    private readonly Regex _referenceRegex = new Regex(@"#\(Reference:([^:]+):([^)]+)\)", RegexOptions.Compiled);
    private List<MessageReference> _messageReferences = new();

    // Status notification properties
    private string? _statusMessage = null;
    private bool _showStatusMessage = false;
    private Timer? _statusTimer;
    private bool _statusProcessingComplete = false;
    private bool _statusPersistent = false;

    protected override void OnInitialized()
    {
        InitializeOrRestartTimer();
        ExtractReferences();
        RegisterForStatusUpdates();
    }

    protected override void OnParametersSet()
    {
        InitializeOrRestartTimer();
        ExtractReferences();
    }

    private void RegisterForStatusUpdates()
    {
        if (HubConnection != null && ChatMessage != null)
        {
            // Register for message-specific status updates
            HubConnection.On<ChatMessageStatusNotification>(
                "ReceiveChatMessageStatusNotification",
                HandleChatMessageStatusNotification);

            // Join message-specific group for targeted updates
            _ = HubConnection.SendAsync("AddToGroup", ChatMessage.Id.ToString());
        }
    }

    /// <summary>
    /// Handles Status Notification messages for this message - received via SignalR.
    /// </summary>
    /// <param name="notification"></param>
    /// <returns></returns>
    private async Task HandleChatMessageStatusNotification(ChatMessageStatusNotification notification)
    {
        if (notification.ChatMessageId == ChatMessage.Id)
        {
            _statusMessage = notification.StatusMessage;
            _showStatusMessage = true;
            _statusProcessingComplete = notification.ProcessingComplete;
            _statusPersistent = notification.Persistent;

            // For processing complete notifications, always treat as non-persistent regardless of the Persistent property
            if (notification.ProcessingComplete)
            {
                _statusPersistent = false;

                // Reset timer for completed notifications - they should disappear after the default time
                _statusTimer?.Dispose();
                _statusTimer = new Timer(2000); // 2 seconds
                _statusTimer.Elapsed += HideStatusMessage;
                _statusTimer.AutoReset = false;
                _statusTimer.Start();
            }
            // For persistent notifications, don't set a timer unless it's a completed notification
            else if (!notification.Persistent)
            {
                // Reset timer for non-persistent notifications
                _statusTimer?.Dispose();
                _statusTimer = new Timer(10000); // 10 seconds
                _statusTimer.Elapsed += HideStatusMessage;
                _statusTimer.AutoReset = false;
                _statusTimer.Start();
            }
            else
            {
                // For persistent notifications, cancel any existing timer
                _statusTimer?.Dispose();
                _statusTimer = null;
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private void HideStatusMessage(object? sender, ElapsedEventArgs e)
    {
        // Don't hide persistent messages via timer
        if (_statusPersistent)
        {
            return;
        }

        // Hide non-persistent messages when the timer expires
        _showStatusMessage = false;
        InvokeAsync(StateHasChanged);
        _statusTimer?.Dispose();
    }

    private void ExtractReferences()
    {
        _messageReferences.Clear();
        var content = GetOriginalMessageContent();

        int referenceNumber = 1;
        foreach (Match match in _referenceRegex.Matches(content))
        {
            if (match.Success && Enum.TryParse<ContentReferenceType>(match.Groups[1].Value, out var referenceType)
                              && Guid.TryParse(match.Groups[2].Value, out var referenceId))
            {
                // Try to find the reference in the conversation references
                var referenceInfo = ConversationReferences.FirstOrDefault(r => r.Id == referenceId);

                var reference = new MessageReference
                {
                    Number = referenceNumber++,
                    ReferenceType = referenceType,
                    ReferenceId = referenceId,
                    FullMatch = match.Value,
                    DisplayName = referenceInfo?.DisplayName ?? $"Reference {referenceId.ToString().Substring(0, 8)}"
                };

                _messageReferences.Add(reference);
            }
        }

        // Handle file reference display names
        foreach (var reference in _messageReferences.Where(r => r.ReferenceType == ContentReferenceType.ExternalFile))
        {
            var fileReference = ConversationReferences.FirstOrDefault(r => r.Id == reference.ReferenceId);
            if (fileReference != null)
            {
                reference.DisplayName = fileReference.DisplayName;
            }
        }
    }

    private string GetFormattedMessageContent()
    {
        var content = ChatMessage.Message ?? string.Empty;

        // Check if this is a message with a content reference
        bool hasContentReference = !string.IsNullOrEmpty(ChatMessage.ContentText) &&
                                   content.Contains("Content included as reference");

        if (hasContentReference)
        {
            // Remove the "Content included as reference" text
            content = content.Replace("(Content included as reference)", "");

            // Add a reference indicator
            content = content.Trim() + "\n\n[Content reference attached]";
        }

        // Replace references with numbered references
        foreach (var reference in _messageReferences)
        {
            content = content.Replace(reference.FullMatch, $"[{reference.Number}]");
        }

        return content;
    }


    private string GetOriginalMessageContent()
    {
        return !string.IsNullOrEmpty(ChatMessage.ContentText)
            ? ChatMessage.ContentText
            : ChatMessage.Message ?? string.Empty;
    }

    private void InitializeOrRestartTimer()
    {
        if (ChatMessage.Source == ChatMessageSource.Assistant &&
            ChatMessage.State == ChatMessageCreationState.InProgress)
        {
            _timer?.Dispose();
            _timer = new Timer(10000); // 10 seconds
            _timer.Elapsed += HideTypingIndicator;
            _timer.AutoReset = false;
            _timer.Start();
        }
        else
        {
            _showTypingIndicator = false;
        }
    }

    private void HideTypingIndicator(object? sender, ElapsedEventArgs e)
    {
        _showTypingIndicator = false;
        InvokeAsync(StateHasChanged);
        _timer?.Dispose();
    }

    private bool IsCurrentUser =>
        ChatMessage.Source == ChatMessageSource.User &&
        ChatMessage.UserId == CurrentUser?.ProviderSubjectId;

    private string GetMessageClass()
        => IsCurrentUser
            ? "message-wrapper message-wrapper-user"
            : "message-wrapper message-wrapper-other";

    private string GetBubbleClass()
    {
        if (IsCurrentUser)
            return "message-bubble message-bubble-user";
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "message-bubble message-bubble-assistant";
        if (ChatMessage.Source == ChatMessageSource.System)
            return "message-bubble message-bubble-system";
        return "message-bubble message-bubble-other";
    }

    private string GetAvatarClass()
    {
        if (IsCurrentUser)
            return "avatar avatar-user";
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "avatar avatar-assistant";
        if (ChatMessage.Source == ChatMessageSource.System)
            return "avatar avatar-system";
        return "avatar avatar-other";
    }

    private string GetMetaClass()
        => IsCurrentUser
            ? "message-meta message-meta-user"
            : "message-meta";

    private string GetInitials()
    {
        if (string.IsNullOrEmpty(ChatMessage.UserFullName))
            return "?";

        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "AI";

        if (ChatMessage.Source == ChatMessageSource.System)
            return "SYS";

        var parts = ChatMessage.UserFullName.Split(' ');
        if (parts.Length == 1)
            return parts[0].Substring(0, 1).ToUpper();

        return $"{parts[0].Substring(0, 1)}{parts[^1].Substring(0, 1)}".ToUpper();
    }

    private string FormatDateTime(DateTime dateTime)
    {
        if (dateTime.Date == DateTime.Today)
            return $"Today at {dateTime:HH:mm}";
        if (dateTime.Date == DateTime.Today.AddDays(-1))
            return $"Yesterday at {dateTime:HH:mm}";
        return $"{dateTime:MMM d, yyyy HH:mm}";
    }

    private string GetReferenceIcon(ContentReferenceType referenceType)
    {
        return referenceType switch
        {
            ContentReferenceType.GeneratedDocument => Icons.Material.Filled.Description,
            ContentReferenceType.GeneratedSection => Icons.Material.Filled.Subject,
            ContentReferenceType.ExternalFile => Icons.Material.Filled.AttachFile,
            ContentReferenceType.ReviewItem => Icons.Material.Filled.RateReview,
            _ => Icons.Material.Filled.Link,
        };
    }

    private async Task ApplySuggestion()
    {
        if (IsContextEditMode && !string.IsNullOrEmpty(ChatMessage.ContentText))
        {
            await OnContentSuggestionSelected.InvokeAsync(ChatMessage.ContentText);
        }
    }

    public async ValueTask DisposeAsync()
    {
        _timer?.Dispose();
        _statusTimer?.Dispose();

        if (HubConnection != null && ChatMessage != null)
        {
            // Remove from message-specific group
            await HubConnection.SendAsync("RemoveFromGroup", ChatMessage.Id.ToString());

            // Unregister notifications
            HubConnection.Remove("ReceiveChatMessageStatusNotification");
        }
    }

    private class MessageReference
    {
        public int Number { get; set; }
        public ContentReferenceType ReferenceType { get; set; }
        public Guid ReferenceId { get; set; }
        public string? FullMatch { get; set; }
        public string? DisplayName { get; set; }
    }
}

@{
    var wrapperClass = GetMessageClass() + (EffectiveIsDarkMode ? " dark-mode" : "");
}

@if (IsCurrentUser)
{
    <!-- User Message (Right-aligned) -->
    <div class="@wrapperClass">
        <div class="avatar-space-left">
            <div class="@GetAvatarClass()" title="@ChatMessage.UserFullName">
                @GetInitials()
            </div>
        </div>
        <div class="flex-grow-1">
            <div class="@GetBubbleClass()">
                <div class="message-content">
                    <RenderMultilineText Value="@GetFormattedMessageContent()" />

                    @if (_messageReferences.Any())
                    {
                        <div class="chat-message-attachments">
                            @foreach (var reference in _messageReferences)
                            {
                                <div class="chat-message-attachment-item">
                                    <span class="chat-message-attachment-number">[@reference.Number]</span>
                                    <MudIcon Icon="@GetReferenceIcon(reference.ReferenceType)" Size="Size.Small" Class="mx-1" />
                                    <span class="chat-message-attachment-name text-truncate">@reference.DisplayName</span>
                                </div>
                            }
                        </div>
                    }

                    @if (_showStatusMessage && !string.IsNullOrEmpty(_statusMessage))
                    {
                        <MudDivider />
                        <div class="message-status-container d-flex align-end flex-column">
                            <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                                <MudText Typo="Typo.caption">@_statusMessage</MudText>
                                @if (!_statusProcessingComplete)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-1" />
                                }
                                else
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="mr-1" />
                                }
                            </MudStack>
                        </div>
                    }
                </div>
            </div>

            <div class="@GetMetaClass()">
                <MudText Typo="Typo.caption">
                    @FormatDateTime(ChatMessage.CreatedUtc)
                    @if (ChatMessage.State != ChatMessageCreationState.Complete)
                    {
                        <span class="state-indicator">
                            @if (ChatMessage.State == ChatMessageCreationState.InProgress)
                            {
                                <MudIcon Icon="@Icons.Material.Filled.HourglassEmpty" Size="Size.Small" />
                                <span>In progress</span>
                            }
                            else if (ChatMessage.State == ChatMessageCreationState.Failed)
                            {
                                <MudIcon Icon="@Icons.Material.Filled.Error" Size="Size.Small" />
                                <span>Failed</span>
                            }
                        </span>
                    }
                </MudText>
            </div>
        </div>

    </div>
}
else
{
    <!-- Assistant/Other Message (Left-aligned) -->
    <div class="@wrapperClass">
        <div class="avatar-space-right">
            <div class="@GetAvatarClass()" title="@ChatMessage.UserFullName">
                @GetInitials()
            </div>
        </div>
        <div class="flex-grow-1">
            <div class="@GetBubbleClass()">
                <div class="message-content">
                    <RenderMultilineText Value="@GetFormattedMessageContent()" />

                    @if (_messageReferences.Any())
                    {
                        <div class="chat-message-attachments">
                            @foreach (var reference in _messageReferences)
                            {
                                <div class="chat-message-attachment-item">
                                    <span class="chat-message-attachment-number">[@reference.Number]</span>
                                    <MudIcon Icon="@GetReferenceIcon(reference.ReferenceType)" Size="Size.Small" Class="mx-1" />
                                    <span class="chat-message-attachment-name text-truncate">@reference.DisplayName</span>
                                </div>
                            }
                        </div>
                    }

                    @if (IsContextEditMode && ChatMessage.Source == ChatMessageSource.Assistant && !string.IsNullOrEmpty(ChatMessage.ContentText))
                    {
                        <MudDivider Class="my-2" />
                        <MudText Typo="Typo.subtitle2" Class="mt-2">Suggested Content:</MudText>
                        <MudPaper Elevation="0" Class="pa-2 my-2" Style="background-color: var(--mud-palette-background-gray)">
                            <MudText Typo="Typo.body2" Style="white-space: pre-wrap; max-height: 200px; overflow-y: auto;">@ChatMessage.ContentText</MudText>
                        </MudPaper>
                        <MudButton Color="Color.Primary"
                                   Variant="Variant.Filled"
                                   Size="Size.Small"
                                   OnClick="ApplySuggestion"
                                   Class="mt-1">
                            Apply Suggestion
                        </MudButton>
                    }

                    @if (_showStatusMessage && !string.IsNullOrEmpty(_statusMessage))
                    {
                        <MudDivider Class="mt-2 mb-1" />
                        <div class="message-status-container d-flex align-end flex-column">
                            <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                                @if (!_statusProcessingComplete)
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-1" />
                                }
                                else
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="mr-1" />
                                }
                                <MudText Typo="Typo.caption">@_statusMessage</MudText>
                            </MudStack>
                        </div>
                    }
                </div>
            </div>

            <div class="@GetMetaClass()">
                @if (ChatMessage is { Source: ChatMessageSource.Assistant, State: ChatMessageCreationState.InProgress } && _showTypingIndicator)
                {
                    <div class="typing-indicator">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                }
                else
                {
                    <MudText Typo="Typo.caption">
                        @FormatDateTime(ChatMessage.CreatedUtc)
                        @if (ChatMessage.State != ChatMessageCreationState.Complete)
                        {
                            <span class="state-indicator">
                                @if (ChatMessage.State == ChatMessageCreationState.InProgress)
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.HourglassEmpty" Size="Size.Small" />
                                    <span>In progress</span>
                                }
                                else if (ChatMessage.State == ChatMessageCreationState.Failed)
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.Error" Size="Size.Small" />
                                    <span>Failed</span>
                                }
                            </span>
                        }
                    </MudText>
                }
            </div>
        </div>
    </div>
}
