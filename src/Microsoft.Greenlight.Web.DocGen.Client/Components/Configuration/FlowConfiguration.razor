@* Copyright (c) Microsoft Corporation. All rights reserved. *@
@using Microsoft.Greenlight.Shared.Configuration
@using Microsoft.Greenlight.Shared.Contracts.DTO.Configuration
@using Microsoft.Greenlight.Shared.Enums
@using Microsoft.Greenlight.Web.DocGen.Client.ServiceClients
@inject IConfigurationApiClient ConfigApi
@inject IDialogService DialogService
@inherits Microsoft.Greenlight.Web.DocGen.Client.Components.Configuration.Infrastructure.ConfigurationSectionBase

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h6">Flow AI Assistant Configuration</MudText>
    <MudText Typo="Typo.body2" Class="mb-3">Configure settings for the Flow AI Assistant including model selection and conversation parameters.</MudText>
    <MudDivider Class="mt-2 mb-3" />

    <MudGrid>
        <MudItem xs="12" md="6">
            <MudCard Outlined>
                <MudCardContent>
                    <MudText Typo="Typo.h6" Class="mb-3">Model Configuration</MudText>

                    <MudSelect T="AiModelDeploymentInfo" @bind-Value="SelectedDeployment"
                              Label="AI Model Deployment"
                              ToStringFunc="@(d => d.DeploymentName)"
                              HelperText="The AI model deployment used for Flow conversations. Temperature and token limits are configured per model deployment."
                              Class="mb-3">
                        @foreach (var deployment in _chatModelDeployments)
                        {
                            <MudSelectItem Value="@deployment">
                                @deployment.DeploymentName
                            </MudSelectItem>
                        }
                    </MudSelect>

                    @if (SelectedDeployment?.AiModel != null)
                    {
                        <MudAlert Severity="Severity.Info" Class="mb-3">
                            <strong>@SelectedDeployment.DeploymentName</strong> model settings (temperature, max tokens, etc.) are configured via AI Model Deployments in the system configuration.
                        </MudAlert>
                    }
                </MudCardContent>
            </MudCard>
        </MudItem>

        <MudItem xs="12" md="6">
            <MudCard Outlined>
                <MudCardContent>
                    <MudText Typo="Typo.h6" Class="mb-3">Conversation Settings</MudText>

                    <MudSwitch T="bool" @bind-Value="EnableIntentDetection"
                              Label="Enable Intent Detection"
                              Color="Color.Primary"
                              Class="mb-3" />
                    <MudText Typo="Typo.caption" Class="mb-3">Automatically detect when users need specific document processes</MudText>

                    <MudSwitch T="bool" @bind-Value="EnableConversationalFallback"
                              Label="Enable Conversational Fallback"
                              Color="Color.Primary"
                              Class="mb-3" />
                    <MudText Typo="Typo.caption" Class="mb-3">Respond conversationally when no specific intent is detected</MudText>

                    <MudNumericField @bind-Value="ConversationHistoryLimit"
                                    Label="Conversation History Limit"
                                    Min="1"
                                    Max="100"
                                    HelperText="Number of previous messages to include in context"
                                    Immediate="true"
                                    Class="mb-3" />

                    <MudDivider Class="my-3" />
                    <MudText Typo="Typo.subtitle2" Class="mb-2">Intent Detection Thresholds</MudText>

                    <MudSlider @bind-Value="MinimumIntentRelevanceThreshold"
                              Min="0.0"
                              Max="1.0"
                              Step="0.05"
                              Color="Color.Secondary"
                              Immediate="true"
                              Class="mb-1">
                        Minimum Relevance: @MinimumIntentRelevanceThreshold.ToString("0.00")
                    </MudSlider>
                    <MudText Typo="Typo.caption" Class="mb-3">
                        Document processes must score above this threshold to be engaged (0.0 = any match, 1.0 = perfect match)
                    </MudText>

                    <MudSwitch T="bool" @bind-Value="RequireMinimumRelevanceForEngagement"
                              Label="Require Minimum Relevance"
                              Color="Color.Secondary"
                              Class="mb-1" />
                    <MudText Typo="Typo.caption" Class="mb-3">
                        When enabled, if no document process meets the threshold, Flow will respond conversationally instead
                    </MudText>
                </MudCardContent>
            </MudCard>
        </MudItem>

        <MudItem xs="12">
            <MudCard Outlined>
                <MudCardContent>
                    <MudText Typo="Typo.h6" Class="mb-3">System Prompts</MudText>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        Configure the AI prompts used by Flow for different scenarios. Click "Edit" to customize each prompt.
                    </MudText>

                    <MudText Typo="Typo.subtitle1" Class="mt-4 mb-2">Orchestration Prompts</MudText>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        Prompts used for Flow orchestration, intent detection, and response synthesis.
                    </MudText>
                    <MudStack Spacing="2" Class="mb-4">
                        @foreach (var promptName in _systemPromptNames)
                        {
                            <MudPaper Outlined="true" Class="pa-3">
                                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                    <MudStack Spacing="1">
                                        <MudText Typo="Typo.subtitle2">@GetPromptDisplayName(promptName)</MudText>
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">@GetPromptDescription(promptName)</MudText>
                                    </MudStack>
                                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                        @if (_promptStatuses.TryGetValue(promptName, out var isCustomized))
                                        {
                                            <MudChip T="string" Color="@(isCustomized ? Color.Secondary : Color.Default)" Variant="Variant.Outlined" Size="Size.Small">
                                                @(isCustomized ? "Customized" : "Default")
                                            </MudChip>
                                        }
                                        <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="@(() => EditPrompt(promptName))">
                                            Edit
                                        </MudButton>
                                    </MudStack>
                                </MudStack>
                            </MudPaper>
                        }
                    </MudStack>

                    <MudDivider Class="my-4" />

                    <MudText Typo="Typo.subtitle1" Class="mb-2">Task Execution Prompts</MudText>
                    <MudText Typo="Typo.body2" Class="mb-3">
                        Prompts used during Flow Task execution for field extraction, requirement prompting, validation, and output generation.
                    </MudText>
                    <MudStack Spacing="2">
                        @foreach (var promptName in _flowTaskPromptNames)
                        {
                            <MudPaper Outlined="true" Class="pa-3">
                                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                                    <MudStack Spacing="1">
                                        <MudText Typo="Typo.subtitle2">@GetPromptDisplayName(promptName)</MudText>
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">@GetPromptDescription(promptName)</MudText>
                                    </MudStack>
                                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                                        @if (_promptStatuses.TryGetValue(promptName, out var taskIsCustomized))
                                        {
                                            <MudChip T="string" Color="@(taskIsCustomized ? Color.Secondary : Color.Default)" Variant="Variant.Outlined" Size="Size.Small">
                                                @(taskIsCustomized ? "Customized" : "Default")
                                            </MudChip>
                                        }
                                        <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="@(() => EditPrompt(promptName))">
                                            Edit
                                        </MudButton>
                                    </MudStack>
                                </MudStack>
                            </MudPaper>
                        }
                    </MudStack>
                </MudCardContent>
            </MudCard>
        </MudItem>
    </MudGrid>
</MudPaper>

@code {
    private ServiceConfigurationOptions.FlowOptions _options = new();
    private string _initial = string.Empty;
    private List<AiModelDeploymentInfo> _aiModelDeployments = new();
    private List<AiModelDeploymentInfo> _chatModelDeployments = new();
    private readonly List<string> _systemPromptNames = new()
    {
        "FlowUserConversationSystemPrompt",
        "FlowBackendConversationSystemPrompt",
        "FlowIntentDetectionPrompt",
        "FlowResponseSynthesisPrompt",
        "FlowConversationalFallbackPrompt"
    };
    private readonly List<string> _flowTaskPromptNames = new()
    {
        "FlowTaskFieldExtractionPrompt",
        "FlowTaskRequirementPromptingPrompt",
        "FlowTaskValidationRepromptPrompt",
        "FlowTaskOutputSummaryPrompt",
        "FlowTaskOptionalFieldsPrompt",
        "FlowTaskOptionalFieldSelectionPrompt"
    };
    private Dictionary<string, bool> _promptStatuses = new();
    public override string Title => "Flow Assistant";

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync();
        await LoadPromptStatusesAsync();
    }

    public override async Task LoadAsync(CancellationToken cancellationToken = default)
    {
        // Load both Flow options and AI model deployments
        var flowTask = ConfigApi.GetFlowOptionsAsync();
        var deploymentsTask = ConfigApi.GetAiModelDeploymentsAsync();

        await Task.WhenAll(flowTask, deploymentsTask);

        _options = flowTask.Result;
        _aiModelDeployments = deploymentsTask.Result;

        // Filter to only chat/completion models (exclude embedding models and fix the bug mentioned)
        _chatModelDeployments = _aiModelDeployments
            .Where(d => d.AiModel?.ModelType != AiModelType.Embedding)
            .ToList();

        _initial = System.Text.Json.JsonSerializer.Serialize(_options);
        SetDirty(false);
    }

    private void MarkDirty()
    {
        var cur = System.Text.Json.JsonSerializer.Serialize(_options);
        SetDirty(!string.Equals(cur, _initial, StringComparison.Ordinal));
    }

    // Model deployment selection property
    private AiModelDeploymentInfo? SelectedDeployment
    {
        get => _chatModelDeployments.FirstOrDefault(d => d.DeploymentName == _options.DefaultModelDeployment);
        set
        {
            _options.DefaultModelDeployment = value?.DeploymentName ?? "gpt-4o";
            MarkDirty();
        }
    }

    // Wrapper properties to track changes on Flow-specific fields
    private bool EnableIntentDetection { get => _options.EnableIntentDetection; set { _options.EnableIntentDetection = value; MarkDirty(); } }
    private bool EnableConversationalFallback { get => _options.EnableConversationalFallback; set { _options.EnableConversationalFallback = value; MarkDirty(); } }
    private int ConversationHistoryLimit { get => _options.ConversationHistoryLimit; set { _options.ConversationHistoryLimit = value; MarkDirty(); } }
    private double MinimumIntentRelevanceThreshold { get => _options.MinimumIntentRelevanceThreshold; set { _options.MinimumIntentRelevanceThreshold = value; MarkDirty(); } }
    private bool RequireMinimumRelevanceForEngagement { get => _options.RequireMinimumRelevanceForEngagement; set { _options.RequireMinimumRelevanceForEngagement = value; MarkDirty(); } }

    public override async Task SaveAsync(CancellationToken cancellationToken = default)
    {
        var items = new Dictionary<string, string>
        {
            ["ServiceConfiguration:GreenlightServices:Flow:DefaultModelDeployment"] = _options.DefaultModelDeployment ?? string.Empty,
            ["ServiceConfiguration:GreenlightServices:Flow:EnableIntentDetection"] = _options.EnableIntentDetection.ToString(),
            ["ServiceConfiguration:GreenlightServices:Flow:EnableConversationalFallback"] = _options.EnableConversationalFallback.ToString(),
            ["ServiceConfiguration:GreenlightServices:Flow:ConversationHistoryLimit"] = _options.ConversationHistoryLimit.ToString(),
            ["ServiceConfiguration:GreenlightServices:Flow:MinimumIntentRelevanceThreshold"] = _options.MinimumIntentRelevanceThreshold.ToString("F2"),
            ["ServiceConfiguration:GreenlightServices:Flow:RequireMinimumRelevanceForEngagement"] = _options.RequireMinimumRelevanceForEngagement.ToString()
        };

        await ConfigApi.UpdateConfigurationAsync(new Microsoft.Greenlight.Shared.Contracts.DTO.ConfigurationUpdateRequest
        {
            ConfigurationItems = items
        });
        _initial = System.Text.Json.JsonSerializer.Serialize(_options);
        SetDirty(false);
    }

    public override IEnumerable<string> DescribePendingChanges()
    {
        var before = System.Text.Json.JsonSerializer.Deserialize<ServiceConfigurationOptions.FlowOptions>(_initial) ?? new();
        if (_options.DefaultModelDeployment != before.DefaultModelDeployment) yield return $"AI Model: {before.DefaultModelDeployment} → {_options.DefaultModelDeployment}";
        if (_options.EnableIntentDetection != before.EnableIntentDetection) yield return $"Intent Detection: {before.EnableIntentDetection} → {_options.EnableIntentDetection}";
        if (_options.EnableConversationalFallback != before.EnableConversationalFallback) yield return $"Conversational Fallback: {before.EnableConversationalFallback} → {_options.EnableConversationalFallback}";
        if (_options.ConversationHistoryLimit != before.ConversationHistoryLimit) yield return $"History Limit: {before.ConversationHistoryLimit} → {_options.ConversationHistoryLimit}";
        if (Math.Abs(_options.MinimumIntentRelevanceThreshold - before.MinimumIntentRelevanceThreshold) > 0.001) yield return $"Min Relevance: {before.MinimumIntentRelevanceThreshold:F2} → {_options.MinimumIntentRelevanceThreshold:F2}";
        if (_options.RequireMinimumRelevanceForEngagement != before.RequireMinimumRelevanceForEngagement) yield return $"Require Min Relevance: {before.RequireMinimumRelevanceForEngagement} → {_options.RequireMinimumRelevanceForEngagement}";
    }

    private async Task LoadPromptStatusesAsync()
    {
        _promptStatuses.Clear();
        var allPromptNames = _systemPromptNames.Concat(_flowTaskPromptNames);
        foreach (var promptName in allPromptNames)
        {
            try
            {
                var prompt = await ConfigApi.GetSystemPromptAsync(promptName);
                _promptStatuses[promptName] = prompt.IsCustomized;
            }
            catch
            {
                // Default to false if we can't load the prompt status
                _promptStatuses[promptName] = false;
            }
        }
    }

    private async Task EditPrompt(string promptName)
    {
        var parameters = new DialogParameters
        {
            { nameof(EditSystemPromptDialog.PromptName), promptName }
        };

        var options = new DialogOptions
        {
            CloseButton = true,
            MaxWidth = MaxWidth.Large,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<EditSystemPromptDialog>($"Edit {GetPromptDisplayName(promptName)}", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            // Reload prompt statuses after editing
            await LoadPromptStatusesAsync();
        }
    }

    private static string GetPromptDisplayName(string promptName)
    {
        return promptName switch
        {
            "FlowUserConversationSystemPrompt" => "User Conversation System Prompt",
            "FlowBackendConversationSystemPrompt" => "Backend Conversation System Prompt",
            "FlowIntentDetectionPrompt" => "Intent Detection Prompt",
            "FlowResponseSynthesisPrompt" => "Response Synthesis Prompt",
            "FlowConversationalFallbackPrompt" => "Conversational Fallback Prompt",
            "FlowTaskFieldExtractionPrompt" => "Task Field Extraction Prompt",
            "FlowTaskRequirementPromptingPrompt" => "Task Requirement Prompting",
            "FlowTaskValidationRepromptPrompt" => "Task Validation Reprompt",
            "FlowTaskOutputSummaryPrompt" => "Task Output Summary",
            "FlowTaskOptionalFieldsPrompt" => "Optional Fields Offer",
            "FlowTaskOptionalFieldSelectionPrompt" => "Optional Field Selection Parser",
            _ => promptName
        };
    }

    private static string GetPromptDescription(string promptName)
    {
        return promptName switch
        {
            "FlowUserConversationSystemPrompt" => "System prompt used when conversing directly with users",
            "FlowBackendConversationSystemPrompt" => "System prompt used for backend AI reasoning and orchestration",
            "FlowIntentDetectionPrompt" => "Prompt for detecting user intent and matching to document processes",
            "FlowResponseSynthesisPrompt" => "Prompt for synthesizing final responses from process outputs",
            "FlowConversationalFallbackPrompt" => "Prompt used when no specific document process intent is detected",
            "FlowTaskFieldExtractionPrompt" => "Prompt for extracting field values from user messages during Flow Task execution",
            "FlowTaskRequirementPromptingPrompt" => "Prompt for generating conversational requests for required field values",
            "FlowTaskValidationRepromptPrompt" => "Prompt for handling validation failures and reprompting users",
            "FlowTaskOutputSummaryPrompt" => "Prompt for generating completion summaries when Flow Tasks finish",
            "FlowTaskOptionalFieldsPrompt" => "Prompt for offering optional fields after required fields are collected",
            "FlowTaskOptionalFieldSelectionPrompt" => "Prompt for parsing user's optional field selection intent",
            _ => "System prompt configuration"
        };
    }
}