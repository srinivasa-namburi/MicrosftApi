@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.DTO.Configuration
@using Microsoft.Greenlight.Shared.Contracts.Requests.FileStorage
@using Microsoft.Greenlight.Shared.Enums
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject IFileStorageHostApiClient FileStorageHostApiClient
@inject IFileStorageSourceApiClient FileStorageSourceApiClient
@inject IDocumentLibraryApiClient DocumentLibraryApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject IFileApiClient FileApiClient
@inject IPluginApiClient PluginApiClient
@inject IDocumentReindexApiClient DocumentReindexApiClient
@inject ISnackbar SnackBar
@inject IDialogService DialogService
@inject SignalRConnectionService SignalRConnectionService
@inject SignalRSubscriptionFactory SignalRSubscriptionFactory
@using Microsoft.Greenlight.Shared.Contracts.Messages.Reindexing.Events
@implements IAsyncDisposable

@if (_isLoading)
{
    <!-- Loading indicator displayed during initialization -->
    <MudPaper Class="pa-6 d-flex flex-column align-center justify-center" Style="min-height: 300px;">
        <MudProgressCircular Size="Size.Large" Indeterminate="true" Color="Color.Primary" Class="mb-4" />
        <MudText Typo="Typo.h5" Align="Align.Center">Loading Document Process details...</MudText>
    </MudPaper>
}
else
{
    <MudPaper Class="pa-6">
        <MudText Typo="Typo.h5">@(_isEditMode ? "Edit Document Process" : "Create Document Process")</MudText>
        <MudDivider Class="mt-2 mb-5" />
        <MudGrid>
            <MudItem xs="12">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.h6">Basic Information</MudText>
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.body2" Class="text-right">
                            <strong>Logic Type:</strong> @_process.LogicType.ToString()
                        </MudText>
                        @if (_isEditMode && _process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                        {
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Size="Size.Small" OnClick="OpenVectorSearchDialog" StartIcon="@Icons.Material.Filled.Search">
                                Search Vector Store
                            </MudButton>
                        }
                        @if (_isEditMode)
                        {
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Size="Size.Small" OnClick="OpenExportDialog" StartIcon="@Icons.Material.Filled.Download">
                                Export Definition
                            </MudButton>
                        }
                    </MudStack>
                </MudStack>
            </MudItem>
        </MudGrid>

        <!-- Inline Reindex Status -->
        @if (_isEditMode && ShouldShowProcessBanner)
        {
            <MudGrid Class="mb-2">
                <MudItem xs="12">
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.subtitle2">Reindexing Status:</MudText>

                        <MudChip T="string" Color="@GetStatusColor(_processReindexStatus!.Status)" Variant="Variant.Filled">
                            Process: @_processReindexStatus!.Status.ToString() (@_processReindexStatus!.ProcessedDocuments/@_processReindexStatus!.TotalDocuments)
                        </MudChip>
                        <MudButton Size="Size.Small" Variant="Variant.Outlined" Color="Color.Info" OnClick="OpenProcessReindexProgress">View details</MudButton>
                        <MudSpacer />
                        <MudTooltip Text="Refresh reindex status">
                            <MudIconButton Icon="@Icons.Material.Filled.Refresh" OnClick="RefreshReindexStatusesAsync" />
                        </MudTooltip>
                    </MudStack>
                </MudItem>
            </MudGrid>
        }

        <MudGrid Spacing="6">
            <MudItem xs="12" md="6">
                <MudGrid Spacing="3">
                    <MudItem xs="12">
                        <MudTextField @bind-Value="_process.ShortName" Label="Short Name" Disabled="_isEditMode" OnBlur="ValidateAndFormatShortName" />
                    </MudItem>
                    <MudItem xs="12">
                        <MudTextField @bind-Value="_process.Description" Label="Description" Lines="3" />
                    </MudItem>

                    <MudItem xs="12">
                        <MudText Typo="Typo.subtitle2" Class="mb-2">AI Model Configuration</MudText>
                    </MudItem>

                    <MudItem xs="12">
                        <MudSelect T="AiModelDeploymentInfo" @bind-Value="SelectedDeployment" Label="AI Model Deployment"
                                   ToStringFunc="@(d => d.DeploymentName)">
                            @foreach (var deployment in _aiModelDeployments.Where(d => d.AiModel?.ModelType != AiModelType.Embedding))
                            {
                                <MudSelectItem Value="@deployment">
                                    @deployment.DeploymentName
                                </MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>

                    <MudItem xs="12">
                        <MudSelect T="AiModelDeploymentInfo" @bind-Value="SelectedValidationDeployment" Label="AI Model Deployment for Validation"
                                   ToStringFunc="@(d => d.DeploymentName)">
                            @foreach (var deployment in _aiModelDeployments.Where(d => d.AiModel?.ModelType != AiModelType.Embedding))
                            {
                                <MudSelectItem Value="@deployment">
                                    @deployment.DeploymentName
                                </MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>

                    <MudItem xs="12">
                        <MudSelect T="DocumentProcessCompletionServiceType" @bind-Value="_completionServiceType" Label="AI Completion Service">
                            <MudSelectItem Value="DocumentProcessCompletionServiceType.GenericAiCompletionService">Generic AI Completion Service</MudSelectItem>
                            <MudSelectItem Value="DocumentProcessCompletionServiceType.AgentAiCompletionService">Agent AI Completion Service</MudSelectItem>
                        </MudSelect>
                    </MudItem>
                </MudGrid>

                <MudExpansionPanels Class="mt-2">
                    <MudExpansionPanel Text="Storage & Index" Expanded="true">
                        <MudTextField @bind-Value="_indexName" Label="Repository Index Name" Disabled="_isEditMode" OnInternalInputChanged="UpdateRepositories" />

                        <!-- File Storage Sources -->
                        <div class="mt-4">
                            <PermissionView Permission="@Microsoft.Greenlight.Shared.Contracts.Authorization.PermissionKeys.AlterDocumentProcessesAndLibraries">
                                <ChildContent>
                                    <FileStorageSourceListComponent DocumentProcessId="@ProcessId"
                                                                    LegacyContainerName="@_process.BlobStorageContainerName"
                                                                    LegacyAutoImportFolder="@_process.BlobStorageAutoImportFolderName"
                                                                    ShowBackwardCompatibility="true"
                                                                    OnMigrateLegacy="HandleMigrateLegacyStorage" />
                                </ChildContent>
                                <NotAuthorized>
                                    <MudAlert Severity="Severity.Info">
                                        You need the "Alter Document Processes and Libraries" permission to manage file storage sources.
                                    </MudAlert>
                                </NotAuthorized>
                            </PermissionView>
                        </div>

                        <!-- Legacy fields - shown as read-only for reference -->
                        @if (_isEditMode && !string.IsNullOrEmpty(_process.BlobStorageContainerName))
                        {
                            <MudDivider Class="mt-5 mb-4" />
                            <MudText Typo="Typo.subtitle2" Class="mb-2">Legacy Configuration (Read-Only)</MudText>
                            <MudTextField Value="_process.BlobStorageContainerName" Label="Legacy Blob Storage Container Name" Disabled="true" />
                            <MudTextField Value="_process.BlobStorageAutoImportFolderName" Label="Legacy Auto Import Folder Name" Disabled="true" />
                        }
                    </MudExpansionPanel>

                    <MudExpansionPanel Text="Vector Store Configuration" Expanded="true">
                        @if (_process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                        {
                            <MudSelect T="TextChunkingMode?" @bind-Value="_process.VectorStoreChunkingMode" Label="Chunking Mode">
                                @foreach (var mode in Enum.GetValues<TextChunkingMode>())
                                {
                                    <MudSelectItem Value="@(mode as TextChunkingMode?)">@mode.ToString()</MudSelectItem>
                                }
                            </MudSelect>

                            <MudNumericField T="int?" @bind-Value="_process.VectorStoreChunkSize" Label="Chunk Size (tokens)" Min="100" Max="8000" HelperText="Number of tokens per chunk. Leave empty to use global default." />
                            <MudNumericField T="int?" @bind-Value="_process.VectorStoreChunkOverlap" Label="Chunk Overlap (tokens)" Min="0" Max="2000" HelperText="Number of overlapping tokens between chunks. Leave empty to use global default." />

                            <MudDivider Class="mt-2 mb-3" />

                            <MudSelect T="AiModelDeploymentInfo" Label="Embedding Model Deployment" @bind-Value="SelectedEmbeddingDeployment" ToStringFunc="@(d => d.DeploymentName)">
                                @foreach (var deployment in _aiModelDeployments.Where(d => d.AiModel?.ModelType == AiModelType.Embedding))
                                {
                                    <MudSelectItem Value="@deployment">@deployment.DeploymentName</MudSelectItem>
                                }
                            </MudSelect>

                            <MudSelect T="int?" @bind-Value="_process.EmbeddingDimensionsOverride" Label="Embedding Size Override (dimensions)">
                                <MudSelectItem T="int?" Value="@(default(int?))">Use deployment default</MudSelectItem>
                                <MudSelectItem T="int?" Value="256">256</MudSelectItem>
                                <MudSelectItem T="int?" Value="512">512</MudSelectItem>
                                <MudSelectItem T="int?" Value="1024">1024</MudSelectItem>
                                <MudSelectItem T="int?" Value="1536">1536</MudSelectItem>
                                <MudSelectItem T="int?" Value="3072">3072</MudSelectItem>
                            </MudSelect>

                            <MudAlert Severity="Severity.Info" Class="mt-2">
                                <strong>Note:</strong> Changing chunk size or overlap will only apply to newly ingested documents. You can reindex existing documents to apply new settings.
                            </MudAlert>
                        }
                    </MudExpansionPanel>
                </MudExpansionPanels>

                <!-- File Upload Section -->
                @if (ProcessId != null && _isEditMode)
                {
                    <MudDivider Class="mt-5 mb-4" />

                    <MudGrid Spacing="2" Class="mt-4 mb-2">
                        <MudItem>
                            <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                                           FilesChanged="HandleFileSelected"
                                           MaximumFileCount="16384">
                                <ActivatorContent>
                                    <MudButton HtmlTag="label"
                                               Variant="Variant.Outlined"
                                               Color="Color.Secondary"
                                               StartIcon="@Icons.Material.Filled.CloudUpload"
                                               Disabled="_isUploadingFiles">
                                        @if (_isUploadingFiles)
                                        {
                                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-2" />
                                            @:Uploading...
                                        }
                                        else
                                        {
                                            @:Upload Documents
                                        }
                                    </MudButton>
                                </ActivatorContent>
                            </MudFileUpload>
                        </MudItem>
                        @if (_process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                        {
                            <MudItem>
                                <MudButton Variant="Variant.Outlined" Color="Color.Secondary" StartIcon="@Icons.Material.Filled.Refresh" OnClick="ShowReindexDialog" Disabled="_processReindexStatus?.Status == ReindexOrchestrationState.Running">
                                    @if (_processReindexStatus?.Status == ReindexOrchestrationState.Running)
                                    {
                                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-2" />
                                        @:Reindexing...
                                    }
                                    else
                                    {
                                        @:Reindex Documents
                                    }
                                </MudButton>
                            </MudItem>
                        }
                    </MudGrid>
                }

                @if (ProcessId != null && _isEditMode)
                {
                    <MudSpacer />

                    <MudGrid Spacing="2" Class="mt-2 mb-2">
                        <MudItem>
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" StartIcon="@Icons.Material.Filled.Edit" OnClick="OpenDocumentOutlineEditor">Document Outline Editor</MudButton>
                        </MudItem>
                        <MudItem>
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" StartIcon="@Icons.Material.Filled.Settings" OnClick="OpenMetadataFieldEditor">Metadata Fields Editor</MudButton>
                        </MudItem>
                    </MudGrid>

                }
                <MudSpacer />

                <MudGrid Spacing="2" Class="mt-2 mb-2">
                    <MudItem>
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveProcess" Style="min-width:150px" Disabled="_isSaving">
                            @if (_isSaving)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="me-2" />
                                @:Saving...
                            }
                            else
                            {
                                @:Save
                            }
                        </MudButton>
                    </MudItem>
                    <MudItem>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="Cancel" Style="min-width:150px">Cancel</MudButton>
                    </MudItem>
                    @if (ProcessId != null)
                    {
                        <MudItem>
                            <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="ConfirmDeleteProcess" Style="min-width:150px">Delete Process</MudButton>
                        </MudItem>
                    }
                </MudGrid>

            </MudItem>

            <MudItem xs="12" md="6">
                <MudGrid Spacing="3">
                    <MudItem xs="12">
                        <MudText Typo="Typo.subtitle2" Class="mb-2">Document Retrieval Settings</MudText>
                    </MudItem>

                    <MudItem xs="12">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudSlider T="int" @bind-Value="_process.PrecedingSearchPartitionInclusionCount" Min="0" Max="10" TickMarks="true" ValueLabel="true" Immediate="true">
                                # of Preceding Partitions to retrieve
                            </MudSlider>
                            <MudNumericField @bind-Value="_process.PrecedingSearchPartitionInclusionCount" Min="0" Max="10" Immediate="true" Style="width:80px;" />
                        </MudStack>
                    </MudItem>

                    <MudItem xs="12">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudSlider T="int" @bind-Value="_process.FollowingSearchPartitionInclusionCount" Min="0" Max="10" TickMarks="true" ValueLabel="true" Immediate="true">
                                # of Following Partitions to retrieve
                            </MudSlider>
                            <MudNumericField @bind-Value="_process.FollowingSearchPartitionInclusionCount" Min="0" Max="10" Immediate="true" Style="width:80px;" />
                        </MudStack>
                    </MudItem>

                    <MudItem xs="12">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudSlider T="int" @bind-Value="_process.NumberOfCitationsToGetFromRepository" Min="0" Max="100" TickMarks="false" ValueLabel="true" Immediate="true">
                                # Number of Citations to retrieve
                            </MudSlider>
                            <MudNumericField @bind-Value="_process.NumberOfCitationsToGetFromRepository" Min="0" Max="100" Immediate="true" Style="width:80px;" />
                        </MudStack>
                    </MudItem>

                    <MudItem xs="12" Class="mb-4">
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                            <MudSlider T="double" @bind-Value="_minimumRelevancePercentage" Min="0" Max="100" Step="10" TickMarks="true" TickMarkLabels="@_minimumRelevanceStepLabels" ValueLabel="true" Immediate="true">
                                Minimum Relevance (%)
                            </MudSlider>
                            <MudNumericField @bind-Value="_minimumRelevancePercentage" Min="0" Max="100" Step="10" Immediate="true" Style="width:80px;" />
                        </MudStack>
                    </MudItem>

                    @if (_isEditMode)
                    {
                        <MudItem xs="12">
                            <MudDivider Class="my-3" />
                            <MudText Typo="Typo.subtitle2" Class="mb-2">Validation Pipeline Settings</MudText>
                            <ValidationStepsEditorComponent Steps="@_validationSteps"
                                                            StepsChanged="@HandleValidationStepsChanged"
                                                            RunValidationAutomatically="@_runValidationAutomatically"
                                                            RunValidationAutomaticallyChanged="@HandleRunValidationAutomaticallyChanged" />
                        </MudItem>
                    }
                </MudGrid>
            </MudItem>
        </MudGrid>
    </MudPaper>


    <!-- Place this after the main form MudPaper -->
    @if (_isEditMode)
    {
        <MudDivider Class="mt-5 mb-4" />

        <MudPaper Class="pa-6">
            <MudTabs Elevation="4" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-4">
                <MudTabPanel Text="Document Libraries">
                    <MudText Typo="Typo.h6">Associated Document Libraries</MudText>

                    <MudTable T="DocumentLibraryInfo" Items="@_associatedLibraries" Hover="true">
                        <HeaderContent>
                            <MudTh>Library Name</MudTh>
                            <MudTh>Description</MudTh>
                            <MudTh>Actions</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd>@context.ShortName</MudTd>
                            <MudTd>@context.DescriptionOfContents</MudTd>
                            <MudTd>
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="() => ConfirmDisassociateLibrary(context.Id)" />
                            </MudTd>
                        </RowTemplate>
                    </MudTable>

                    <MudButton Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.Add" OnClick="ShowAssociateLibraryDialog" Class="mt-4">Associate Document Library</MudButton>
                </MudTabPanel>

                <MudTabPanel Text="Plugins">
                    <PluginDocumentProcessAssociationManager DocumentProcessId="@ProcessId"
                                                             PluginCentric="false"
                                                             Title="Associated Plugins"
                                                             SelectionColumnLabel="Plugin"
                                                             OnAssociationChanged="HandleAssociationChanged" />
                </MudTabPanel>

                <MudTabPanel Text="Prompts">
                    @if (_showPrompts)
                    {
                        <PromptList Prompts="@_prompts" />
                    }
                    else
                    {
                        <MudProgressCircular Indeterminate="true" />
                    }
                </MudTabPanel>
            </MudTabs>
        </MudPaper>
    }
}


@code {
    [Parameter] public Guid? ProcessId { get; set; }
    [Parameter] public EventCallback OnProcessSaved { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }

    // Initialized immediately; treated as non-null after OnInitializedAsync
    private DocumentProcessInfo _process = new();
    private List<PromptInfo> _prompts = [];

    // Completion service selection backing field
    private DocumentProcessCompletionServiceType _completionServiceType = DocumentProcessCompletionServiceType.GenericAiCompletionService;

    // Validation pipeline-related fields
    private List<DocumentProcessValidationPipelineStepInfo> _validationSteps = [];
    private DocumentProcessValidationPipelineInfo? _validationPipeline;
    private bool _runValidationAutomatically = true;

    // Plugin-related fields
    private List<McpPluginInfo> _availablePlugins = new();
    private List<PluginAssociationViewModel> _associatedPlugins = new();

    // Document Library-related fields
    private List<DocumentLibraryInfo> _associatedLibraries = new();
    private List<DocumentLibraryInfo> _availableLibraries = new();
    private List<AiModelDeploymentInfo> _aiModelDeployments = new();

    private bool _isEditMode;
    private bool _showPrompts;

    // Add loading state
    private bool _isLoading = true;
    private bool _isSaving = false;
    private bool _isUploadingFiles = false;

    private readonly string[] _minimumRelevanceStepLabels = Enumerable.Range(0, 11).Select(i => $"{i * 10}%").ToArray();

    private string _indexName = string.Empty;
    private double _minimumRelevancePercentage
    {
        get => _process?.MinimumRelevanceForCitations * 100 ?? 0;
        set
        {
            if (_process != null)
            {
                _process.MinimumRelevanceForCitations = value / 100;
            }
        }
    }

    // Reindex status state
    private string ProcessOrchestrationId => string.IsNullOrWhiteSpace(_process?.ShortName) ? string.Empty : $"process-{_process.ShortName}";
    private DocumentReindexStateInfo? _processReindexStatus;
    private bool _sawProcessRunThisSession; // true after a Running/Progress event this session

    // SignalR management
    private HubConnection? _hubConnection;
    private SignalRSubscriptionManager? _subMgr;

    private bool ShouldShowProcessBanner => _processReindexStatus is not null && (
        _processReindexStatus.Status == ReindexOrchestrationState.Running ||
        (_processReindexStatus.Status == ReindexOrchestrationState.Completed && _sawProcessRunThisSession)
    );

    // New fields to track initial embedding model and dimensions
    private Guid? _initialEmbeddingModelDeploymentId;
    private int? _initialEmbeddingDimensionsOverride;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load AI Model Deployments
            _aiModelDeployments = await ConfigurationApiClient.GetAiModelDeploymentsAsync();

            if (ProcessId.HasValue)
            {
                _isEditMode = true;
                _process = await DocumentProcessApiClient.GetDocumentProcessInfoByIdAsync(ProcessId.Value) ?? new DocumentProcessInfo();
                _initialEmbeddingModelDeploymentId = _process.EmbeddingModelDeploymentId;
                _initialEmbeddingDimensionsOverride = _process.EmbeddingDimensionsOverride;

                // Default completion service type if missing
                _completionServiceType = _process.CompletionServiceType ?? DocumentProcessCompletionServiceType.GenericAiCompletionService;
                _process.CompletionServiceType ??= _completionServiceType;

                // If no embedding deployment has been set yet, default to the first embedding deployment
                if (_process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore && _process.EmbeddingModelDeploymentId == null)
                {
                    var defaultEmbedding = _aiModelDeployments.FirstOrDefault(d => d.AiModel?.ModelType == AiModelType.Embedding);
                    if (defaultEmbedding != null)
                    {
                        _process.EmbeddingModelDeploymentId = defaultEmbedding.Id;
                    }
                }

                // Initialize _indexName with the existing repository value
                if (_process.Repositories != null && _process.Repositories.Any())
                {
                    _indexName = _process.Repositories.First();
                }
                else
                {
                    _indexName = string.Empty;
                }

                // Load associated plugins - use try/catch to avoid failures if the plugin API returns errors
                try
                {
                    await LoadAssociatedPlugins();

                    // Load available plugins
                    _availablePlugins = await PluginApiClient.GetAllMcpPluginsAsync() ?? new List<McpPluginInfo>();
                }
                catch (Exception ex)
                {
                    _availablePlugins = new List<McpPluginInfo>();
                    _associatedPlugins = new List<PluginAssociationViewModel>();
                    Console.WriteLine($"Error loading plugins: {ex.Message}");
                    SnackBar.Add($"Error loading plugins: {ex.Message}", Severity.Warning);
                }

                try
                {
                    // Load associated document libraries
                    await LoadAssociatedLibraries();

                    // Load available document libraries
                    await LoadAvailableLibraries();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading document libraries: {ex.Message}");
                    SnackBar.Add($"Error loading document libraries: {ex.Message}", Severity.Warning);
                }

                try
                {
                    // Load prompts
                    await LoadPrompts();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading prompts: {ex.Message}");
                    SnackBar.Add($"Error loading prompts: {ex.Message}", Severity.Warning);
                }

                try
                {
                    // Load validation pipeline
                    await LoadValidationPipelines();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading validation pipeline: {ex.Message}");
                    SnackBar.Add($"Error loading validation pipeline: {ex.Message}", Severity.Warning);
                }

                // Refresh reindexing statuses
                await RefreshReindexStatusesAsync();
                await InitializeSignalRAsync();
            }
            else
            {
                // New document process defaults
                SelectedDeployment = _aiModelDeployments.FirstOrDefault(x => x.DeploymentName == "gpt-4o");
                SelectedValidationDeployment = _aiModelDeployments.FirstOrDefault(x => x.DeploymentName == "gpt-4o");
                // Default repository logic type: Semantic Kernel Vector Store (migrated away from Kernel Memory)
                _process.LogicType = DocumentProcessLogicType.SemanticKernelVectorStore;

                // Default completion service is Generic
                _completionServiceType = DocumentProcessCompletionServiceType.GenericAiCompletionService;
                _process.CompletionServiceType = _completionServiceType;

                // Default embedding deployment for new processes
                var defaultEmbedding = _aiModelDeployments.FirstOrDefault(d => d.AiModel?.ModelType == AiModelType.Embedding);
                if (defaultEmbedding != null)
                {
                    _process.EmbeddingModelDeploymentId = defaultEmbedding.Id;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing document process edit component: {ex.Message}");
            SnackBar.Add($"Error loading document process: {ex.Message}", Severity.Error);
        }
        finally
        {
            // Always set loading to false when done, even if there's an error
            _isLoading = false;
        }
    }

    private async Task InitializeSignalRAsync()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(ProcessOrchestrationId))
            {
                return;
            }

            _hubConnection ??= await SignalRConnectionService.GetOrCreateAsync();
            _subMgr ??= SignalRSubscriptionFactory.Create(_hubConnection);

            _subMgr.RegisterHandlerOnce<DocumentReindexStartedNotification>("ReceiveDocumentReindexStartedNotification", async n =>
            {
                if (n.OrchestrationId == ProcessOrchestrationId)
                {
                    _sawProcessRunThisSession = true;
                    await RefreshReindexStatusesAsync();
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexProgressNotification>("ReceiveDocumentReindexProgressNotification", async n =>
            {
                if (n.OrchestrationId == ProcessOrchestrationId)
                {
                    _sawProcessRunThisSession = true;
                    _processReindexStatus ??= new DocumentReindexStateInfo();
                    _processReindexStatus.Status = ReindexOrchestrationState.Running;
                    _processReindexStatus.TotalDocuments = n.TotalDocuments;
                    _processReindexStatus.ProcessedDocuments = n.ProcessedDocuments;
                    _processReindexStatus.FailedDocuments = n.FailedDocuments;
                    await InvokeAsync(StateHasChanged);
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexCompletedNotification>("ReceiveDocumentReindexCompletedNotification", async n =>
            {
                if (n.OrchestrationId == ProcessOrchestrationId)
                {
                    _processReindexStatus ??= new DocumentReindexStateInfo();
                    _processReindexStatus.Status = ReindexOrchestrationState.Completed;
                    _processReindexStatus.TotalDocuments = n.TotalDocuments;
                    _processReindexStatus.ProcessedDocuments = n.ProcessedDocuments;
                    _processReindexStatus.FailedDocuments = n.FailedDocuments;
                    await InvokeAsync(StateHasChanged);
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexFailedNotification>("ReceiveDocumentReindexFailedNotification", async n =>
            {
                if (n.OrchestrationId == ProcessOrchestrationId)
                {
                    _processReindexStatus ??= new DocumentReindexStateInfo();
                    _processReindexStatus.Status = ReindexOrchestrationState.Failed;
                    await InvokeAsync(StateHasChanged);
                }
            });

            await _subMgr.EnsureConnectedAsync();
            await _subMgr.JoinGroupAsync(ProcessOrchestrationId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR init failed: {ex.Message}");
        }
    }

    private async Task OpenVectorSearchDialog()
    {
        if (!_isEditMode)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            ["IsLibraryScope"] = false,
            ["ScopeShortName"] = _process.ShortName
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Large, FullWidth = true };
        await DialogService.ShowAsync<VectorStoreSearchDialog>("Search Vector Store", parameters, options);
    }

    private Color GetStatusColor(ReindexOrchestrationState status) => status switch
    {
        ReindexOrchestrationState.Running => Color.Info,
        ReindexOrchestrationState.Completed => Color.Success,
        ReindexOrchestrationState.Failed => Color.Error,
        _ => Color.Default
    };

    private async Task RefreshReindexStatusesAsync()
    {
        try
        {
            _processReindexStatus = null;

            if (!string.IsNullOrWhiteSpace(ProcessOrchestrationId))
            {
                _processReindexStatus = await DocumentReindexApiClient.GetReindexingStatusAsync(ProcessOrchestrationId);
                if (_processReindexStatus?.Status == ReindexOrchestrationState.Running)
                {
                    _sawProcessRunThisSession = true;
                }
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing reindex statuses: {ex.Message}");
        }
    }

    private async Task OpenProcessReindexProgress()
    {
        if (string.IsNullOrWhiteSpace(ProcessOrchestrationId))
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "OrchestrationId", ProcessOrchestrationId },
            { "TargetName", _process.ShortName },
            { "Reason", _processReindexStatus?.Reason ?? "" }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    // Intermediate property for binding the selected deployment.
    private AiModelDeploymentInfo? SelectedDeployment
    {
        get
        {
            // Return the deployment that matches the currently selected ID (if any).
            return _aiModelDeployments.FirstOrDefault(d => d.Id == _process.AiModelDeploymentId);
        }
        set
        {
            if (value is not null)
            {
                _process.AiModelDeploymentId = value.Id;
            }
            else
            {
                _process.AiModelDeploymentId = null;
            }
        }
    }

    // Intermediate property for binding the selected validation deployment.
    private AiModelDeploymentInfo? SelectedValidationDeployment
    {
        get
        {
            // Return the deployment that matches the currently selected validation ID (if any).
            return _aiModelDeployments.FirstOrDefault(d => d.Id == _process.AiModelDeploymentForValidationId);
        }
        set
        {
            if (value is not null)
            {
                _process.AiModelDeploymentForValidationId = value.Id;
            }
            else
            {
                _process.AiModelDeploymentForValidationId = null;
            }
        }
    }

    // Intermediate property for binding the selected embedding deployment.
    private AiModelDeploymentInfo? SelectedEmbeddingDeployment
    {
        get => _aiModelDeployments.FirstOrDefault(d => d.Id == _process.EmbeddingModelDeploymentId);
        set => _process.EmbeddingModelDeploymentId = value?.Id;
    }

    private async Task HandleFileSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files == null || files.Count == 0)
        {
            SnackBar.Add("No files selected for upload.", Severity.Warning);
            return;
        }

        _isUploadingFiles = true;
        StateHasChanged();

        try
        {
            foreach (var file in files)
            {
                try
                {
                    // Use the FileApiClient method for document process uploads
                    var result = await FileApiClient.UploadFileToDocumentProcessAsync(_process.ShortName, file.Name, file);
                    SnackBar.Add($"File '{file.Name}' uploaded successfully.", Severity.Success);
                }
                catch (Exception ex)
                {
                    SnackBar.Add($"Error uploading file '{file.Name}': {ex.Message}", Severity.Error);
                }
            }
        }
        finally
        {
            _isUploadingFiles = false;
            StateHasChanged();
        }
    }

    private void HandleValidationStepsChanged(List<DocumentProcessValidationPipelineStepInfo> steps)
    {
        _validationSteps = steps;
    }

    private void HandleRunValidationAutomaticallyChanged(bool value)
    {
        _runValidationAutomatically = value;
        // No need to save immediately - will be saved when the form is submitted
    }

    private async Task LoadAssociatedLibraries()
    {
        if (_process == null)
        {
            return;
        }

        _associatedLibraries = await DocumentLibraryApiClient.GetDocumentLibrariesByProcessIdAsync(_process.Id);
    }

    private async Task LoadAvailableLibraries()
    {
        var allLibraries = await DocumentLibraryApiClient.GetAllDocumentLibrariesAsync();
        _availableLibraries = allLibraries.Where(l => !_associatedLibraries.Any(al => al.Id == l.Id)).ToList();
    }

    private async Task LoadPrompts()
    {
        _prompts = await DocumentProcessApiClient.GetPromptsByProcessIdAsync(_process.Id);
        _showPrompts = true;
    }

    private async Task LoadValidationPipelines()
    {
        if (ProcessId.HasValue)
        {
            _validationPipeline = await DocumentProcessApiClient.GetValidationPipelineAsync(ProcessId.Value);
        }
        if (_validationPipeline != null)
        {
            _validationSteps = _validationPipeline.ValidationPipelineSteps;
            _runValidationAutomatically = _validationPipeline.RunValidationAutomatically;
        }
    }

    private async Task LoadAssociatedPlugins()
    {
        try
        {
            // Get associated plugins from the API
            var associatedPluginInfos = await PluginApiClient.GetMcpPluginsByDocumentProcessIdAsync(_process.Id);

            // Map to PluginAssociation objects
            _associatedPlugins = (associatedPluginInfos ?? new List<McpPluginInfo>()).Select(p =>
            {
                var docProcess = p.DocumentProcesses?.FirstOrDefault(dp => dp.DocumentProcessId == _process.Id);
                var version = docProcess?.Version;
                var versionString = version != null ? $"{version.Major}.{version.Minor}.{version.Patch}" :
                    p.LatestVersion != null ? $"{p.LatestVersion.Major}.{p.LatestVersion.Minor}.{p.LatestVersion.Patch}" : "1.0.0";

                return new PluginAssociationViewModel
                {
                    Plugin = p,
                    Version = versionString
                };

            }).ToList();
        }
        catch (Exception ex)
        {
            // Log the error, but don't crash
            Console.WriteLine($"Error loading associated plugins: {ex.Message}");
            _associatedPlugins = new List<PluginAssociationViewModel>();
            SnackBar.Add($"Error loading plugins: {ex.Message}", Severity.Warning);
        }
    }

    private async Task SaveProcess()
    {
        _isSaving = true;
        StateHasChanged();

        try
        {
            ValidateAndFormatShortName();
            UpdateRepositories();

            // Write selected completion service back to the process model
            _process.CompletionServiceType = _completionServiceType;

            if (!await ConfirmReindexIfEmbeddingChangedAsync())
            {
                return;
            }

            // For new processes, check if a FileStorageSource already exists with this container name
            if (!_isEditMode)
            {
                if (!await ValidateContainerNameIsUniqueAsync(_process.BlobStorageContainerName))
                {
                    return;
                }
            }

            if (_isEditMode && _process != null)
            {
                // Handle validation pipeline
                if (_validationSteps.Any())
                {
                    var pipelineInfo = _validationPipeline ?? new DocumentProcessValidationPipelineInfo
                    {
                        DocumentProcessId = _process.Id
                    };

                    pipelineInfo.ValidationPipelineSteps = _validationSteps;
                    pipelineInfo.RunValidationAutomatically = _runValidationAutomatically;
                    await DocumentProcessApiClient.SaveValidationPipelineAsync(_process.Id, pipelineInfo);
                }
                else if (_validationPipeline != null)
                {
                    // Delete the validation pipeline if it exists but there are no steps
                    await DocumentProcessApiClient.DeleteValidationPipelineAsync(_process.Id);
                    _validationPipeline = null;
                }

                // Ensure embedding settings are only applied for SemanticKernelVectorStore
                if (_process.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
                {
                    _process.EmbeddingModelDeploymentId = null;
                    _process.EmbeddingDimensionsOverride = null;
                }

                await DocumentProcessApiClient.UpdateDynamicDocumentProcessDefinitionAsync(_process);
                SnackBar.Add("Document process updated successfully.", Severity.Success);

                if (_process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore && EmbeddingConfigChangedForProcess())
                {
                    await StartImmediateProcessReindexAsync("Embedding model/dimensions changed");
                }

                _initialEmbeddingModelDeploymentId = _process.EmbeddingModelDeploymentId;
                _initialEmbeddingDimensionsOverride = _process.EmbeddingDimensionsOverride;
            }
            else
            {
                // Create new document process
                // Note: The backend service automatically creates a FileStorageSource association during creation (DocumentProcessInfoService.cs:201)
                var createdProcess = await DocumentProcessApiClient.CreateDynamicDocumentProcessDefinitionAsync(_process);
                if (createdProcess != null)
                {
                    _process = createdProcess;
                    _isEditMode = true;

                    // Save validation pipeline if there are steps
                    if (_validationSteps.Any())
                    {
                        var pipelineInfo = new DocumentProcessValidationPipelineInfo
                        {
                            DocumentProcessId = _process.Id,
                            ValidationPipelineSteps = _validationSteps,
                            RunValidationAutomatically = _runValidationAutomatically
                        };

                        _validationPipeline = await DocumentProcessApiClient.SaveValidationPipelineAsync(_process.Id, pipelineInfo);
                    }

                    // Load associated plugins and libraries
                    await LoadAssociatedPlugins();
                    await LoadAssociatedLibraries();
                    await LoadAvailableLibraries();
                    await LoadValidationPipelines();

                    // Load prompts
                    await LoadPrompts();

                    SnackBar.Add("Document process created successfully.", Severity.Success);

                    // Navigate back to list for new process creation
                    await OnProcessSaved.InvokeAsync();
                }
            }

            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            _isSaving = false;
            StateHasChanged();
        }
    }

    private async Task HandleMigrateLegacyStorage()
    {
        if (!_isEditMode || ProcessId == null || string.IsNullOrEmpty(_process.BlobStorageContainerName))
        {
            return;
        }

        try
        {
            await EnsureDefaultFileStorageSourceForProcessAsync(
                ProcessId.Value,
                _process.BlobStorageContainerName,
                _process.BlobStorageAutoImportFolderName ?? "ingest-auto");

            SnackBar.Add("Legacy storage configuration migrated successfully.", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            SnackBar.Add($"Failed to migrate legacy storage: {ex.Message}", Severity.Error);
        }
    }

    private async Task EnsureDefaultFileStorageSourceForProcessAsync(Guid processId, string containerOrPath, string autoImportFolder)
    {
        var hosts = await FileStorageHostApiClient.GetAllFileStorageHostsAsync();
        var defaultHost = hosts.FirstOrDefault(h => h.IsDefault && h.IsActive);
        if (defaultHost == null) { throw new InvalidOperationException("No default FileStorageHost configured."); }

        // Try to find existing source on default host
        var allSources = await FileStorageSourceApiClient.GetAllFileStorageSourcesAsync();
        var existing = allSources.FirstOrDefault(s => s.FileStorageHostId == defaultHost.Id && string.Equals(s.ContainerOrPath, containerOrPath, StringComparison.OrdinalIgnoreCase));
        if (existing == null)
        {
            var createReq = new CreateFileStorageSourceRequest
            {
                Name = $"Default - {_process.ShortName}",
                FileStorageHostId = defaultHost.Id,
                ContainerOrPath = containerOrPath,
                AutoImportFolderName = string.IsNullOrWhiteSpace(autoImportFolder) ? "ingest-auto" : autoImportFolder,
                IsDefault = false,
                IsActive = true,
                ShouldMoveFiles = true,
                Description = $"Auto-created for process {_process.ShortName}",
                StorageSourceDataTypes = new List<FileStorageSourceDataType> { FileStorageSourceDataType.Ingestion }
            };
            existing = await FileStorageSourceApiClient.CreateFileStorageSourceAsync(createReq);
        }

        // Associate and make it the upload source
        await FileStorageSourceApiClient.AssociateSourceWithProcessAsync(processId, existing.Id);
        await FileStorageSourceApiClient.UpdateProcessSourceAssociationAsync(processId, existing.Id, new UpdateProcessSourceAssociationRequest
        {
            AcceptsUploads = true,
            IsActive = true,
            Priority = 1
        });
    }

    private async Task Cancel()
    {
        await OnCancel.InvokeAsync();
    }

    private void OpenDocumentOutlineEditor()
    {
        var parameters = new DialogParameters
        {
            { "DocumentOutlineId", _process.DocumentOutlineId }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };
        DialogService.Show<EditDocumentOutlineDialog>("Document Outline Editor", parameters, options);
    }

    private async Task OpenMetadataFieldEditor()
    {
        var parameters = new DialogParameters
        {
            { "DocumentProcessId", _process.Id },
            { "DocumentProcessName", _process.ShortName}
        };
        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraLarge, FullWidth = true, BackdropClick = false };
        var dialog = await DialogService.ShowAsync<EditMetadataFieldsDialog>("Metadata Fields Editor", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            //_process.MetadataFields = result.Data;
        }
    }

    private void ValidateAndFormatShortName()
    {
        if (string.IsNullOrWhiteSpace(_process.ShortName))
        {
            SnackBar.Add("Short Name cannot be empty.", Severity.Error);
            return;
        }

        // Replace spaces with periods
        _process.ShortName = _process.ShortName.Replace(" ", ".");

        // Remove any characters that are not letters, digits, or periods
        _process.ShortName = new string(_process.ShortName.Where(c => char.IsLetterOrDigit(c) || c == '.').ToArray());

        if (string.IsNullOrWhiteSpace(_process.ShortName))
        {
            SnackBar.Add("Short Name must contain valid characters.", Severity.Error);
            return;
        }

        ComputeIndexAndBlobStorageContainerName();
    }

    private void ComputeIndexAndBlobStorageContainerName()
    {
        if (!_isEditMode && string.IsNullOrWhiteSpace(_indexName))
        {
            _indexName = "index-" + _process.ShortName.ToLower()
                                            .Replace(" ", "-")
                                            .Replace(".", "-");
        }

        if (!_isEditMode && string.IsNullOrWhiteSpace(_process.BlobStorageContainerName))
        {
            _process.BlobStorageContainerName = "blob-" + _process.ShortName.ToLower()
                                            .Replace(" ", "-")
                                            .Replace(".", "-");
        }
    }

    private void UpdateRepositories()
    {
        _process.Repositories ??= new List<string>();
        _process.Repositories.Clear();
        _process.Repositories.Add(_indexName);
    }

    // Document Library Association Methods
    private void ShowAssociateLibraryDialog()
    {
        var parameters = new DialogParameters
        {
            { "AvailableLibraries", _availableLibraries },
            { "DocumentProcessId", _process.Id }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<AssociateDocumentLibraryWithDocumentProcessDialog>("Associate Document Library", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await LoadAssociatedLibraries();
                await LoadAvailableLibraries();
                // refresh reindex status when libraries change
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private void ConfirmDisassociateLibrary(Guid libraryId)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", "Are you sure you want to disassociate this document library?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Disassociate Document Library", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await DisassociateLibrary(libraryId);
                // refresh reindex status when libraries change
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private async Task DisassociateLibrary(Guid libraryId)
    {
        if (_process == null)
        {
            return;
        }

        try
        {
            await DocumentLibraryApiClient.DisassociateDocumentProcessAsync(libraryId, _process.Id);
            SnackBar.Add("Document library disassociated successfully.", Severity.Success);

            await LoadAssociatedLibraries();
            await LoadAvailableLibraries();
        }
        catch (Exception ex)
        {
            SnackBar.Add($"Error disassociating document library: {ex.Message}", Severity.Error);
        }
    }

    // Plugin-related methods
    private async Task HandleAssociationChanged()
    {
        // Refresh associated plugins
        await LoadAssociatedPlugins();
        StateHasChanged();
    }

    private async Task ShowReindexDialog()
    {
        if (!_isEditMode || _process.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", _process.ShortName },
            { "IsDocumentProcess", true },
            { "Reason", "Manual reindexing" },
            { "WarningMessage", "This will delete and rebuild the process repository index." }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Documents", parameters, options);
    }

    // Helper class for plugin associations
    private class PluginAssociationViewModel
    {
        public McpPluginInfo Plugin { get; set; } = new();
        public String Version { get; set; } = string.Empty;
    }

    private bool EmbeddingConfigChangedForProcess()
    {
        return _initialEmbeddingModelDeploymentId != _process.EmbeddingModelDeploymentId
            || _initialEmbeddingDimensionsOverride != _process.EmbeddingDimensionsOverride;
    }

    private async Task<bool> ConfirmReindexIfEmbeddingChangedAsync()
    {
        if (!_isEditMode || _process.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            return true;
        }
        if (!EmbeddingConfigChangedForProcess())
        {
            return true;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", _process.ShortName },
            { "IsDocumentProcess", true },
            { "Reason", "Embedding model/dimensions changed" },
            { "WarningMessage", "Changing the embedding model or dimensions requires deleting and rebuilding the process repository index. Proceed?" }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Required", parameters, options);
        var result = await dialog.Result;
        return !result.Canceled;
    }

    private async Task StartImmediateProcessReindexAsync(string reason)
    {
        try
        {
            var orchestrationId = await DocumentReindexApiClient.StartDocumentProcessReindexingAsync(_process.ShortName, reason);

            var parameters = new DialogParameters
            {
                { "OrchestrationId", orchestrationId },
                { "TargetName", _process.ShortName },
                { "Reason", reason }
            };
            var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
            await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);

            await RefreshReindexStatusesAsync();
        }
        catch (Exception ex)
        {
            SnackBar.Add($"Failed to start reindex: {ex.Message}", Severity.Error);
        }
    }

    private async Task ConfirmDeleteProcess()
    {
        if (ProcessId == null)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "ContentText", $"Are you sure you want to delete the document process '{_process.ShortName}'? This deletes the vector index/collection (if SK), its blob container and all ingested document records." },
            { "ButtonText", "Delete" },
            { "DialogColor", Color.Error }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<ConfirmationDialog>("Delete Document Process", parameters, options);
        var result = await dialog.Result;
        if (!result.Canceled)
        {
            try
            {
                var ok = await DocumentProcessApiClient.DeleteDocumentProcessAsync(ProcessId.Value);
                if (ok)
                {
                    SnackBar.Add("Document process deleted.", Severity.Success);
                    await OnProcessSaved.InvokeAsync();
                }
                else
                {
                    SnackBar.Add("Delete failed.", Severity.Error);
                }
            }
            catch (Exception ex)
            {
                SnackBar.Add($"Failed to delete process: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task<bool> ValidateContainerNameIsUniqueAsync(string containerName)
    {
        if (string.IsNullOrWhiteSpace(containerName))
        {
            return true; // Will be caught by other validation
        }

        try
        {
            var hosts = await FileStorageHostApiClient.GetAllFileStorageHostsAsync();
            var defaultHost = hosts.FirstOrDefault(h => h.IsDefault && h.IsActive);
            if (defaultHost == null)
            {
                // No default host - can't check, but backend will handle this
                return true;
            }

            var allSources = await FileStorageSourceApiClient.GetAllFileStorageSourcesAsync();
            var existing = allSources.FirstOrDefault(s =>
                s.FileStorageHostId == defaultHost.Id &&
                string.Equals(s.ContainerOrPath, containerName, StringComparison.OrdinalIgnoreCase));

            if (existing != null)
            {
                SnackBar.Add($"A file storage source already exists with container name '{containerName}' on the default host. Please choose a different short name.", Severity.Error);
                return false;
            }

            return true;
        }
        catch (Exception ex)
        {
            SnackBar.Add($"Failed to validate container name: {ex.Message}", Severity.Warning);
            return true; // Allow save to proceed, backend will handle validation
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_subMgr != null)
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(ProcessOrchestrationId))
                {
                    await _subMgr.LeaveGroupAsync(ProcessOrchestrationId);
                }
            }
            catch { }
            await _subMgr.DisposeAsync();
        }
    }

    private async Task OpenExportDialog()
    {
        if (!_isEditMode || ProcessId is null) { return; }
        var parameters = new DialogParameters
        {
            ["ProcessId"] = ProcessId.Value,
            ["SuggestedFileName"] = $"process-{_process.ShortName}.json"
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<ExportDefinitionDialog>("Export Definition", parameters, options);
    }
}
