@using System.Net
@using Microsoft.Greenlight.Shared.Contracts.DTO.Configuration
@using Microsoft.Greenlight.Shared.Enums
@using Microsoft.Greenlight.Shared.Contracts.DTO
@using Microsoft.Greenlight.Web.Shared.ServiceClients
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject IDocumentLibraryApiClient DocumentLibraryApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject IFileApiClient FileApiClient
@inject IPluginApiClient PluginApiClient
@inject IDocumentReindexApiClient DocumentReindexApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    @if (_isLoading)
    {
        <!-- Loading indicator displayed during initialization -->
        <MudPaper Class="pa-6 d-flex flex-column align-center justify-center" Style="min-height: 300px;">
            <MudProgressCircular Size="Size.Large" Indeterminate="true" Color="Color.Primary" Class="mb-4" />
            <MudText Typo="Typo.h5" Align="Align.Center">Loading Document Process details...</MudText>
        </MudPaper>
    }
    else
    {
        <MudPaper Class="pa-4">
            <MudGrid>
                <MudItem xs="12">
                    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                        <MudText Typo="Typo.h6">Basic Information</MudText>
                        <MudText Typo="Typo.body2" Class="text-right">
                            <strong>Logic Type:</strong> @_process.LogicType.ToString()
                        </MudText>
                    </MudStack>
                </MudItem>
            </MudGrid>

            <!-- Inline Reindex Status -->
            @if (_isEditMode)
            {
                <MudGrid Class="mb-2">
                    <MudItem xs="12">
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                            <MudText Typo="Typo.subtitle2">Reindexing Status:</MudText>

                            @if (_processReindexStatus != null)
                            {
                                <MudChip Color="@GetStatusColor(_processReindexStatus.Status)" Variant="Variant.Filled">
                                    Process: @_processReindexStatus.Status.ToString() (@_processReindexStatus.ProcessedDocuments/@_processReindexStatus.TotalDocuments)
                                </MudChip>
                                <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="OpenProcessReindexProgress">View details</MudButton>
                            }
                            else
                            {
                                <MudChip Color="Color.Default" Variant="Variant.Outlined">No active reindex for process</MudChip>
                            }

                            @if (_libraryReindexStatuses.Any())
                            {
                                <MudDivider Vertical="true" Class="mx-2" />
                                @foreach (var kvp in _libraryReindexStatuses)
                                {
                                    <MudChip Color="@GetStatusColor(kvp.Value.Status)" Variant="Variant.Filled" Class="mr-1">
                                        Library @kvp.Key: @kvp.Value.Status.ToString() (@kvp.Value.ProcessedDocuments/@kvp.Value.TotalDocuments)
                                    </MudChip>
                                    <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="() => OpenLibraryReindexProgress(kvp.Key)">View</MudButton>
                                }
                            }
                            <MudSpacer />
                            <MudIconButton Icon="@Icons.Material.Filled.Refresh" Title="Refresh reindex status" OnClick="RefreshReindexStatusesAsync" />
                        </MudStack>
                    </MudItem>
                </MudGrid>
            }
            
            <MudGrid>
                <MudItem xs="12" md="6">
                    <MudTextField @bind-Value="_process.ShortName" Label="Short Name" Disabled="_isEditMode" OnBlur="ValidateAndFormatShortName" />
                    <MudTextField @bind-Value="_process.Description" Label="Description" />
                    <MudTextField @bind-Value="_process.BlobStorageContainerName" Label="Blob Storage Container Name" />
                    <MudTextField @bind-Value="_process.BlobStorageAutoImportFolderName" Label="Auto Import Folder Name" />
                    <MudTextField @bind-Value="_indexName"
                                  Label="Repository Index Name"
                                  Disabled="_isEditMode"
                                  OnInternalInputChanged="UpdateRepositories" />
                    @if (_process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                    {
                        <MudSelect T="TextChunkingMode?" @bind-Value="_process.VectorStoreChunkingMode" Label="Chunking Mode">
                            @foreach (var mode in Enum.GetValues<TextChunkingMode>())
                            {
                                <MudSelectItem Value="@(mode as TextChunkingMode?)">@mode.ToString()</MudSelectItem>
                            }
                        </MudSelect>
                        
                        <MudNumericField T="int?" @bind-Value="_process.VectorStoreChunkSize" 
                                       Label="Chunk Size (tokens)" 
                                       HelperText="Number of tokens per chunk. Leave empty to use global default."
                                       Min="100" Max="8000" />
                        
                        <MudNumericField T="int?" @bind-Value="_process.VectorStoreChunkOverlap" 
                                       Label="Chunk Overlap (tokens)" 
                                       HelperText="Number of overlapping tokens between chunks. Leave empty to use global default."
                                       Min="0" Max="2000" />
                                        
                        <MudAlert Severity="Severity.Info" Class="mt-2">
                            <strong>Note:</strong> Changing chunk size or overlap will only apply to newly ingested documents. 
                            Existing documents in the index will retain their original chunking. 
                            You can reindex existing documents to apply new chunk settings.
                        </MudAlert>
                    }
                    <MudSelect T="DocumentProcessCompletionServiceType ?" @bind-Value="_process.CompletionServiceType" Label="AI Completion Service Type">
                        @foreach (var completionType in Enum.GetValues<DocumentProcessCompletionServiceType>())
                        {
                            <MudSelectItem Value="@(completionType as DocumentProcessCompletionServiceType?)">@completionType.ToString()</MudSelectItem>
                        }
                    </MudSelect>
                    <MudSelect T="AiModelDeploymentInfo" @bind-Value="SelectedDeployment" Label="AI Model Deployment"
                               ToStringFunc="@(d => d.DeploymentName)">
                        @foreach (var deployment in _aiModelDeployments)
                        {
                            <MudSelectItem Value="@deployment">
                                @deployment.DeploymentName
                            </MudSelectItem>
                        }
                    </MudSelect>

                    <MudSelect T="AiModelDeploymentInfo" @bind-Value="SelectedValidationDeployment" Label="AI Model Deployment for Validation"
                               ToStringFunc="@(d => d.DeploymentName)">
                        @foreach (var deployment in _aiModelDeployments)
                        {
                            <MudSelectItem Value="@deployment">
                                @deployment.DeploymentName
                            </MudSelectItem>
                        }
                    </MudSelect>

                    <!-- File Upload Section -->
                    @if (ProcessId != null && _isEditMode)
                    {
                        <MudDivider Class="my-4" />


                        <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                                       FilesChanged="HandleFileSelected"
                                       MaximumFileCount="16384">
                            <ButtonTemplate>
                                <MudButton HtmlTag="label"
                                           Variant="Variant.Filled"
                                           Color="Color.Primary"
                                           StartIcon="@Icons.Material.Filled.CloudUpload"
                                           for="@context">
                                    Upload RAG Documents to Repository
                                </MudButton>
                            </ButtonTemplate>
                        </MudFileUpload>
                    }

                    @if (ProcessId != null && _isEditMode && _process.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                    {
                        <MudStack Class="mt-4" Spacing="2">
                            <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.Refresh" OnClick="ShowReindexDialog">
                                Reindex Documents
                            </MudButton>
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                This will recreate vector embeddings for all previously ingested documents in this process.
                            </MudText>
                        </MudStack>
                    }

                    @if (ProcessId != null && _isEditMode)
                    {
                        <MudSpacer />

                        <MudGrid Spacing="2" Class="mt-2 mb-2">
                            <MudItem>
                                <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="OpenDocumentOutlineEditor">Document Outline Editor</MudButton>
                            </MudItem>
                            <MudItem>
                                <MudButton Variant="Variant.Filled" Color="Color.Secondary" OnClick="OpenMetadataFieldEditor">Metadata Fields Editor</MudButton>
                            </MudItem>
                        </MudGrid>

                    }
                    <MudSpacer />

                    <MudGrid Spacing="2" Class="mt-2 mb-2">
                        <MudItem>
                            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveProcess">Save</MudButton>
                        </MudItem>
                        <MudItem>
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="Cancel">Cancel</MudButton>
                        </MudItem>
                    </MudGrid>

                </MudItem>

                <MudItem xs="12" md="6">
                    <!-- Document Retrieval Settings section -->
                    <MudText Typo="Typo.h6">Document Retrieval Settings</MudText>

                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudSlider T="int" @bind-Value="_process.PrecedingSearchPartitionInclusionCount" Min="0" Max="10" TickMarks="true" ValueLabel="true" Immediate="true">
                            # of Preceding Partitions to retrieve
                        </MudSlider>
                        <MudNumericField @bind-Value="_process.PrecedingSearchPartitionInclusionCount" Min="0" Max="10" Immediate="true" Style="width:80px;" />
                    </MudStack>

                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudSlider T="int" @bind-Value="_process.FollowingSearchPartitionInclusionCount" Min="0" Max="10" TickMarks="true" ValueLabel="true" Immediate="true">
                            # of Following Partitions to retrieve
                        </MudSlider>
                        <MudNumericField @bind-Value="_process.FollowingSearchPartitionInclusionCount" Min="0" Max="10" Immediate="true" Style="width:80px;" />
                    </MudStack>

                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudSlider T="int" @bind-Value="_process.NumberOfCitationsToGetFromRepository" Min="0" Max="100" TickMarks="false" ValueLabel="true" Immediate="true">
                            # Number of Citations to retrieve
                        </MudSlider>
                        <MudNumericField @bind-Value="_process.NumberOfCitationsToGetFromRepository" Min="0" Max="100" Immediate="true" Style="width:80px;" />
                    </MudStack>

                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        <MudSlider T="double" @bind-Value="_minimumRelevancePercentage" Min="0" Max="100" Step="10" TickMarks="true" TickMarkLabels="@_minimumRelevanceStepLabels" ValueLabel="true" Immediate="true">
                            Minimum Relevance (%)
                        </MudSlider>
                        <MudNumericField @bind-Value="_minimumRelevancePercentage" Min="0" Max="100" Step="10" Immediate="true" Style="width:80px;" />
                    </MudStack>

                    <!-- Validation Pipeline Settings section -->
                    @if (_isEditMode)
                    {
                        <MudStack AlignItems="AlignItems.Start" Spacing="2">
                            <ValidationStepsEditorComponent Steps="@_validationSteps"
                                                            StepsChanged="@HandleValidationStepsChanged"
                                                            RunValidationAutomatically="@_runValidationAutomatically"
                                                            RunValidationAutomaticallyChanged="@HandleRunValidationAutomaticallyChanged" />
                        </MudStack>
                    }

                </MudItem>
            </MudGrid>
        </MudPaper>
    }
    
    <!-- Place this after the main form MudPaper -->
    @if (_isEditMode)
    {
        <MudDivider Class="my-4" />

        <MudPaper Class="pa-4">
            <MudTabs Elevation="4" Rounded="true" ApplyEffectsToContainer="true" PanelClass="pa-4">
                <MudTabPanel Text="Document Libraries">
                    <MudText Typo="Typo.h6">Associated Document Libraries</MudText>

                    <MudTable Items="_associatedLibraries" Hover="true">
                        <HeaderContent>
                            <MudTh>Library Name</MudTh>
                            <MudTh>Description</MudTh>
                            <MudTh>Actions</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd>@context.ShortName</MudTd>
                            <MudTd>@context.DescriptionOfContents</MudTd>
                            <MudTd>
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="() => ConfirmDisassociateLibrary(context.Id)" />
                            </MudTd>
                        </RowTemplate>
                    </MudTable>

                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowAssociateLibraryDialog" Class="mt-4">Associate Document Library</MudButton>
                </MudTabPanel>

                <MudTabPanel Text="Plugins">
                    <PluginDocumentProcessAssociationManager DocumentProcessId="@ProcessId"
                                                          PluginCentric="false"
                                                          Title="Associated Plugins"
                                                          SelectionColumnLabel="Plugin"
                                                          OnAssociationChanged="HandleAssociationChanged" />
                </MudTabPanel>

                <MudTabPanel Text="Prompts">
                    @if (_showPrompts)
                    {
                        <PromptList Prompts="_prompts" />
                    }
                    else
                    {
                        <MudProgressCircular Indeterminate="true" />
                    }
                </MudTabPanel>
            </MudTabs>
        </MudPaper>
    }


</MudContainer>

@code {
    [Parameter] public Guid? ProcessId { get; set; }
    [Parameter] public EventCallback OnProcessSaved { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }

    // Initialized immediately; treated as non-null after OnInitializedAsync
    private DocumentProcessInfo _process = new();
    private List<PromptInfo> _prompts = [];

    // Validation pipeline-related fields
    private List<DocumentProcessValidationPipelineStepInfo> _validationSteps = [];
    private DocumentProcessValidationPipelineInfo? _validationPipeline;
    private bool _runValidationAutomatically = true;

    // Plugin-related fields
    private List<McpPluginInfo> _availablePlugins = new();
    private List<PluginAssociationViewModel> _associatedPlugins = new();

    // Document Library-related fields
    private List<DocumentLibraryInfo> _associatedLibraries = new();
    private List<DocumentLibraryInfo> _availableLibraries = new();
    private List<AiModelDeploymentInfo> _aiModelDeployments = new();

    private bool _isEditMode;
    private bool _showPrompts;
    
    // Add loading state
    private bool _isLoading = true;

    private readonly string[] _minimumRelevanceStepLabels = Enumerable.Range(0, 11).Select(i => $"{i * 10}%").ToArray();

    private string _indexName = string.Empty;
    private double _minimumRelevancePercentage
    {
        get => _process?.MinimumRelevanceForCitations * 100 ?? 0;
        set
        {
            if (_process != null)
                _process.MinimumRelevanceForCitations = value / 100;
        }
    }

    // Reindex status state
    private string ProcessOrchestrationId => string.IsNullOrWhiteSpace(_process?.ShortName) ? string.Empty : $"process-{_process.ShortName}";
    private DocumentReindexStateInfo? _processReindexStatus;
    private Dictionary<string, DocumentReindexStateInfo> _libraryReindexStatuses = new();

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load AI Model Deployments
            _aiModelDeployments = await ConfigurationApiClient.GetAiModelDeploymentsAsync();

            if (ProcessId.HasValue)
            {
                _isEditMode = true;
                _process = await DocumentProcessApiClient.GetDocumentProcessInfoByIdAsync(ProcessId.Value) ?? new DocumentProcessInfo();

                // Initialize _indexName with the existing repository value
                if (_process.Repositories != null && _process.Repositories.Any())
                {
                    _indexName = _process.Repositories.First();
                }
                else
                {
                    _indexName = string.Empty;
                }

                // Load associated plugins - use try/catch to avoid failures if the plugin API returns errors
                try
                {
                    await LoadAssociatedPlugins();

                    // Load available plugins
                    _availablePlugins = await PluginApiClient.GetAllMcpPluginsAsync() ?? new List<McpPluginInfo>();
                }
                catch (Exception ex)
                {
                    _availablePlugins = new List<McpPluginInfo>();
                    _associatedPlugins = new List<PluginAssociationViewModel>();
                    Console.WriteLine($"Error loading plugins: {ex.Message}");
                    Snackbar.Add($"Error loading plugins: {ex.Message}", Severity.Warning);
                }

                try
                {
                    // Load associated document libraries
                    await LoadAssociatedLibraries();

                    // Load available document libraries
                    await LoadAvailableLibraries();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading document libraries: {ex.Message}");
                    Snackbar.Add($"Error loading document libraries: {ex.Message}", Severity.Warning);
                }

                try
                {
                    // Load prompts
                    await LoadPrompts();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading prompts: {ex.Message}");
                    Snackbar.Add($"Error loading prompts: {ex.Message}", Severity.Warning);
                }

                try
                {
                    // Load validation pipeline
                    await LoadValidationPipelines();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error loading validation pipeline: {ex.Message}");
                    Snackbar.Add($"Error loading validation pipeline: {ex.Message}", Severity.Warning);
                }

                // Refresh reindexing statuses
                await RefreshReindexStatusesAsync();
            }
            else
            {
                // New document process defaults
                SelectedDeployment = _aiModelDeployments.FirstOrDefault(x => x.DeploymentName == "gpt-4o");
                SelectedValidationDeployment = _aiModelDeployments.FirstOrDefault(x => x.DeploymentName == "gpt-4o");
                // Default repository logic type: Semantic Kernel Vector Store (migrated away from Kernel Memory)
                _process.LogicType = DocumentProcessLogicType.SemanticKernelVectorStore;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing document process edit component: {ex.Message}");
            Snackbar.Add($"Error loading document process: {ex.Message}", Severity.Error);
        }
        finally
        {
            // Always set loading to false when done, even if there's an error
            _isLoading = false;
        }
    }

    private Color GetStatusColor(ReindexOrchestrationState status) => status switch
    {
        ReindexOrchestrationState.Running => Color.Info,
        ReindexOrchestrationState.Completed => Color.Success,
        ReindexOrchestrationState.Failed => Color.Error,
        _ => Color.Default
    };

    private async Task RefreshReindexStatusesAsync()
    {
        try
        {
            _processReindexStatus = null;
            _libraryReindexStatuses.Clear();

            if (!string.IsNullOrWhiteSpace(ProcessOrchestrationId))
            {
                _processReindexStatus = await DocumentReindexApiClient.GetReindexingStatusAsync(ProcessOrchestrationId);
            }

            // For associated libraries, check each deterministic orchestration id
            foreach (var lib in _associatedLibraries)
            {
                var libOrchId = $"library-{lib.ShortName}";
                var status = await DocumentReindexApiClient.GetReindexingStatusAsync(libOrchId);
                if (status != null && status.Status != ReindexOrchestrationState.NotStarted)
                {
                    _libraryReindexStatuses[lib.ShortName] = status;
                }
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing reindex statuses: {ex.Message}");
        }
    }

    private async Task OpenProcessReindexProgress()
    {
        if (string.IsNullOrWhiteSpace(ProcessOrchestrationId)) return;

        var parameters = new DialogParameters
        {
            { "OrchestrationId", ProcessOrchestrationId },
            { "TargetName", _process.ShortName },
            { "Reason", _processReindexStatus?.Reason ?? "" }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    private async Task OpenLibraryReindexProgress(string libraryShortName)
    {
        var orchestrationId = $"library-{libraryShortName}";
        var parameters = new DialogParameters
        {
            { "OrchestrationId", orchestrationId },
            { "TargetName", libraryShortName },
            { "Reason", _libraryReindexStatuses.TryGetValue(libraryShortName, out var st) ? (st.Reason ?? "") : "" }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    // Intermediate property for binding the selected deployment.
    private AiModelDeploymentInfo? SelectedDeployment
    {
        get
        {
            // Return the deployment that matches the currently selected ID (if any).
            return _aiModelDeployments.FirstOrDefault(d => d.Id == _process.AiModelDeploymentId);
        }
        set
        {
            if (value is not null)
            {
                _process.AiModelDeploymentId = value.Id;
            }
            else
            {
                _process.AiModelDeploymentId = null;
            }
        }
    }

    // Intermediate property for binding the selected validation deployment.
    private AiModelDeploymentInfo? SelectedValidationDeployment
    {
        get
        {
            // Return the deployment that matches the currently selected validation ID (if any).
            return _aiModelDeployments.FirstOrDefault(d => d.Id == _process.AiModelDeploymentForValidationId);
        }
        set
        {
            if (value is not null)
            {
                _process.AiModelDeploymentForValidationId = value.Id;
            }
            else
            {
                _process.AiModelDeploymentForValidationId = null;
            }
        }
    }

    private async Task HandleFileSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files == null || files.Count == 0)
        {
            Snackbar.Add("No files selected for upload.", Severity.Warning);
            return;
        }
        foreach (var file in files)
        {
            var fileName = $"{_process.BlobStorageAutoImportFolderName}/{file.Name}";
            // URL encode the file name
            fileName = WebUtility.UrlEncode(fileName);

            try
            {
                var result = await FileApiClient.UploadFileDirectAsync(_process.BlobStorageContainerName, fileName, file);
                Snackbar.Add($"File '{file.Name}' uploaded successfully.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error uploading file '{file.Name}': {ex.Message}", Severity.Error);
            }
        }
    }

    private void HandleValidationStepsChanged(List<DocumentProcessValidationPipelineStepInfo> steps)
    {
        _validationSteps = steps;
    }

    private void HandleRunValidationAutomaticallyChanged(bool value)
    {
        _runValidationAutomatically = value;
        // No need to save immediately - will be saved when the form is submitted
    }

    private async Task LoadAssociatedLibraries()
    {
        if (_process == null)
            return;

        _associatedLibraries = await DocumentLibraryApiClient.GetDocumentLibrariesByProcessIdAsync(_process.Id);
    }

    private async Task LoadAvailableLibraries()
    {
        var allLibraries = await DocumentLibraryApiClient.GetAllDocumentLibrariesAsync();
        _availableLibraries = allLibraries.Where(l => !_associatedLibraries.Any(al => al.Id == l.Id)).ToList();
    }

    private async Task LoadPrompts()
    {
        _prompts = await DocumentProcessApiClient.GetPromptsByProcessIdAsync(_process.Id);
        _showPrompts = true;
    }

    private async Task LoadValidationPipelines()
    {
        if (ProcessId.HasValue)
        {
            _validationPipeline = await DocumentProcessApiClient.GetValidationPipelineAsync(ProcessId.Value);
        }
        if (_validationPipeline != null)
        {
            _validationSteps = _validationPipeline.ValidationPipelineSteps;
            _runValidationAutomatically = _validationPipeline.RunValidationAutomatically;
        }
    }

    private async Task LoadAssociatedPlugins()
    {
        try
        {
            // Get associated plugins from the API
            var associatedPluginInfos = await PluginApiClient.GetMcpPluginsByDocumentProcessIdAsync(_process.Id);
            
            // Map to PluginAssociation objects
            _associatedPlugins = (associatedPluginInfos ?? new List<McpPluginInfo>()).Select(p =>
            {
                var docProcess = p.DocumentProcesses?.FirstOrDefault(dp => dp.DocumentProcessId == _process.Id);
                var version = docProcess?.Version;
                var versionString = version != null ? $"{version.Major}.{version.Minor}.{version.Patch}" : 
                    p.LatestVersion != null ? $"{p.LatestVersion.Major}.{p.LatestVersion.Minor}.{p.LatestVersion.Patch}" : "1.0.0";

                return new PluginAssociationViewModel
                {
                    Plugin = p,
                    Version = versionString
                };

            }).ToList();
        }
        catch (Exception ex)
        {
            // Log the error, but don't crash
            Console.WriteLine($"Error loading associated plugins: {ex.Message}");
            _associatedPlugins = new List<PluginAssociationViewModel>();
            Snackbar.Add($"Error loading plugins: {ex.Message}", Severity.Warning);
        }
    }

    private async Task SaveProcess()
    {
        ValidateAndFormatShortName();
        UpdateRepositories();

        if (_isEditMode && _process != null)
        {
            // Handle validation pipeline
            if (_validationSteps.Any())
            {
                var pipelineInfo = _validationPipeline ?? new DocumentProcessValidationPipelineInfo
                {
                    DocumentProcessId = _process.Id
                };

                pipelineInfo.ValidationPipelineSteps = _validationSteps;
                pipelineInfo.RunValidationAutomatically = _runValidationAutomatically;
                await DocumentProcessApiClient.SaveValidationPipelineAsync(_process.Id, pipelineInfo);
            }
            else if (_validationPipeline != null)
            {
                // Delete the validation pipeline if it exists but there are no steps
                await DocumentProcessApiClient.DeleteValidationPipelineAsync(_process.Id);
                _validationPipeline = null;
            }

            await DocumentProcessApiClient.UpdateDynamicDocumentProcessDefinitionAsync(_process);
            Snackbar.Add("Document process updated successfully.", Severity.Success);
        }
        else
        {
            var createdProcess = await DocumentProcessApiClient.CreateDynamicDocumentProcessDefinitionAsync(_process);
            if (createdProcess != null)
            {
                _process = createdProcess;
                _isEditMode = true;

                // Save validation pipeline if there are steps
                if (_validationSteps.Any())
                {
                    var pipelineInfo = new DocumentProcessValidationPipelineInfo
                    {
                        DocumentProcessId = _process.Id,
                        ValidationPipelineSteps = _validationSteps,
                        RunValidationAutomatically = _runValidationAutomatically
                    };

                    _validationPipeline = await DocumentProcessApiClient.SaveValidationPipelineAsync(_process.Id, pipelineInfo);
                }

                // Load associated plugins and libraries
                await LoadAssociatedPlugins();
                await LoadAssociatedLibraries();
                await LoadAvailableLibraries();
                await LoadValidationPipelines();

                // Load prompts
                await LoadPrompts();

                Snackbar.Add("Document process created successfully.", Severity.Success);
            }
        }

        await OnProcessSaved.InvokeAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task Cancel()
    {
        await OnCancel.InvokeAsync();
    }

    private void OpenDocumentOutlineEditor()
    {
        var parameters = new DialogParameters
        {
            { "DocumentOutlineId", _process.DocumentOutlineId }
        };

        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };
        DialogService.Show<EditDocumentOutlineDialog>("Document Outline Editor", parameters, options);
    }

    private async Task OpenMetadataFieldEditor()
    {
        var parameters = new DialogParameters
        {
            { "DocumentProcessId", _process.Id },
            { "DocumentProcessName", _process.ShortName}
        };
        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraLarge, FullWidth = true, DisableBackdropClick = true};
        var dialog = await DialogService.ShowAsync<EditMetadataFieldsDialog>("Metadata Fields Editor", parameters, options);
        var result = await dialog.Result;

    if (!result.Canceled)
        {
            //_process.MetadataFields = result.Data;
        }
    }

    private void ValidateAndFormatShortName()
    {
        if (string.IsNullOrWhiteSpace(_process.ShortName))
        {
            Snackbar.Add("Short Name cannot be empty.", Severity.Error);
            return;
        }

        // Replace spaces with periods
        _process.ShortName = _process.ShortName.Replace(" ", ".");

        // Remove any characters that are not letters, digits, or periods
        _process.ShortName = new string(_process.ShortName.Where(c => char.IsLetterOrDigit(c) || c == '.').ToArray());

        if (string.IsNullOrWhiteSpace(_process.ShortName))
        {
            Snackbar.Add("Short Name must contain valid characters.", Severity.Error);
            return;
        }

        ComputeIndexAndBlobStorageContainerName();
    }

    private void ComputeIndexAndBlobStorageContainerName()
    {
        if (!_isEditMode && string.IsNullOrWhiteSpace(_indexName))
        {
            _indexName = "index-" + _process.ShortName.ToLower()
                                            .Replace(" ", "-")
                                            .Replace(".", "-");
        }

        if (!_isEditMode && string.IsNullOrWhiteSpace(_process.BlobStorageContainerName))
        {
            _process.BlobStorageContainerName = "blob-" + _process.ShortName.ToLower()
                                            .Replace(" ", "-")
                                            .Replace(".", "-");
        }
    }

    private void UpdateRepositories()
    {
        _process.Repositories ??= new List<string>();
        _process.Repositories.Clear();
        _process.Repositories.Add(_indexName);
    }

    // Document Library Association Methods
    private void ShowAssociateLibraryDialog()
    {
        var parameters = new DialogParameters
        {
            { "AvailableLibraries", _availableLibraries },
            { "DocumentProcessId", _process.Id }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<AssociateDocumentLibraryWithDocumentProcessDialog>("Associate Document Library", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await LoadAssociatedLibraries();
                await LoadAvailableLibraries();
                // refresh reindex status when libraries change
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private void ConfirmDisassociateLibrary(Guid libraryId)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", "Are you sure you want to disassociate this document library?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Disassociate Document Library", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await DisassociateLibrary(libraryId);
                // refresh reindex status when libraries change
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private async Task DisassociateLibrary(Guid libraryId)
    {
        if (_process == null)
            return;

        try
        {
            await DocumentLibraryApiClient.DisassociateDocumentProcessAsync(libraryId, _process.Id);
            Snackbar.Add("Document library disassociated successfully.", Severity.Success);

            await LoadAssociatedLibraries();
            await LoadAvailableLibraries();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error disassociating document library: {ex.Message}", Severity.Error);
        }
    }

    // Plugin-related methods
    private async Task HandleAssociationChanged()
    {
        // Refresh associated plugins
        await LoadAssociatedPlugins();
        StateHasChanged();
    }

    private async Task ShowReindexDialog()
    {
        if (!_isEditMode || _process.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", _process.ShortName },
            { "IsDocumentProcess", true },
            { "Reason", "Manual reindexing" },
            { "WarningMessage", "This will delete and rebuild the process repository index." }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Documents", parameters, options);
    }

    // Helper class for plugin associations
    private class PluginAssociationViewModel
    {
    public McpPluginInfo Plugin { get; set; } = new();
    public string Version { get; set; } = string.Empty;
    }
}
