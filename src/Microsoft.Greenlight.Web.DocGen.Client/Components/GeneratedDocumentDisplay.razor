@implements IAsyncDisposable
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Messages.DocumentGeneration.Events
@using Microsoft.Greenlight.Web.Shared.Helpers
@using System.Timers;
@using Microsoft.Greenlight.Shared.Contracts.DTO.Document

@inject IDocumentGenerationApiClient DocumentGenerationApiClient
@inject IContentNodeApiClient ContentNodeApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject NavigationManager Navigation

@code {
    [Parameter] public Guid DocumentId { get; set; }
    [Parameter] public bool LiveUpdated { get; set; } = true;
    [Parameter] public GeneratedDocumentInfo? Document { get; set; }
    [Parameter] public bool EnableReferenceFrontend { get; set; }
    [Parameter] public bool FromGeneration { get; set; }

    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    private bool receivedMessagesVisible = false;
    private bool areNodesGenerated = false;
    private bool isDocumentExportable = false;
    private Timer? stateCheckTimer;
    private bool isFromGenerationPage = false;

    private List<string> messages = new List<string>();
}

@if (Document != null)
{
    <MudPaper Class="pa-4">
        <MudGrid>
            <MudItem xs="12" sm="9">
                <MudText Typo="Typo.h4" GutterBottom="true">@Document.Title</MudText>
            </MudItem>
            <MudItem xs="12" sm="3" Class="d-flex justify-end align-center">
                @if (areNodesGenerated)
                {
                    <DocumentDownloadLink DocumentId=@DocumentId.ToString() />
                }
            </MudItem>
        </MudGrid>

        <MudText Typo="Typo.body1" GutterBottom="true">Document ID: @Document.Id</MudText>
        <MudPaper Outlined="true" Class="border-dashed">
            @if (Document.ContentNodes.Any())
            {
                @foreach (var contentNode in Document.ContentNodes)
                {
                    <ContentNodeDisplay Node="@contentNode" Recursive="true" EnableReferenceFrontend="@EnableReferenceFrontend" />
                }
            }
        </MudPaper>
    </MudPaper>
}
else
{
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h4" GutterBottom="true">Loading document...</MudText>
        <MudSkeleton />
    </MudPaper>
}

@code {
    protected override async Task OnInitializedAsync()
    {
        // Check if we're coming directly from document generation using URL parsing
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        var segments = uri.AbsolutePath.Split('/');

        // Check if the last segment is "true" or parameter FromGeneration is true
        isFromGenerationPage = segments.Length > 2 && segments[^1] == "true" || FromGeneration;

        var token = await DocumentGenerationApiClient.GetAccessTokenAsync();

        // If we're not coming directly from generation, try to load the document right away
        if (!isFromGenerationPage)
        {
            try
            {
                Document = await GetDocumentAsync(DocumentId);
                if (Document != null && Document.ContentNodes != null)
                {
                    ContentNodeInfoSorter.SortContentNodes(Document.ContentNodes);
                    areNodesGenerated = AllNodesGenerated(Document.ContentNodes);
                }
            }
            catch
            {
                // Document might not exist yet, we'll wait for SignalR notification
            }
        }

        await StartHubConnections();
        StartStateCheckTimer();
    }

    private void StartStateCheckTimer()
    {
        stateCheckTimer = new Timer(5000); // Check every 5 seconds
        stateCheckTimer.Elapsed += async (sender, e) => await CheckDocumentState();
        stateCheckTimer.Start();
    }

    private async Task CheckDocumentState()
    {
        try
        {
            // If document is null, try to get it (it might be available now)
            if (Document == null)
            {
                Document = await GetDocumentAsync(DocumentId);
                if (Document != null && Document.ContentNodes != null)
                {
                    ContentNodeInfoSorter.SortContentNodes(Document.ContentNodes);
                }
            }

            if (Document != null)
            {
                areNodesGenerated = AllNodesGenerated(Document.ContentNodes);
                isDocumentExportable = await IsDocumentExportable();

                if (isDocumentExportable)
                {
                    // Stop the timer if all nodes are generated so we don't keep checking
                    stateCheckTimer?.Stop();
                    stateCheckTimer?.Dispose();
                }

                await InvokeAsync(StateHasChanged);
            }
        }
        catch
        {
            // Document might not be ready yet, continue polling
        }
    }

    private async Task<bool> IsDocumentExportable()
    {
        // You might want to add additional checks here, e.g., minimum number of nodes
        return areNodesGenerated;
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            var url = $"{apiAddress}/hubs/notification-hub";

            HubConnection = new HubConnectionBuilder()
                .WithUrl(url, options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithAutomaticReconnect()
                .Build();
        }

        HubConnection.On<string>( // CorrelationId
            "ReceiveDocumentOutlineNotification",
            HubReceiveDocumentOutlineNotificationHandler);

        HubConnection.On<ContentNodeGenerated>(
            "ReceiveContentNodeNotification",
            HubReceiveContentNodeNotificationHandler);

        HubConnection.On<ContentNodeGenerationStateChanged>(
            "ReceiveContentNodeGenerationStateChangedNotification",
            HubReceiveContentNodeGenerationStateChangedNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

        // Add this connection to a group matching the document ID
        if (DocumentId != Guid.Empty)
        {
            await HubConnection.SendAsync("AddToGroup", DocumentId.ToString());
        }
    }

    // Called on component disposal
    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        // Remove handlers
        HubConnection.Remove("ReceiveDocumentOutlineNotification");
        HubConnection.Remove("ReceiveContentNodeNotification");
        HubConnection.Remove("ReceiveContentNodeGenerationStateChangedNotification");

        // Remove from group when leaving the page
        if (DocumentId != Guid.Empty)
        {
            await HubConnection.SendAsync("RemoveFromGroup", DocumentId.ToString());
        }
    }

    private async Task HubReceiveContentNodeGenerationStateChangedNotificationHandler(ContentNodeGenerationStateChanged message)
    {
        if (message.CorrelationId == DocumentId)
        {
            // This notification is for the document we are currently displaying - get the associated contentNode
            var contentNode = await ContentNodeApiClient.GetContentNodeAsync(message.ContentNodeId.ToString());
            if (contentNode is not null)
            {
                await UpdateContentNodeState(Document?.ContentNodes, contentNode);
                areNodesGenerated = AllNodesGenerated(Document.ContentNodes);
            }
        }
    }

    private async Task ExportDocument()
    {
        var stream = await DocumentGenerationApiClient.ExportDocumentAsync(DocumentId.ToString());
        using var memoryStream = new MemoryStream();
        await stream.CopyToAsync(memoryStream);
        var byteArray = memoryStream.ToArray();
        var base64 = Convert.ToBase64String(byteArray);
        var fileName = "exported_document.docx";
        var fileType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        var fileUrl = $"data:{fileType};base64,{base64}";
        Navigation.NavigateTo(fileUrl, true);
    }

    private async Task UpdateContentNodeState(List<ContentNodeInfo>? documentContentNodes, ContentNodeInfo updatedNodeFromEvent)
    {
        if (documentContentNodes is null || !documentContentNodes.Any()) return;

        // Apply the updates.
        documentContentNodes = UpdateNodes(documentContentNodes, updatedNodeFromEvent);
        ContentNodeInfoSorter.SortContentNodes(documentContentNodes);
        await CheckDocumentState();
        await InvokeAsync(StateHasChanged);

        // Recursive method to search and update the node in the tree.
        List<ContentNodeInfo> UpdateNodes(List<ContentNodeInfo> nodes, ContentNodeInfo updatedNode)
        {
            for (int i = 0; i < nodes.Count; i++)
            {
                if (nodes[i].Id == updatedNode.Id)
                {
                    // Replace the node.
                    nodes[i] = updatedNode;
                    return nodes; // Return immediately since the node has been replaced.
                }

                // If the current node has children, attempt to update them.
                if (nodes[i].Children != null && nodes[i].Children.Any())
                {
                    nodes[i].Children = UpdateNodes(nodes[i].Children, updatedNode);
                }
            }

            return nodes; // Return the potentially modified list of nodes.
        }
    }

    private async Task HubReceiveDocumentOutlineNotificationHandler(string correlationId)
    {
        string encodedMsg;
        if (correlationId == DocumentId.ToString())
        {
            receivedMessagesVisible = true;
            encodedMsg = $"Received ReceiveDocumentOutlineNotification for GeneratedDocument with ID : {correlationId}";
            // Get the document using /api/documents/documentId and render it
            try
            {
                var document = await DocumentGenerationApiClient.GetDocumentAsync(correlationId);
                if (document is not null)
                {
                    Document = document;
                    // Sort the ContentNodes by their Text property in ascending order
                    if (document.ContentNodes != null)
                        ContentNodeInfoSorter.SortContentNodes(document.ContentNodes);
                }
            }
            catch
            {
                encodedMsg = "Failed to retrieve document after receiving ReceiveDocumentOutlineNotification";
            }
        }
        else return;

        messages.Add(encodedMsg);

        await InvokeAsync(StateHasChanged);
    }

    private async Task HubReceiveContentNodeNotificationHandler(ContentNodeGenerated contentNodeGeneratedEvent)
    {
        string encodedMsg;
        if (contentNodeGeneratedEvent.CorrelationId == DocumentId)
        {
            var correlationIdString = contentNodeGeneratedEvent.CorrelationId.ToString();
            receivedMessagesVisible = true;
            encodedMsg = $"Received ReceiveContentNodeNotification for ContentNode with ID : {contentNodeGeneratedEvent.ContentNodeId}";
            try
            {
                if (this.Document == null)
                {
                    await HubReceiveDocumentOutlineNotificationHandler(correlationIdString);
                }

                var contentNode = await ContentNodeApiClient.GetContentNodeAsync(contentNodeGeneratedEvent.ContentNodeId.ToString());
                if (contentNode is not null)
                {
                    if (contentNode.ParentId is not null)
                    {
                        var parentNode = this.Document?.ContentNodes.FirstOrDefault(x => x.Id == contentNode.ParentId);
                        parentNode?.Children.Add(contentNode);
                    }
                    else
                    {
                        if (contentNode.Type == ContentNodeType.Heading || contentNode.Type == ContentNodeType.Title)
                        {
                            this.Document?.ContentNodes.Add(contentNode);
                        }
                        else
                        {
                            this.Document?.ContentNodes.Insert(0, contentNode);
                        }
                    }

                    if (Document?.ContentNodes != null)
                        ContentNodeInfoSorter.SortContentNodes(Document!.ContentNodes);
                }
                else
                {
                    encodedMsg = "Failed to retrieve ContentNode after receiving ReceiveContentNodeNotification - ignoring";
                }
            }
            catch
            {
                encodedMsg = "Failed to retrieve ContentNode after receiving ReceiveContentNodeNotification - ignoring";
            }
            messages.Add(encodedMsg);
        }
        else return;

        await CheckDocumentState();
        await InvokeAsync(StateHasChanged);
    }

    private async Task<GeneratedDocumentInfo?> GetDocumentAsync(Guid? documentId)
    {
        if (documentId == null) return null;

        try
        {
            return await DocumentGenerationApiClient.GetDocumentAsync(documentId.ToString());
        }
        catch
        {
            // Document might not exist yet
            return null;
        }
    }

    private bool AllNodesGenerated(List<ContentNodeInfo> contentNodes)
    {
        if (contentNodes is null || !contentNodes.Any()) return false;

        foreach (var contentNode in contentNodes)
        {
            if (contentNode.GenerationState != ContentNodeGenerationState.Completed && contentNode.GenerationState != ContentNodeGenerationState.Failed)
            {
                return false;
            }

            if (contentNode.Children != null && contentNode.Children.Any())
            {
                if (!AllNodesGenerated(contentNode.Children))
                {
                    return false;
                }
            }
        }

        return true;
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }

        stateCheckTimer?.Stop();
        stateCheckTimer?.Dispose();
    }
}
