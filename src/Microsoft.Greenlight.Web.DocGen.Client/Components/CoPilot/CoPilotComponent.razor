@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject IContentReferenceApiClient ContentReferenceApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar

@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Chat
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Commands
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events
@using Microsoft.Greenlight.Web.Shared.Auth

@implements IAsyncDisposable

@if (ConversationId.HasValue)
{
    var containerClass = EffectiveIsDarkMode ? "chat-container dark-mode" : "chat-container";
    if (FillContainer)
    {
        containerClass += " fill-container";
    }

    <MudPaper Class="@containerClass" Elevation="0">
        @if (!IsContextEditMode)
        {
            <div class="chat-header">
                <MudIcon Icon="@Icons.Material.Filled.Chat" Class="mr-2" />
                <h2 class="chat-header-title">
                    @(string.IsNullOrEmpty(DocumentProcessName) ? "Conversation" : $"Conversation with {DocumentProcessName}")
                </h2>
                @if (ChatMessages.Any())
                {
                    <MudTooltip Text="Scroll to bottom">
                        <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward"
                                       Color="Color.Inherit"
                                       OnClick="ScrollMessagesToBottom"
                                       Size="Size.Small" />
                    </MudTooltip>
                }
            </div>
        }

        @* Conversation References *@
        @if (ConversationReferences.Any() && !IsContextEditMode)
        {
            <div class="conversation-references mb-2">
                <MudPaper Class="pa-2">
                    <MudText Typo="Typo.subtitle2">Conversation References:</MudText>
                    <MudList Dense="true">
                        @foreach (var reference in ConversationReferences)
                        {
                            <MudListItem>
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                    @switch (reference.ReferenceType)
                                    {
                                        case ContentReferenceType.GeneratedDocument:
                                            <MudIcon Icon="@Icons.Material.Filled.Description" Size="Size.Small" />
                                            break;
                                        case ContentReferenceType.ExternalFile:
                                            <MudIcon Icon="@Icons.Material.Filled.AttachFile" Size="Size.Small" />
                                            break;
                                        default:
                                            <MudIcon Icon="@Icons.Material.Filled.Link" Size="Size.Small" />
                                            break;
                                    }
                                    <MudText Typo="Typo.body2">@reference.DisplayName</MudText>
                                    <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                   Color="Color.Error"
                                                   Size="Size.Small"
                                                   OnClick="() => RemoveReference(reference.Id)" />
                                </MudStack>
                            </MudListItem>
                        }
                    </MudList>
                </MudPaper>
            </div>
        }

        <div @ref="_messagesContainer" class="messages-container">
            @if (!ChatMessages.Any())
            {
                <div class="empty-state">
                    <MudIcon Icon="@Icons.Material.Outlined.ChatBubbleOutline" Size="Size.Large" Class="mb-4" />
                    <MudText Typo="Typo.body1">
                        @if (IsContextEditMode)
                        {
                            <text>Ask for suggestions to improve this content.</text>
                        }
                        else
                        {
                            <text>No messages yet. Start the conversation!</text>
                        }
                    </MudText>
                </div>
            }
            else
            {
                <div>
                    @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedUtc))
                    {
                        <ChatMessageDisplay ChatMessage="@chatMessage"
                                            CurrentUser="CurrentUser"
                                            ConversationReferences="AllAvailableReferences"
                                            OnContentSuggestionSelected="HandleContentSuggestionSelected"
                                            IsContextEditMode="IsContextEditMode"
                                            IsDarkMode="EffectiveIsDarkMode" />
                    }
                </div>
            }
        </div>

        <div class="input-container">
            @if (CurrentUser == null)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Width="100%" Height="56px" Animation="Animation.Pulse" />
            }
            else
            {
                <CoPilotInputComponent AllReferences="AllAvailableReferences"
                                       OnMessageSubmit="HandleMessageSubmit"
                                       @ref="_inputComponent"
                                       DisableFileUpload="@IsContextEditMode" />
            }
        </div>
    </MudPaper>
}
else
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="my-4">
        <MudText>No conversation loaded</MudText>
    </MudAlert>
}


<style>
    /* Base styles for both modes */
    .chat-container {
        display: flex;
        flex-direction: column;
        background-color: var(--mud-palette-background);
        border-radius: 8px;
        overflow: hidden;
    }

    .dark-mode {
        background-color: var(--mud-palette-background-dark);
    }

    /* Fill container mode - adapts to parent */
    .fill-container {
        height: 100%;
        width: 100%;
    }

    /* Default mode - fixed size */
    .chat-container:not(.fill-container) {
        height: calc(90vh - 120px);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        scroll-behavior: smooth;
        background-color: var(--mud-palette-background-grey);
        display: flex;
        flex-direction: column;
    }

    .dark-mode .messages-container {
        background-color: var(--mud-palette-background-grey-darken);
    }

    .messages-list {
        display: flex;
        flex-direction: column;
        width: 100%;
    }

    .input-container {
        padding: 0.75rem;
        border-top: 1px solid var(--mud-palette-lines-default);
        background-color: var(--mud-palette-surface);
    }

    .dark-mode .input-container {
        background-color: var(--mud-palette-surface-dark);
        border-color: var(--mud-palette-lines-dark);
    }

    /* Other inherited styles can be maintained from app.css */
</style>

@code {
    // For use within normal component hierarchy
    [CascadingParameter(Name = "IsDarkMode")]
    public bool CascadingIsDarkMode { get; set; }

    [CascadingParameter] public AuthenticationState? AuthenticationState { get; set; }
    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string? DocumentProcessName { get; set; }
    [Parameter] public Guid? ExternalReferenceId { get; set; }
    [Parameter] public bool InternalConversationIdCreate { get; set; } = false;

    // Direct parameter for dark mode
    [Parameter] public bool IsDarkMode { get; set; }

    // Parameters for content editing mode
    [Parameter] public bool IsContextEditMode { get; set; } = false;
    [Parameter] public string? EditContextContent { get; set; }
    [Parameter] public Guid? EditContextNodeId { get; set; }
    [Parameter] public string? EditContextDisplayName { get; set; }
    [Parameter] public EventCallback<string> OnContentSuggestionReceived { get; set; }

    /// <summary>
    /// Hide the initial content display in the CoPilot component
    /// </summary>
    [Parameter] public bool HideInitialContentDisplay { get; set; } = false;

    /// <summary>
    /// Start with a compact UI that shows only essential elements
    /// </summary>
    [Parameter] public bool StartWithCompactUI { get; set; } = false;

    /// <summary>
    /// When true, the component will adapt to fill its container instead of using fixed heights
    /// </summary>
    [Parameter] public bool FillContainer { get; set; } = false;

    // Use either direct or cascading parameter
    private bool EffectiveIsDarkMode => IsDarkMode || CascadingIsDarkMode;

    private ElementReference _messagesContainer;
    private CoPilotInputComponent? _inputComponent;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private List<ContentReferenceItemInfo> ConversationReferences { get; set; } = [];
    private List<ContentReferenceItemInfo> AllAvailableReferences { get; set; } = [];
    private UserInfoDTO? CurrentUser { get; set; }
    private bool _isLoading = true;
    private bool _initialContextMessageSent = false;

    protected override async Task OnInitializedAsync()
    {
        if (!ConversationId.HasValue && InternalConversationIdCreate)
        {
            ConversationId = Guid.NewGuid();
        }

        if (ConversationId.HasValue && !string.IsNullOrEmpty(DocumentProcessName))
        {
            try
            {
                _isLoading = true;
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var userInfo = UserInfo.FromClaimsPrincipal(authState.User);
                CurrentUser = await AuthorizationApiClient.GetUserInfoAsync(userInfo.UserId);

                // This also creates the conversation if it doesn't exist
                ChatMessages = await ChatApiClient.GetChatMessagesAsync(ConversationId.Value, DocumentProcessName);

                AllAvailableReferences = await ContentReferenceApiClient.GetAllReferencesAsync();

                await StartHubConnections();

                // If we're in content edit mode and have content to edit, send a system message with the content
                if (IsContextEditMode && !string.IsNullOrEmpty(EditContextContent) && !_initialContextMessageSent)
                {
                    await SendInitialContextMessage();
                    _initialContextMessageSent = true;
                }
            }
            finally
            {
                _isLoading = false;
            }
        }
    }

    private async Task SendInitialContextMessage()
    {
        // Create a system message with the content being edited
        var contextMessage = new ChatMessageDTO
        {
            Id = Guid.NewGuid(),
            ConversationId = ConversationId!.Value,
            Source = ChatMessageSource.System,
            Message = $"I'm going to help you improve the content from \"{EditContextDisplayName}\". The content is included as a reference.",
            ContentText = EditContextContent,
            CreatedUtc = DateTime.UtcNow
        };

        // Send to API but don't wait for response (it won't generate one)
        await ChatApiClient.SendChatMessageAsync(contextMessage);

        // Add a visible guidance message for the user - but only if we're not hiding initial display

        var guideMessage = new ChatMessageDTO
        {
            Id = Guid.NewGuid(),
            ConversationId = ConversationId!.Value,
            Source = ChatMessageSource.System,
            Message = "I can help improve this content. You can ask me to:\n\n" +
                      "• Make it more concise or detailed\n" +
                      "• Improve clarity or technical accuracy\n" +
                      "• Fix grammar and formatting\n" +
                      "• Change the tone or style\n\n" +
                      "When I provide suggestions, they will always include the complete content with the changes applied.",
            CreatedUtc = DateTime.UtcNow.AddSeconds(1)
        };

        // Only add guide message to UI, don't send to backend
        ChatMessages.Add(guideMessage);
        await InvokeAsync(StateHasChanged);

    }



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            HubConnection = new HubConnectionBuilder()
                .WithUrl($"{apiAddress}/hubs/notification-hub", options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithStatefulReconnect()
                .WithAutomaticReconnect()
                .Build();
        }

        HubConnection.On<ChatMessageResponseReceived>(
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        HubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        HubConnection.On<ConversationReferencesUpdatedNotification>(
            "ReceiveConversationReferencesUpdatedNotification",
            HubReceiveConversationReferencesUpdatedNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

        await HubConnection.SendAsync("AddToGroup", ConversationId);
    }

    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        HubConnection.Remove("ReceiveChatMessageResponseReceivedNotification");
        HubConnection.Remove("ReceiveProcessChatMessageReceivedNotification");
        HubConnection.Remove("ReceiveConversationReferencesUpdatedNotification");

        await HubConnection.SendAsync("RemoveFromGroup", ConversationId);
    }

    private async Task HubReceiveConversationReferencesUpdatedNotificationHandler(ConversationReferencesUpdatedNotification obj)
    {
        if (obj.ConversationId != ConversationId)
            return;

        ConversationReferences = obj.ReferenceItems;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task RemoveReference(Guid referenceId)
    {
        if (ConversationId == null)
            return;
        try
        {
            bool removed = await ContentReferenceApiClient.RemoveReferenceAsync(referenceId, ConversationId.Value);
            if (!removed)
            {
                Snackbar.Add("Reference or conversation not found.", Severity.Error);
                return;
            }
            // Remove from local list so UI updates immediately.
            var referenceToRemove = ConversationReferences.FirstOrDefault(r => r.Id == referenceId);
            if (referenceToRemove != null)
            {
                ConversationReferences.Remove(referenceToRemove);
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add("Error removing reference from conversation", Severity.Error);
        }
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        if (obj.ChatMessageDto.ConversationId != ConversationId)
            return;

        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            existingMessage.State = obj.ChatMessageDto.State;
            existingMessage.Message = obj.ChatMessageDto.Message;
            existingMessage.ContentText = obj.ChatMessageDto.ContentText;
        }
        else
        {
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        // If we're in content edit mode and we received a ContentText suggestion
        if (IsContextEditMode && !string.IsNullOrEmpty(obj.ChatMessageDto.ContentText))
        {
            // Notify parent component about the suggestion
            await OnContentSuggestionReceived.InvokeAsync(obj.ChatMessageDto.ContentText);
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task HandleMessageSubmit(string message)
    {
        if (string.IsNullOrWhiteSpace(message))
        {
            return;
        }

        var chatMessage = new ChatMessageDTO
        {
            ConversationId = ConversationId!.Value,
            Id = Guid.NewGuid(),
            Message = message,
            CreatedUtc = DateTime.UtcNow,
            Source = ChatMessageSource.User,
            UserId = CurrentUser!.ProviderSubjectId,
            UserFullName = CurrentUser!.FullName
        };

        // If in content edit mode, include the content being edited as a reference
        // but don't display it in the message itself
        if (IsContextEditMode && !string.IsNullOrEmpty(EditContextContent))
        {
            chatMessage.ContentText = EditContextContent;

            // Modify the message to indicate that content is included as a reference
            if (!message.Contains("content included as reference"))
            {
                chatMessage.Message = message + "\n\n(Content included as reference)";
            }
        }

        await ProcessMessage(chatMessage);
    }

    private void HandleContentSuggestionSelected(string suggestion)
    {
        if (!string.IsNullOrEmpty(suggestion) && IsContextEditMode)
        {
            OnContentSuggestionReceived.InvokeAsync(suggestion);
        }
    }

    public async Task UpdateContextContent(string newContent)
    {
        // Update the content context
        EditContextContent = newContent;

        // Create a system message with the updated content being edited
        var contextUpdateMessage = new ChatMessageDTO
        {
            Id = Guid.NewGuid(),
            ConversationId = ConversationId!.Value,
            Source = ChatMessageSource.System,
            Message = $"The content has been updated. Here's the current content from \"{EditContextDisplayName}\":",
            ContentText = newContent,
            CreatedUtc = DateTime.UtcNow
        };

        // Send to API but don't wait for response (it won't generate one)
        await ChatApiClient.SendChatMessageAsync(contextUpdateMessage);

        // Add an informational message to the UI
        var infoMessage = new ChatMessageDTO
        {
            Id = Guid.NewGuid(),
            ConversationId = ConversationId!.Value,
            Source = ChatMessageSource.System,
            Message = "Content has been updated. You can continue making suggestions based on the current version.",
            CreatedUtc = DateTime.UtcNow.AddSeconds(1)
        };

        // Only add message to UI, don't send to backend
        ChatMessages.Add(infoMessage);
        await InvokeAsync(StateHasChanged);

        // Scroll to bottom to show the new message
        await ScrollMessagesToBottom();
    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        var index = ChatMessages.FindLastIndex(x => x.CreatedUtc < chatMessageDto.CreatedUtc);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            await _inputComponent?.Clear();
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await ChatApiClient.SendChatMessageAsync(chatMessageDto);
            await _inputComponent?.Focus();
        }
    }

    private async Task ScrollMessagesToBottom()
    {
        try
        {
            await Task.Delay(50); // Small delay to ensure DOM update
            await JSRuntime.InvokeVoidAsync("scrollToBottom", _messagesContainer);
        }
        catch (Exception ex)
        {
            // Log error but don't throw - non-critical functionality
            Console.Error.WriteLine($"Error scrolling messages: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }
    }
}

