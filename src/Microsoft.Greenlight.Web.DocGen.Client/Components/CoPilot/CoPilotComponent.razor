@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject IContentReferenceApiClient ContentReferenceApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar

@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Chat
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Commands
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events
@using Microsoft.Greenlight.Web.Shared.Auth

@implements IAsyncDisposable

@if (ConversationId.HasValue)
{
    var containerClass = EffectiveIsDarkMode ? "chat-container dark-mode" : "chat-container";
    if (FillContainer)
    {
        containerClass += " fill-container";
    }

    <MudPaper Class="@containerClass" Elevation="0">
        @if (!IsContextEditMode)
        {
            <div class="chat-header">
                <MudIcon Icon="@Icons.Material.Filled.Chat" Class="mr-2" />
                <h2 class="chat-header-title">
                    @(string.IsNullOrEmpty(DocumentProcessName) ? "Conversation" : $"Conversation with {DocumentProcessName}")
                </h2>
                @if (ChatMessages.Any())
                {
                    <MudTooltip Text="Scroll to bottom">
                        <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward"
                                       Color="Color.Inherit"
                                       OnClick="ScrollMessagesToBottom"
                                       Size="Size.Small" />
                    </MudTooltip>
                }
            </div>
        }

        @* Conversation References *@
        @if (ConversationReferences.Any() && !IsContextEditMode)
        {
            <div class="conversation-references mb-2">
                <MudPaper Class="pa-2">
                    <MudText Typo="Typo.subtitle2">Conversation References:</MudText>
                    <MudList Dense="true">
                        @foreach (var reference in ConversationReferences)
                        {
                            <MudListItem>
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                    @switch (reference.ReferenceType)
                                    {
                                        case ContentReferenceType.GeneratedDocument:
                                            <MudIcon Icon="@Icons.Material.Filled.Description" Size="Size.Small" />
                                            break;
                                        case ContentReferenceType.ExternalFile:
                                            <MudIcon Icon="@Icons.Material.Filled.AttachFile" Size="Size.Small" />
                                            break;
                                        default:
                                            <MudIcon Icon="@Icons.Material.Filled.Link" Size="Size.Small" />
                                            break;
                                    }
                                    <MudText Typo="Typo.body2">@reference.DisplayName</MudText>
                                    <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                   Color="Color.Error"
                                                   Size="Size.Small"
                                                   OnClick="() => RemoveReference(reference.Id)" />
                                </MudStack>
                            </MudListItem>
                        }
                    </MudList>
                </MudPaper>
            </div>
        }

        <div @ref="_messagesContainer" class="messages-container">
            @if (!ChatMessages.Any())
            {
                <div class="empty-state">
                    <MudIcon Icon="@Icons.Material.Outlined.ChatBubbleOutline" Size="Size.Large" Class="mb-4" />
                    <MudText Typo="Typo.body1">
                        @if (IsContextEditMode)
                        {
                            <text>Ask for suggestions to improve this content.</text>
                        }
                        else
                        {
                            <text>No messages yet. Start the conversation!</text>
                        }
                    </MudText>
                </div>
            }
            else
            {
                <div>
                    @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedUtc))
                    {
                        <ChatMessageDisplay ChatMessage="@chatMessage"
                                            CurrentUser="CurrentUser"
                                            ConversationReferences="AllAvailableReferences"
                                            OnContentSuggestionSelected="HandleContentSuggestionSelected"
                                            IsContextEditMode="IsContextEditMode"
                                            IsDarkMode="EffectiveIsDarkMode" />
                    }
                </div>
            }
        </div>

        <div class="input-container">
            @if (CurrentUser == null)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Width="100%" Height="56px" Animation="Animation.Pulse" />
            }
            else
            {
                <CoPilotInputComponent AllReferences="AllAvailableReferences"
                                       OnMessageSubmit="HandleMessageSubmit"
                                       @ref="_inputComponent"
                                       DisableFileUpload="@IsContextEditMode" />
            }
        </div>
    </MudPaper>
}
else
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="my-4">
        <MudText>No conversation loaded</MudText>
    </MudAlert>
}


<style>
    /* Base styles for both modes */
    .chat-container {
        display: flex;
        flex-direction: column;
        background-color: var(--mud-palette-background);
        border-radius: 8px;
        overflow: hidden;
    }

    .dark-mode {
        background-color: var(--mud-palette-background-dark);
    }

    /* Fill container mode - adapts to parent */
    .fill-container {
        height: 100%;
        width: 100%;
    }

    /* Default mode - fixed size */
    .chat-container:not(.fill-container) {
        height: calc(90vh - 120px);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    .messages-container {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
        scroll-behavior: smooth;
        background-color: var(--mud-palette-background-grey);
        display: flex;
        flex-direction: column;
    }

    .dark-mode .messages-container {
        background-color: var(--mud-palette-background-grey-darken);
    }

    .messages-list {
        display: flex;
        flex-direction: column;
        width: 100%;
    }

    .input-container {
        padding: 0.75rem;
        border-top: 1px solid var(--mud-palette-lines-default);
        background-color: var(--mud-palette-surface);
    }

    .dark-mode .input-container {
        background-color: var(--mud-palette-surface-dark);
        border-color: var(--mud-palette-lines-dark);
    }

    /* Other inherited styles can be maintained from app.css */
</style>

@code {
    // For use within normal component hierarchy
    [CascadingParameter(Name = "IsDarkMode")]
    public bool CascadingIsDarkMode { get; set; }

    [CascadingParameter] public AuthenticationState? AuthenticationState { get; set; }
    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string? DocumentProcessName { get; set; }
    [Parameter] public Guid? ExternalReferenceId { get; set; }
    [Parameter] public bool InternalConversationIdCreate { get; set; } = false;

    // Direct parameter for dark mode
    [Parameter] public bool IsDarkMode { get; set; }

    // Parameters for content editing mode
    [Parameter] public bool IsContextEditMode { get; set; } = false;
    [Parameter] public string? EditContextContent { get; set; }
    [Parameter] public Guid? EditContextNodeId { get; set; }
    [Parameter] public string? EditContextDisplayName { get; set; }
    [Parameter] public EventCallback<string> OnContentSuggestionReceived { get; set; }

    /// <summary>
    /// Hide the initial content display in the CoPilot component
    /// </summary>
    [Parameter] public bool HideInitialContentDisplay { get; set; } = false;

    /// <summary>
    /// Start with a compact UI that shows only essential elements
    /// </summary>
    [Parameter] public bool StartWithCompactUI { get; set; } = false;

    /// <summary>
    /// When true, the component will adapt to fill its container instead of using fixed heights
    /// </summary>
    [Parameter] public bool FillContainer { get; set; } = false;

    // Use either direct or cascading parameter
    private bool EffectiveIsDarkMode => IsDarkMode || CascadingIsDarkMode;

    private ElementReference _messagesContainer;
    private CoPilotInputComponent? _inputComponent;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private List<ContentReferenceItemInfo> ConversationReferences { get; set; } = [];
    private List<ContentReferenceItemInfo> AllAvailableReferences { get; set; } = [];
    private UserInfoDTO? CurrentUser { get; set; }
    private bool _isLoading = true;
    private bool _initialContextMessageSent = false;

    private string _originalEditContextContent;
    private ContentChunkTracker _contentChunkTracker;
    private bool _isProcessingContentChunks = false;

    protected override async Task OnInitializedAsync()
    {
        if (!ConversationId.HasValue && InternalConversationIdCreate)
        {
            ConversationId = Guid.NewGuid();
        }

        if (ConversationId.HasValue && !string.IsNullOrEmpty(DocumentProcessName))
        {
            try
            {
                _isLoading = true;
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var userInfo = UserInfo.FromClaimsPrincipal(authState.User);
                CurrentUser = await AuthorizationApiClient.GetUserInfoAsync(userInfo.UserId);

                // This also creates the conversation if it doesn't exist
                ChatMessages = await ChatApiClient.GetChatMessagesAsync(ConversationId.Value, DocumentProcessName);

                AllAvailableReferences = await ContentReferenceApiClient.GetAllReferencesAsync();

                await StartHubConnections();

                // If we're in content edit mode and have content to edit, send a system message with the content
                if (IsContextEditMode && !string.IsNullOrEmpty(EditContextContent))
                {
                    _originalEditContextContent = EditContextContent;
                    _contentChunkTracker = new ContentChunkTracker(EditContextContent);

                    if (!_initialContextMessageSent)
                    {
                        await SendInitialContextMessage();
                        _initialContextMessageSent = true;
                    }
                }
            }
            finally
            {
                _isLoading = false;
            }
        }
    }

    private async Task SendInitialContextMessage()
    {
        // Create a system message with the content being edited
        var contextMessage = new ChatMessageDTO
        {
            Id = Guid.NewGuid(),
            ConversationId = ConversationId!.Value,
            Source = ChatMessageSource.System,
            Message = $"I'm going to help you improve the content from \"{EditContextDisplayName}\". The content is included as a reference.",
            ContentText = EditContextContent,
            CreatedUtc = DateTime.UtcNow
        };

        // Send to API but don't wait for response (it won't generate one)
        await ChatApiClient.SendChatMessageAsync(contextMessage);

        // Add a visible guidance message for the user - but only if we're not hiding initial display
        if (!HideInitialContentDisplay)
        {
            var guideMessage = new ChatMessageDTO
            {
                Id = Guid.NewGuid(),
                ConversationId = ConversationId!.Value,
                Source = ChatMessageSource.System,
                Message = "I can help improve this content. You can ask me to:\n\n" +
                          "• Make it more concise or detailed\n" +
                          "• Improve clarity or technical accuracy\n" +
                          "• Fix grammar and formatting\n" +
                          "• Change the tone or style\n\n" +
                          "When I provide suggestions, they will always include the complete content with the changes applied.",
                CreatedUtc = DateTime.UtcNow.AddSeconds(1)
            };

            // Only add guide message to UI, don't send to backend
            ChatMessages.Add(guideMessage);
            await InvokeAsync(StateHasChanged);
        }
    }



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            HubConnection = new HubConnectionBuilder()
                .WithUrl($"{apiAddress}/hubs/notification-hub", options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithStatefulReconnect()
                .WithAutomaticReconnect()
                .Build();
        }

        HubConnection.On<ChatMessageResponseReceived>(
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        HubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        HubConnection.On<ConversationReferencesUpdatedNotification>(
            "ReceiveConversationReferencesUpdatedNotification",
            HubReceiveConversationReferencesUpdatedNotificationHandler);

        HubConnection.On<ContentChunkUpdate>(
            "ReceiveContentChunkUpdateNotification",
            HubReceiveContentChunkUpdateNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

        await HubConnection.SendAsync("AddToGroup", ConversationId);
    }

    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        HubConnection.Remove("ReceiveChatMessageResponseReceivedNotification");
        HubConnection.Remove("ReceiveProcessChatMessageReceivedNotification");
        HubConnection.Remove("ReceiveConversationReferencesUpdatedNotification");
        HubConnection.Remove("ReceiveContentChunkUpdateNotification");

        await HubConnection.SendAsync("RemoveFromGroup", ConversationId);
    }

    private async Task HubReceiveContentChunkUpdateNotificationHandler(ContentChunkUpdate update)
    {
        if (update.ConversationId != ConversationId || !IsContextEditMode)
            return;

        _isProcessingContentChunks = !update.IsComplete;

        if (update.Chunks?.Any() == true)
        {
            try
            {
                // Apply chunks to the tracker
                var beforeContent = _contentChunkTracker.GetCurrentContent();
                var updatedContent = _contentChunkTracker.ApplyChunks(update.Chunks);
                
                // Detect if any changes were actually applied by comparing content
                bool changesApplied = beforeContent != updatedContent;
                
                // Update UI with the new content
                if (changesApplied)
                {
                    await OnContentSuggestionReceived.InvokeAsync(updatedContent);
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error processing content chunks: {ex}");

                // Add error message to the chat only if we don't have a specific error message already
                var existingError = ChatMessages.LastOrDefault(m => m.Source == ChatMessageSource.System &&
                                                     m.Message.Contains("Error applying content changes"));
                if (existingError == null)
                {
                    var errorMessage = new ChatMessageDTO
                    {
                        Id = Guid.NewGuid(),
                        ConversationId = ConversationId!.Value, 
                        Source = ChatMessageSource.System,
                        Message = "Error applying content changes. Please try again.",
                        CreatedUtc = DateTime.UtcNow
                    };

                    ChatMessages.Add(errorMessage);
                    await InvokeAsync(StateHasChanged);
                }
            }
        }

        // We don't need to add status messages for updates anymore since the assistant message handles this
        if (update.IsComplete)
        {
            _isProcessingContentChunks = false;
        }
    }

    private async Task HubReceiveConversationReferencesUpdatedNotificationHandler(ConversationReferencesUpdatedNotification obj)
    {
        if (obj.ConversationId != ConversationId)
            return;

        ConversationReferences = obj.ReferenceItems;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task RemoveReference(Guid referenceId)
    {
        if (ConversationId == null)
            return;
        try
        {
            bool removed = await ContentReferenceApiClient.RemoveReferenceAsync(referenceId, ConversationId.Value);
            if (!removed)
            {
                Snackbar.Add("Reference or conversation not found.", Severity.Error);
                return;
            }
            // Remove from local list so UI updates immediately.
            var referenceToRemove = ConversationReferences.FirstOrDefault(r => r.Id == referenceId);
            if (referenceToRemove != null)
            {
                ConversationReferences.Remove(referenceToRemove);
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add("Error removing reference from conversation", Severity.Error);
        }
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        if (obj.ChatMessageDto.ConversationId != ConversationId)
            return;

        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            existingMessage.State = obj.ChatMessageDto.State;
            existingMessage.Message = obj.ChatMessageDto.Message;
            
            // Only set ContentText for non-content-editing mode, since content-editing
            // mode handles updates through chunks
            if (!IsContextEditMode)
            {
                existingMessage.ContentText = obj.ChatMessageDto.ContentText;
            }
        }
        else
        {
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        // For content editing mode, don't call OnContentSuggestionReceived since
        // we're handling that through chunks
        if (IsContextEditMode && !string.IsNullOrEmpty(obj.ChatMessageDto.ContentText) && !_isProcessingContentChunks)
        {
            // Only update if we're not currently processing chunks (avoid conflict)
            await OnContentSuggestionReceived.InvokeAsync(obj.ChatMessageDto.ContentText);
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task HandleMessageSubmit(string message)
    {
        if (string.IsNullOrWhiteSpace(message))
        {
            return;
        }

        var chatMessage = new ChatMessageDTO
        {
            ConversationId = ConversationId!.Value,
            Id = Guid.NewGuid(),
            Message = message,
            CreatedUtc = DateTime.UtcNow,
            Source = ChatMessageSource.User,
            UserId = CurrentUser!.ProviderSubjectId,
            UserFullName = CurrentUser!.FullName
        };

        // If in content edit mode, include the content being edited as a reference
        // but don't display it in the message itself
        if (IsContextEditMode && !string.IsNullOrEmpty(EditContextContent))
        {
            chatMessage.ContentText = EditContextContent;

            // Modify the message to indicate that content is included as a reference
            if (!message.Contains("content included as reference"))
            {
                chatMessage.Message = message + "\n\n(Content included as reference)";
            }
        }

        await ProcessMessage(chatMessage);
    }

    private void HandleContentSuggestionSelected(string suggestion)
    {
        if (!string.IsNullOrEmpty(suggestion) && IsContextEditMode)
        {
            OnContentSuggestionReceived.InvokeAsync(suggestion);
        }
    }

    public async Task UpdateContextContent(string newContent)
    {
        // Update the content context
        EditContextContent = newContent;

        // Also update the original content reference for chunk positioning
        _originalEditContextContent = newContent;
        _contentChunkTracker = new ContentChunkTracker(newContent);

        // Create a system message with the updated content being edited - send to backend only
        var contextUpdateMessage = new ChatMessageDTO
        {
            Id = Guid.NewGuid(),
            ConversationId = ConversationId!.Value,
            Source = ChatMessageSource.System,
            Message = $"The content has been updated. Here's the current content from \"{EditContextDisplayName}\":",
            ContentText = newContent,
            CreatedUtc = DateTime.UtcNow
        };

        // Send to API to update backend context, but don't display in UI
        await ChatApiClient.SendChatMessageAsync(contextUpdateMessage);

        // No longer adding a local UI message about content updates
        // This keeps the conversation cleaner and lets the assistant's message updates remain visible
    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        var index = ChatMessages.FindLastIndex(x => x.CreatedUtc < chatMessageDto.CreatedUtc);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            await _inputComponent?.Clear();
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await ChatApiClient.SendChatMessageAsync(chatMessageDto);
            await _inputComponent?.Focus();
        }
    }

    private async Task ScrollMessagesToBottom()
    {
        try
        {
            await Task.Delay(50); // Small delay to ensure DOM update
            await JSRuntime.InvokeVoidAsync("scrollToBottom", _messagesContainer);
        }
        catch (Exception ex)
        {
            // Log error but don't throw - non-critical functionality
            Console.Error.WriteLine($"Error scrolling messages: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }
    }

    private class ContentChunkTracker
    {
        private string _originalContent;
        private string _currentContent;
        private readonly object _lock = new object();
        private readonly ILogger _logger;

        public ContentChunkTracker(string initialContent = null, ILogger logger = null)
        {
            _originalContent = initialContent ?? string.Empty;
            _currentContent = initialContent ?? string.Empty;
            _logger = logger;
        }

        public string ApplyChunks(List<ContentChunk> chunks)
        {
            if (chunks == null || !chunks.Any())
                return _currentContent;

            lock (_lock)
            {
                try
                {
                    // Create a working copy to build up changes
                    string workingContent = _currentContent;
                    
                    // Always process chunks in order from first position to last
                    // This prevents later changes from invalidating earlier ones
                    var orderedChunks = chunks.OrderBy(c => c.StartPosition).ToList();
                    
                    foreach (var chunk in orderedChunks)
                    {
                        switch (chunk.ChunkType)
                        {
                            case ContentChunkType.Replace:
                                workingContent = ApplyReplaceChunk(workingContent, chunk);
                                break;
                                
                            case ContentChunkType.Insert:
                                workingContent = ApplyInsertChunk(workingContent, chunk);
                                break;
                                
                            case ContentChunkType.Delete:
                                workingContent = ApplyDeleteChunk(workingContent, chunk);
                                break;
                        }
                    }
                    
                    // Update current content with all changes applied
                    _currentContent = workingContent;
                    return _currentContent;
                }
                catch (Exception ex)
                {
                    _logger?.LogError(ex, "Error applying content chunks");
                    return _currentContent; // Return unchanged content on error
                }
            }
        }

        private string ApplyReplaceChunk(string content, ContentChunk chunk)
        {
            if (string.IsNullOrEmpty(chunk.OriginalText))
                return content;
                
            // First try to find the exact text
            int index = content.IndexOf(chunk.OriginalText);
            
            // If not found directly, try using context
            if (index < 0 && !string.IsNullOrEmpty(chunk.Context))
            {
                // Try to parse context parts
                string beforeContext = string.Empty;
                string afterContext = string.Empty;
                
                if (chunk.Context.Contains("..."))
                {
                    var parts = chunk.Context.Split(new[] { "..." }, StringSplitOptions.None);
                    if (parts.Length >= 1) beforeContext = parts[0].Trim();
                    if (parts.Length >= 2) afterContext = parts[1].Trim();
                    
                    // Look for a section that matches [before][original][after]
                    if (!string.IsNullOrEmpty(beforeContext) && !string.IsNullOrEmpty(afterContext))
                    {
                        // Find where this context appears in the content
                        int contextStart = content.IndexOf(beforeContext);
                        if (contextStart >= 0)
                        {
                            int searchStart = contextStart + beforeContext.Length;
                            int potentialEnd = content.IndexOf(afterContext, searchStart);
                            
                            if (potentialEnd > searchStart)
                            {
                                // Extract what's in between and verify it matches or is similar
                                string textBetween = content.Substring(
                                    searchStart, potentialEnd - searchStart);
                                    
                                if (TextSimilarity(textBetween, chunk.OriginalText) > 0.7)
                                {
                                    // Replace this specific occurrence
                                    return content.Substring(0, searchStart) + 
                                           chunk.NewText + 
                                           content.Substring(potentialEnd);
                                }
                            }
                        }
                    }
                }
            }
            
            // If we found the text directly, replace it
            if (index >= 0)
            {
                return content.Substring(0, index) + 
                       chunk.NewText + 
                       content.Substring(index + chunk.OriginalText.Length);
            }
            
            // If we couldn't find it, return unchanged
            return content;
        }

        private string ApplyInsertChunk(string content, ContentChunk chunk)
        {
            // For inserts, we need to identify the exact insertion point
            if (!string.IsNullOrEmpty(chunk.Context) && chunk.Context.Contains("..."))
            {
                var parts = chunk.Context.Split(new[] { "..." }, StringSplitOptions.None);
                string beforeContext = parts.Length >= 1 ? parts[0].Trim() : string.Empty;
                string afterContext = parts.Length >= 2 ? parts[1].Trim() : string.Empty;
                
                // Try to insert between before and after context
                if (!string.IsNullOrEmpty(beforeContext) && !string.IsNullOrEmpty(afterContext))
                {
                    int beforePos = content.IndexOf(beforeContext);
                    if (beforePos >= 0)
                    {
                        int afterPos = content.IndexOf(afterContext, beforePos + beforeContext.Length);
                        if (afterPos > beforePos)
                        {
                            // Insert between the context markers
                            return content.Substring(0, beforePos + beforeContext.Length) +
                                   chunk.NewText +
                                   content.Substring(beforePos + beforeContext.Length);
                        }
                    }
                }
                // If we have only before context
                else if (!string.IsNullOrEmpty(beforeContext))
                {
                    int beforePos = content.IndexOf(beforeContext);
                    if (beforePos >= 0)
                    {
                        return content.Substring(0, beforePos + beforeContext.Length) +
                               chunk.NewText +
                               content.Substring(beforePos + beforeContext.Length);
                    }
                }
                // If we have only after context
                else if (!string.IsNullOrEmpty(afterContext))
                {
                    int afterPos = content.IndexOf(afterContext);
                    if (afterPos >= 0)
                    {
                        return content.Substring(0, afterPos) +
                               chunk.NewText +
                               content.Substring(afterPos);
                    }
                }
            }
            
            // Fall back to position-based insert using surrounding context from original
            if (chunk.StartPosition >= 0 && chunk.StartPosition < _originalContent.Length)
            {
                // Get context from original content around the insertion point
                int contextLength = 25;
                int startContext = Math.Max(0, chunk.StartPosition - contextLength);
                int endContext = Math.Min(_originalContent.Length, chunk.StartPosition + contextLength);
                
                string beforeText = startContext < chunk.StartPosition 
                    ? _originalContent.Substring(startContext, chunk.StartPosition - startContext)
                    : string.Empty;
                    
                string afterText = chunk.StartPosition < endContext
                    ? _originalContent.Substring(chunk.StartPosition, endContext - chunk.StartPosition)
                    : string.Empty;
                    
                // Try to locate this context in the current content
                if (!string.IsNullOrEmpty(beforeText) && !string.IsNullOrEmpty(afterText))
                {
                    int beforePos = content.IndexOf(beforeText);
                    if (beforePos >= 0 && beforePos + beforeText.Length < content.Length)
                    {
                        int afterPos = content.IndexOf(afterText, beforePos + beforeText.Length);
                        if (afterPos == beforePos + beforeText.Length)
                        {
                            return content.Substring(0, beforePos + beforeText.Length) +
                                   chunk.NewText +
                                   content.Substring(beforePos + beforeText.Length);
                        }
                    }
                }
                else if (!string.IsNullOrEmpty(beforeText))
                {
                    int beforePos = content.IndexOf(beforeText);
                    if (beforePos >= 0)
                    {
                        return content.Substring(0, beforePos + beforeText.Length) +
                               chunk.NewText +
                               content.Substring(beforePos + beforeText.Length);
                    }
                }
                else if (!string.IsNullOrEmpty(afterText))
                {
                    int afterPos = content.IndexOf(afterText);
                    if (afterPos >= 0)
                    {
                        return content.Substring(0, afterPos) +
                               chunk.NewText +
                               content.Substring(afterPos);
                    }
                }
            }
            
            // Could not reliably insert, return unchanged
            return content;
        }

        private string ApplyDeleteChunk(string content, ContentChunk chunk)
        {
            if (string.IsNullOrEmpty(chunk.OriginalText))
                return content;
                
            // Try to find the exact text to delete
            int index = content.IndexOf(chunk.OriginalText);
            
            // If not found directly, try using context
            if (index < 0 && !string.IsNullOrEmpty(chunk.Context))
            {
                // Parse context
                string beforeContext = string.Empty;
                string afterContext = string.Empty;
                
                if (chunk.Context.Contains("..."))
                {
                    var parts = chunk.Context.Split(new[] { "..." }, StringSplitOptions.None);
                    if (parts.Length >= 1) beforeContext = parts[0].Trim();
                    if (parts.Length >= 2) afterContext = parts[1].Trim();
                    
                    // Look for a section that matches [before][original][after]
                    if (!string.IsNullOrEmpty(beforeContext) && !string.IsNullOrEmpty(afterContext))
                    {
                        int contextStart = content.IndexOf(beforeContext);
                        if (contextStart >= 0)
                        {
                            int searchStart = contextStart + beforeContext.Length;
                            int potentialEnd = content.IndexOf(afterContext, searchStart);
                            
                            if (potentialEnd > searchStart)
                            {
                                string textBetween = content.Substring(
                                    searchStart, potentialEnd - searchStart);
                                    
                                if (TextSimilarity(textBetween, chunk.OriginalText) > 0.7)
                                {
                                    // Delete this specific occurrence
                                    return content.Substring(0, searchStart) + content.Substring(potentialEnd);
                                }
                            }
                        }
                    }
                }
            }
            
            // If found directly, delete it
            if (index >= 0)
            {
                return content.Substring(0, index) + content.Substring(index + chunk.OriginalText.Length);
            }
            
            // If not found, return unchanged
            return content;
        }

        // Simple text similarity function to help with fuzzy matching
        private double TextSimilarity(string s1, string s2)
        {
            if (string.IsNullOrEmpty(s1) || string.IsNullOrEmpty(s2))
                return 0;
                
            // Simple Jaccard similarity on character 2-grams
            var set1 = new HashSet<string>();
            var set2 = new HashSet<string>();
            
            for (int i = 0; i < s1.Length - 1; i++)
                set1.Add(s1.Substring(i, 2));
                
            for (int i = 0; i < s2.Length - 1; i++)
                set2.Add(s2.Substring(i, 2));
                
            int intersectionCount = set1.Intersect(set2).Count();
            int unionCount = set1.Union(set2).Count();
            
            return unionCount == 0 ? 0 : (double)intersectionCount / unionCount;
        }

        public string GetCurrentContent() => _currentContent;

        public void Reset(string content)
        {
            lock (_lock)
            {
                _originalContent = content ?? string.Empty;
                _currentContent = content ?? string.Empty;
            }
        }
    }
}
