@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject IContentReferenceApiClient ContentReferenceApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime
@inject ISnackbar Snackbar    

@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Chat
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Commands
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events
@using Microsoft.Greenlight.Web.Shared.Auth

@implements IAsyncDisposable

@if (ConversationId.HasValue)
{
    var containerClass = IsDarkMode ? "chat-container dark-mode" : "chat-container";

    <MudPaper Class="@containerClass" Elevation="0">
        <div class="chat-header">
            <MudIcon Icon="@Icons.Material.Filled.Chat" Class="mr-2" />
            <h2 class="chat-header-title">
                @(string.IsNullOrEmpty(DocumentProcessName) ? "Conversation" : $"Conversation with {DocumentProcessName}")
            </h2>
            @if (ChatMessages.Any())
            {
                <MudTooltip Text="Scroll to bottom">
                    <MudIconButton Icon="@Icons.Material.Filled.ArrowDownward"
                                   Color="Color.Inherit"
                                   OnClick="ScrollMessagesToBottom"
                                   Size="Size.Small" />
                </MudTooltip>
            }
        </div>

        @* Conversation References *@
        @if (ConversationReferences.Any())
        {
            <div class="conversation-references mb-2">
                <MudPaper Class="pa-2">
                    <MudText Typo="Typo.subtitle2">Conversation References:</MudText>
                    <MudList Dense="true">
                        @foreach (var reference in ConversationReferences)
                        {
                            <MudListItem>
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                                    @switch (reference.ReferenceType)
                                    {
                                        case ContentReferenceType.GeneratedDocument:
                                            <MudIcon Icon="@Icons.Material.Filled.Description" Size="Size.Small" />
                                            break;
                                        case ContentReferenceType.ExternalFile:
                                            <MudIcon Icon="@Icons.Material.Filled.AttachFile" Size="Size.Small" />
                                            break;
                                        default:
                                            <MudIcon Icon="@Icons.Material.Filled.Link" Size="Size.Small" />
                                            break;
                                    }
                                    <MudText Typo="Typo.body2">@reference.DisplayName</MudText>
                                    <MudIconButton Icon="@Icons.Material.Filled.Close"
                                                   Color="Color.Error"
                                                   Size="Size.Small"
                                                   OnClick="() => RemoveReference(reference.Id)" />
                                </MudStack>
                            </MudListItem>
                        }
                    </MudList>
                </MudPaper>
            </div>
        }

        <div @ref="_messagesContainer" class="messages-container">
            @if (!ChatMessages.Any())
            {
                <div class="empty-state">
                    <MudIcon Icon="@Icons.Material.Outlined.ChatBubbleOutline" Size="Size.Large" Class="mb-4" />
                    <MudText Typo="Typo.body1">No messages yet. Start the conversation!</MudText>
                </div>
            }
            else
            {
                <div>
                    @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedUtc))
                    {
                        <ChatMessageDisplay ChatMessage="@chatMessage" 
                                            CurrentUser="CurrentUser"
                                            ConversationReferences="AllAvailableReferences" />
                    }
                </div>
            }
        </div>

        <div class="input-container">
            @if (CurrentUser == null)
            {
                <MudSkeleton SkeletonType="SkeletonType.Rectangle" Width="100%" Height="56px" Animation="Animation.Pulse" />
            }
            else
            {
                <CoPilotInputComponent 
                    AllReferences="AllAvailableReferences"
                    OnMessageSubmit="HandleMessageSubmit"
                    @ref="_inputComponent" />
            }
        </div>
    </MudPaper>
}
else
{
    <MudAlert Severity="Severity.Info" Variant="Variant.Filled" Class="my-4">
        <MudText>No conversation loaded</MudText>
    </MudAlert>
}

@code {
    [CascadingParameter] public AuthenticationState? AuthenticationState { get; set; }
    [CascadingParameter] public HubConnection? HubConnection { get; set; }
    [CascadingParameter] public bool IsDarkMode { get; set; }

    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string? DocumentProcessName { get; set; }
    [Parameter] public Guid? ExternalReferenceId { get; set; }
    [Parameter] public bool InternalConversationIdCreate { get; set; } = false;

    private ElementReference _messagesContainer;
    private CoPilotInputComponent? _inputComponent;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private List<ContentReferenceItemInfo> ConversationReferences { get; set; } = [];
    private List<ContentReferenceItemInfo> AllAvailableReferences { get; set; } = [];
    private UserInfoDTO? CurrentUser { get; set; }
    private bool _isLoading = true;

    protected override async Task OnInitializedAsync()
    {
        if (!ConversationId.HasValue && InternalConversationIdCreate)
        {
            ConversationId = Guid.NewGuid();
        }

        if (ConversationId.HasValue && !string.IsNullOrEmpty(DocumentProcessName))
        {
            try
            {
                _isLoading = true;
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var userInfo = UserInfo.FromClaimsPrincipal(authState.User);
                CurrentUser = await AuthorizationApiClient.GetUserInfoAsync(userInfo.UserId);

                // This also creates the conversation if it doesn't exist
                ChatMessages = await ChatApiClient.GetChatMessagesAsync(ConversationId.Value, DocumentProcessName);

                AllAvailableReferences = await ContentReferenceApiClient.GetAllReferencesAsync();

                await StartHubConnections();
            }
            finally
            {
                _isLoading = false;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            HubConnection = new HubConnectionBuilder()
                .WithUrl($"{apiAddress}/hubs/notification-hub", options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithStatefulReconnect()
                .WithAutomaticReconnect()
                .Build();
        }

        HubConnection.On<ChatMessageResponseReceived>(
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        HubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        HubConnection.On<ConversationReferencesUpdatedNotification>(
            "ReceiveConversationReferencesUpdatedNotification",
            HubReceiveConversationReferencesUpdatedNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

        await HubConnection.SendAsync("AddToGroup", ConversationId);
    }

    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        HubConnection.Remove("ReceiveChatMessageResponseReceivedNotification");
        HubConnection.Remove("ReceiveProcessChatMessageReceivedNotification");
        HubConnection.Remove("ReceiveConversationReferencesUpdatedNotification");

        await HubConnection.SendAsync("RemoveFromGroup", ConversationId);
    }

    private async Task HubReceiveConversationReferencesUpdatedNotificationHandler(ConversationReferencesUpdatedNotification obj)
    {
        if (obj.ConversationId != ConversationId)
            return;

        ConversationReferences = obj.ReferenceItems;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task RemoveReference(Guid referenceId)
    {
        if (ConversationId == null)
            return;
        try
        {
            bool removed = await ContentReferenceApiClient.RemoveReferenceAsync(referenceId, ConversationId.Value);
            if (!removed)
            {
                Snackbar.Add("Reference or conversation not found.", Severity.Error);
                return;
            }
            // Remove from local list so UI updates immediately.
            var referenceToRemove = ConversationReferences.FirstOrDefault(r => r.Id == referenceId);
            if (referenceToRemove != null)
            {
                ConversationReferences.Remove(referenceToRemove);
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add("Error removing reference from conversation", Severity.Error);
        }
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            existingMessage.State = obj.ChatMessageDto.State;
            if (existingMessage.Message.Length < obj.ChatMessageDto.Message.Length)
            {
                existingMessage.Message = obj.ChatMessageDto.Message;
            }
        }
        else
        {
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task HandleMessageSubmit(string message)
    {
        if (string.IsNullOrWhiteSpace(message))
        {
            return;
        }

        var chatMessage = new ChatMessageDTO
        {
            ConversationId = ConversationId!.Value,
            Id = Guid.NewGuid(),
            Message = message,
            CreatedUtc = DateTime.UtcNow,
            Source = ChatMessageSource.User,
            UserId = CurrentUser!.ProviderSubjectId,
            UserFullName = CurrentUser!.FullName
        };

        await ProcessMessage(chatMessage);
    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        var index = ChatMessages.FindLastIndex(x => x.CreatedUtc < chatMessageDto.CreatedUtc);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();
    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            await _inputComponent?.Clear();
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await ChatApiClient.SendChatMessageAsync(chatMessageDto);
            await _inputComponent?.Focus();
        }
    }

    private async Task ScrollMessagesToBottom()
    {
        await JSRuntime.InvokeVoidAsyncIgnoreErrors("scrollToBottom", _messagesContainer);
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }
    }
}
