@using Microsoft.Greenlight.Shared.Contracts.Components
@using Microsoft.Greenlight.Shared.Contracts.DTO.Document
@using Microsoft.Greenlight.Shared.Contracts.DTO.Validation

@implements IDisposable

@inject IContentNodeApiClient ContentNodeApiClient
@inject IDocumentValidationApiClient DocumentValidationApiClient
@inject ISnackbar Snackbar
@inject IJSRuntime JS
@inject ValidationEditorService ValidationEditorService
@inject IDialogService DialogService

<div class="content-node-editor">
    @if (!IsEditing && !ShowVersions)
    {
        <div class="content-preview">
            <RenderMultilineText Value="@Node.Text" />
        </div>
    }
    else if (IsEditing)
    {
        <div class="editor-container">
            <EditorFactory @bind-Value="editText"
                           @bind-SecondValue="secondValueText"
                           EditorMode="@EditorMode"
                           HeightStyle="300px"
                           OnContentChanged="HandleContentChanged" />

            <div class="mt-3 d-flex align-center">
                <MudTextField @bind-Value="versionComment" Label="Comment (optional)" Variant="Variant.Outlined" Class="mr-2 flex-grow-1" />
                <MudSelect T="ContentNodeVersioningReason" @bind-Value="versionReason" Label="Reason" Variant="Variant.Outlined" Class="mr-2">
                    <MudSelectItem Value="ContentNodeVersioningReason.ManualEdit">Manual Edit</MudSelectItem>
                    <MudSelectItem Value="ContentNodeVersioningReason.ValidationRun">Validation</MudSelectItem>
                    <MudSelectItem Value="ContentNodeVersioningReason.AiEdit">AI Edit</MudSelectItem>
                </MudSelect>
            </div>

            <div class="mt-3 d-flex justify-end">
                @if (CurrentValidationChange != null)
                {
                    <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="RejectChange" Class="mr-2">Reject</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="AcceptChange" Disabled="@IsBusy">
                        @if (IsBusy)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Accepting...</span>
                        }
                        else
                        {
                            <span>Accept</span>
                        }
                    </MudButton>
                }
                else
                {
                    <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="CancelEdit" Class="mr-2">Cancel</MudButton>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveChanges" Disabled="@IsBusy">
                        @if (IsBusy)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Saving...</span>
                        }
                        else
                        {
                            <span>Save</span>
                        }
                    </MudButton>
                }
            </div>
        </div>
    }
    else if (ShowVersions)
    {
        <MudContainer MaxWidth="MaxWidth.Large" Class="pa-4">
            <MudCard>
                <MudCardContent>
                    <MudText Typo="Typo.h6" Class="mb-2">Version History</MudText>
                    <MudTable Items="versions?.OrderByDescending(x => x.Version)" Hover="true" Striped="true">
                        <HeaderContent>
                            <MudTh>Version</MudTh>
                            <MudTh>Time</MudTh>
                            <MudTh>Reason</MudTh>
                            <MudTh>Comment</MudTh>
                            <MudTh>Actions</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Version">@context.Version</MudTd>
                            <MudTd DataLabel="Time">@context.VersionTimeUtc.ToLocalTime().ToString("g")</MudTd>
                            <MudTd DataLabel="Reason">@context.VersioningReason</MudTd>
                            <MudTd DataLabel="Comment">@context.Comment</MudTd>
                            <MudTd DataLabel="Actions">
                                <MudTooltip Text="Preview this version">
                                    <MudIconButton Icon="@Icons.Material.Filled.Preview" Size="Size.Small" OnClick="@(() => PreviewVersion(context))" />
                                </MudTooltip>
                                <MudTooltip Text="Restore this version">
                                    <MudIconButton Icon="@Icons.Material.Filled.Restore" Size="Size.Small" OnClick="@(() => RestoreVersion(context))" Disabled="@IsBusy" />
                                </MudTooltip>
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudCardContent>
                @if (previewVersion != null)
                {
                    <MudCardContent>
                        <MudText Typo="Typo.subtitle1">Preview of Version @previewVersion.Version</MudText>
                        <MudText Typo="Typo.body2" Class="mt-2">
                            <RenderMultilineText Value="@previewVersion.Text" />
                        </MudText>
                    </MudCardContent>
                }
                <MudCardActions>
                    <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="CloseVersions">Close</MudButton>
                </MudCardActions>
            </MudCard>
        </MudContainer>
    }
</div>

@code {
    [CascadingParameter(Name = "IsDarkMode")]
    public bool IsDarkMode { get; set; }

    [Parameter] public ContentNodeInfo Node { get; set; } = null!;
    [Parameter] public string? SecondValue { get; set; }
    [Parameter] public EventCallback<ContentNodeInfo> OnNodeUpdated { get; set; }
    [Parameter] public EditorComponentEditorMode EditorMode { get; set; } = EditorComponentEditorMode.SingleValue;

    public bool IsEditing { get; set; } = false;
    private bool ShowVersions { get; set; } = false;
    private bool IsBusy { get; set; } = false;
    private string editText = "";
    private string secondValueText = "";
    private string lastUpdateEditText = "";
    private string lastUpdateSecondValueText = "";
    private string versionComment = "";
    private ContentNodeVersioningReason versionReason = ContentNodeVersioningReason.ManualEdit;
    private List<ContentNodeVersion>? versions;
    private ContentNodeVersion? previewVersion;
    private ValidationContentChangeInfo? CurrentValidationChange;

    protected override void OnInitialized()
    {
        ValidationEditorService.StateChanged += HandleValidationEditorStateChanged;

        if (Node.ParentId.HasValue)
        {
            ContentNodeBodyTextComponentRegistry.RegisterComponent(Node.ParentId.Value, this);
        }
    }

    protected override void OnParametersSet()
    {
        // Only update editText when not editing, so that changes aren't overwritten
        if (!IsEditing)
        {
            editText = Node.Text;
            if (EditorMode == EditorComponentEditorMode.MultiValueDiffEditor)
            {
                // For a diff editor, ensure we set up both the original and suggested text
                if (!string.IsNullOrEmpty(SecondValue))
                {
                    secondValueText = SecondValue;
                    // Initialize lastUpdate variables to track if changes were made
                    lastUpdateEditText = editText;
                    lastUpdateSecondValueText = string.Empty; // Empty means no changes yet
                }
            }
            else
            {
                // Single value editor
                lastUpdateEditText = editText;
            }
        }
    }


    public void Dispose()
    {
        ValidationEditorService.StateChanged -= HandleValidationEditorStateChanged;

        if (Node.ParentId.HasValue)
        {
            ContentNodeBodyTextComponentRegistry.UnregisterComponent(Node.ParentId.Value, this);
        }
    }

    private void HandleValidationEditorStateChanged(ValidationEditorStateChange stateChange)
    {
        if (stateChange.ContentNodeId == Node.Id)
        {
            EditorMode = stateChange.Data.EditorMode;
            editText = Node.Text;
            secondValueText = stateChange.Data.SuggestedText;
            CurrentValidationChange = stateChange.Data.ValidationChangeInfo; // Track the validation change

            if (stateChange.Data.IsVisible && !IsEditing)
            {
                IsEditing = true;
                ShowVersions = false;

                // Set validation options
                if (EditorMode == EditorComponentEditorMode.MultiValueDiffEditor)
                {
                    versionReason = ContentNodeVersioningReason.ValidationRun;
                    versionComment = "Validation changes applied";
                }

                InvokeAsync(StateHasChanged);
            }
        }
    }

    public async Task StartEdit()
    {
        editText = Node.Text;

        if (EditorMode == EditorComponentEditorMode.MultiValueDiffEditor && !string.IsNullOrEmpty(SecondValue))
        {
            secondValueText = SecondValue;
            versionReason = ContentNodeVersioningReason.ValidationRun;
            versionComment = "Validation changes applied";

            // Initialize the lastUpdate variables
            lastUpdateEditText = editText;
            lastUpdateSecondValueText = string.Empty; // Empty means no changes yet
        }

        IsEditing = true;
        ShowVersions = false;

        // Ensure UI updates before proceeding
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleContentChanged()
    {
        // Store latest content
        lastUpdateEditText = editText;
        lastUpdateSecondValueText = secondValueText;
    }

    public async Task OpenAiAssistant()
    {
        var parameters = new DialogParameters
        {
            ["ContentNodeId"] = Node.Id,
            ["NodeContent"] = Node.Text,
            ["NodeDisplayName"] = GetSectionName(),
            ["OnSuggestedContentReceived"] = EventCallback.Factory.Create<string>(this, HandleAiSuggestedContent),
            ["AssociatedGeneratedDocumentId"] = Node.AssociatedGeneratedDocumentId,
            // Pass the IsDarkMode value directly to the dialog
            ["IsDarkMode"] = IsDarkMode
        };

        var dialog = DialogService.Show<ContentNodeCoPilotDialog>("AI Content Assistant", parameters, new DialogOptions
        {
            MaxWidth = MaxWidth.ExtraExtraLarge,
            FullWidth = true,
            CloseButton = true,
            DisableBackdropClick = false,
            Position = DialogPosition.Center
        });

        await dialog.Result;
    }


    private async Task HandleAiSuggestedContent(string suggestedContent)
    {
        if (string.IsNullOrEmpty(suggestedContent) || suggestedContent == Node.Text)
            return;

        // Switch to diff editor mode to show the changes
        EditorMode = EditorComponentEditorMode.MultiValueDiffEditor;
        editText = Node.Text;
        secondValueText = suggestedContent;
        versionReason = ContentNodeVersioningReason.AiEdit;
        versionComment = "AI-assisted edit";

        // Show the editor
        IsEditing = true;
        ShowVersions = false;

        await InvokeAsync(StateHasChanged);
    }

    private string GetSectionName()
    {
        // Try to find a meaningful name for this content node
        if (Node.ParentId.HasValue)
        {
            return "Content Section";
        }
        return "Content";
    }

    private async Task SaveChanges()
    {
        // Determine which text to use (single editor or diff editor)
        string finalText;

        if (EditorMode == EditorComponentEditorMode.SingleValue)
        {
            finalText = !string.IsNullOrEmpty(lastUpdateEditText)
                ? lastUpdateEditText
                : editText;
        }
        else
        {
            finalText = !string.IsNullOrEmpty(lastUpdateSecondValueText)
                ? lastUpdateSecondValueText
                : secondValueText;
        }

        // Check if the text has actually changed
        if (string.IsNullOrWhiteSpace(finalText) || finalText == Node.Text)
        {
            Snackbar.Add("No changes detected - no save performed", Severity.Info);
            IsEditing = false;
            return;
        }

        IsBusy = true;

        try
        {
            // Update the content node text via the API
            var updatedNode = await ContentNodeApiClient.UpdateContentNodeTextAsync(
                Node.Id,
                finalText,
                versionReason,
                string.IsNullOrWhiteSpace(versionComment) ? null : versionComment);

            if (updatedNode != null)
            {
                // Update the local Node object with the updated content
                Node.Text = updatedNode.Text;
                Node.ContentNodeVersionTrackerId = updatedNode.ContentNodeVersionTrackerId;

                Snackbar.Add("Content saved successfully - new version added", Severity.Success);

                // If the editor was set to multi-value diff editor mode, reset it back to single value
                if (EditorMode == EditorComponentEditorMode.MultiValueDiffEditor)
                {
                    EditorMode = EditorComponentEditorMode.SingleValue;
                    SecondValue = null; // Reset the second value
                }

                // Clear any validation data for this node since it's been saved
                ValidationEditorService.ClearEditorData(Node.Id);

                // Notify parent component about the updated node
                await OnNodeUpdated.InvokeAsync(updatedNode);
            }
            else
            {
                Snackbar.Add("Failed to save content", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving content: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsBusy = false;
            IsEditing = false;
            CurrentValidationChange = null; // Clear the current validation change
        }
    }

    private void CancelEdit()
    {
        IsEditing = false;
        editText = Node.Text;
    }

    private async Task AcceptChange()
    {
        if (CurrentValidationChange == null) return;

        IsBusy = true;

        try
        {
            // Update the ApplicationStatus to Accepted
            CurrentValidationChange.ApplicationStatus = ValidationContentNodeApplicationStatus.Accepted;

            // Call the API to update the validation content change status
            var success = await DocumentValidationApiClient.UpdateValidationContentChangeStatusAsync(
                CurrentValidationChange.OriginalValidationExecutionStepContentNodeResultId,
                ValidationContentNodeApplicationStatus.Accepted);

            if (!success)
            {
                Snackbar.Add("Failed to update validation change status to Accepted", Severity.Error);
                return;
            }

            // Get the parent section ID for clearing validation data
            Guid? parentSectionId = CurrentValidationChange.ParentContentNodeId;

            // Clear validation status for this node and its parent section
            ValidationEditorService.ClearValidationStatus(Node.Id, parentSectionId);

            // Then save the changes
            await SaveChanges();

            Snackbar.Add("Validation change accepted successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error accepting validation change: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsBusy = false;
            CurrentValidationChange = null; // Clear the current validation change
        }
    }

    private async Task RejectChange()
    {
        if (CurrentValidationChange == null) return;

        IsBusy = true;

        try
        {
            // Update the validation content change status to Rejected
            var success = await DocumentValidationApiClient.UpdateValidationContentChangeStatusAsync(
                CurrentValidationChange.OriginalValidationExecutionStepContentNodeResultId,
                ValidationContentNodeApplicationStatus.Rejected);

            if (!success)
            {
                Snackbar.Add("Failed to update validation change status to Rejected", Severity.Error);
                return;
            }

            // Get the parent section ID for clearing validation data
            Guid? parentSectionId = CurrentValidationChange.ParentContentNodeId;

            // Clear validation status for this node and its parent section
            ValidationEditorService.ClearValidationStatus(Node.Id, parentSectionId);

            Snackbar.Add("Validation change rejected successfully", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error rejecting validation change: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsBusy = false;
            IsEditing = false;
            CurrentValidationChange = null; // Clear the current validation change
        }
    }

    public async Task ShowVersionHistory()
    {
        // Use the same button to toggle the version history
        if (ShowVersions == true)
        {
            CloseVersions();
            return;
        }

        IsEditing = false;
        ShowVersions = true;

        try
        {
            versions = await ContentNodeApiClient.GetContentNodeVersionsAsync(Node.Id);
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.log", "Error loading versions: " + ex.Message);
            Snackbar.Add($"Error loading versions: {ex.Message}", Severity.Error);
            versions = [];
        }
    }

    private void CloseVersions()
    {
        ShowVersions = false;
        previewVersion = null;
    }

    private void PreviewVersion(ContentNodeVersion version)
    {
        previewVersion = version;
    }

    private async Task RestoreVersion(ContentNodeVersion version)
    {
        if (IsBusy) return;

        IsBusy = true;
        try
        {
            var updatedNode = await ContentNodeApiClient.PromoteContentNodeVersionAsync(Node.Id, version.Id);
            if (updatedNode != null)
            {
                Node.Text = updatedNode.Text;
                Snackbar.Add("Version restored successfully", Severity.Success);
                await OnNodeUpdated.InvokeAsync(updatedNode);
                CloseVersions();
            }
            else
            {
                Snackbar.Add("Failed to restore version", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.log", "Error in RestoreVersion: " + ex.Message);
            Snackbar.Add($"Error restoring version: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsBusy = false;
        }
    }

    public void NotifyParentNodeUpdated(ContentNodeInfo parentNode)
    {
        // Only handle if this is really our parent
        if (Node.ParentId == parentNode.Id)
        {
            // Update any UI elements affected by the parent's state
            InvokeAsync(StateHasChanged);
        }
    }

    private string GetVersionBadgeClass(ContentNodeVersioningReason reason)
    {
        return reason switch
        {
            ContentNodeVersioningReason.ManualEdit => "version-badge-manual",
            ContentNodeVersioningReason.ValidationRun => "version-badge-validation",
            ContentNodeVersioningReason.AiEdit => "version-badge-ai",
            ContentNodeVersioningReason.System => "version-badge-system",
            _ => ""
        };
    }
}
