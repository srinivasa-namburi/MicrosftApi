@using Microsoft.Greenlight.Shared.Contracts.Components
@using Microsoft.Greenlight.Shared.Contracts.DTO.Document

@inject IContentNodeApiClient ContentNodeApiClient
@inject ISnackbar Snackbar
@inject IJSRuntime JS

<div class="content-node-editor">
    @if (!IsEditing && !ShowVersions)
    {
        <div class="content-preview">
            <RenderMultilineText Value="@Node.Text" />
        </div>
    }
    else if (IsEditing)
    {
        <div class="editor-container">
            <EditorComponent @ref="editor"
                             @bind-Value="editText"
                             IsDarkMode="@IsDarkMode"
                             HeightStyle="300px"
                             OnContentChanged="HandleContentChanged" />

            <div class="mt-3 d-flex align-center">
                <MudTextField @bind-Value="versionComment" Label="Comment (optional)" Variant="Variant.Outlined" Class="mr-2 flex-grow-1" />
                <MudSelect T="ContentNodeVersioningReason" @bind-Value="versionReason" Label="Reason" Variant="Variant.Outlined" Class="mr-2">
                    <MudSelectItem Value="ContentNodeVersioningReason.ManualEdit">Manual Edit</MudSelectItem>
                    <MudSelectItem Value="ContentNodeVersioningReason.ValidationRun">Validation</MudSelectItem>
                    <MudSelectItem Value="ContentNodeVersioningReason.AiEdit">AI Edit</MudSelectItem>
                </MudSelect>
            </div>

            <div class="mt-3 d-flex justify-end">
                <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="CancelEdit" Class="mr-2">Cancel</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveChanges" Disabled="@IsBusy">
                    @if (IsBusy)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        <span>Saving...</span>
                    }
                    else
                    {
                        <span>Save</span>
                    }
                </MudButton>
            </div>
        </div>
    }
    else if (ShowVersions)
    {
        <MudContainer MaxWidth="MaxWidth.Large" Class="pa-4">
            <MudCard>
                <MudCardContent>
                    <MudText Typo="Typo.h6" Class="mb-2">Version History</MudText>
                    <MudTable Items="versions" Hover="true" Striped="true">
                        <HeaderContent>
                            <MudTh>Version</MudTh>
                            <MudTh>Time</MudTh>
                            <MudTh>Reason</MudTh>
                            <MudTh>Comment</MudTh>
                            <MudTh>Actions</MudTh>
                        </HeaderContent>
                        <RowTemplate>
                            <MudTd DataLabel="Version">@context.Version</MudTd>
                            <MudTd DataLabel="Time">@context.VersionTimeUtc.ToLocalTime().ToString("g")</MudTd>
                            <MudTd DataLabel="Reason">@context.VersioningReason</MudTd>
                            <MudTd DataLabel="Comment">@context.Comment</MudTd>
                            <MudTd DataLabel="Actions">
                                <MudTooltip Text="Preview this version">
                                    <MudIconButton Icon="@Icons.Material.Filled.Preview" Size="Size.Small" OnClick="@(() => PreviewVersion(context))" />
                                </MudTooltip>
                                <MudTooltip Text="Restore this version">
                                    <MudIconButton Icon="@Icons.Material.Filled.Restore" Size="Size.Small" OnClick="@(() => RestoreVersion(context))" Disabled="@IsBusy" />
                                </MudTooltip>
                            </MudTd>
                        </RowTemplate>
                    </MudTable>
                </MudCardContent>
                @if (previewVersion != null)
                {
                    <MudCardContent>
                        <MudText Typo="Typo.subtitle1">Preview of Version @previewVersion.Version</MudText>
                        <MudText Typo="Typo.body2" Class="mt-2">
                            <RenderMultilineText Value="@previewVersion.Text" />
                        </MudText>
                    </MudCardContent>
                }
                <MudCardActions>
                    <MudButton Variant="Variant.Text" Color="Color.Secondary" OnClick="CloseVersions">Close</MudButton>
                </MudCardActions>
            </MudCard>
        </MudContainer>
    }
</div>

@code {

    [CascadingParameter(Name = "IsDarkMode")]
    public bool IsDarkMode { get; set; }

    [Parameter] public ContentNodeInfo Node { get; set; } = null!;
    [Parameter] public EventCallback<ContentNodeInfo> OnNodeUpdated { get; set; }

    private bool IsEditing { get; set; } = false;
    private bool ShowVersions { get; set; } = false;
    private bool IsBusy { get; set; } = false;
    private string editText = "";
    private string lastUpdateText = "";
    private string versionComment = "";
    private ContentNodeVersioningReason versionReason = ContentNodeVersioningReason.ManualEdit;
    private EditorComponent? editor;
    private List<ContentNodeVersion>? versions;
    private ContentNodeVersion? previewVersion;

    protected override void OnParametersSet()
    {
        editText = Node.Text;
    }

    public async Task StartEdit()
    {
        editText = Node.Text;
        versionComment = "";
        IsEditing = true;
        ShowVersions = false;

        // Wait for rendering to complete and then focus the editor
        await Task.Delay(50);
        StateHasChanged();
    }

    private async Task HandleContentChanged()
    {
        editText = editor!.Value;

        // The editor removes new lines on final close, so we need to keep track of the last update text
        // before the editor closes. This is then used when saving changes instead of the last state of the editor.
        lastUpdateText = editText;
    }

    private async Task SaveChanges()
    {
        if (lastUpdateText == Node.Text)
        {
            IsEditing = false;
            return;
        }

        editText = lastUpdateText;
        IsBusy = true;

        try
        {
            var updatedNode = await ContentNodeApiClient.UpdateContentNodeTextAsync(
                Node.Id,
                editText,
                versionReason,
                string.IsNullOrWhiteSpace(versionComment) ? null : versionComment);

            if (updatedNode != null)
            {
                // Update the UI
                Node.Text = updatedNode.Text;
                Node.ContentNodeVersionTrackerId = updatedNode.ContentNodeVersionTrackerId;

                Snackbar.Add("Content saved successfully - new version added", Severity.Success);
                await OnNodeUpdated.InvokeAsync(updatedNode);
            }
            else
            {
                Snackbar.Add("Failed to save content", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving content: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsBusy = false;
            IsEditing = false;
        }
    }

    private void CancelEdit()
    {
        IsEditing = false;
        editText = Node.Text;
    }

    public async Task ShowVersionHistory()
    {
        // Use the same button to toggle the version history
        if (ShowVersions == true)
        {
            CloseVersions();
            return;
        }

        IsEditing = false;
        ShowVersions = true;

        try
        {
            versions = await ContentNodeApiClient.GetContentNodeVersionsAsync(Node.Id);
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.log", "Error loading versions: " + ex.Message);
            Snackbar.Add($"Error loading versions: {ex.Message}", Severity.Error);
            versions = [];
        }
    }

    private void CloseVersions()
    {
        ShowVersions = false;
        previewVersion = null;
    }

    private void PreviewVersion(ContentNodeVersion version)
    {
        previewVersion = version;
    }

    private async Task RestoreVersion(ContentNodeVersion version)
    {
        if (IsBusy) return;

        IsBusy = true;
        try
        {
            var updatedNode = await ContentNodeApiClient.PromoteContentNodeVersionAsync(Node.Id, version.Id);
            if (updatedNode != null)
            {
                Node.Text = updatedNode.Text;
                Snackbar.Add("Version restored successfully", Severity.Success);
                await OnNodeUpdated.InvokeAsync(updatedNode);
                CloseVersions();
            }
            else
            {
                Snackbar.Add("Failed to restore version", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("console.log", "Error in RestoreVersion: " + ex.Message);
            Snackbar.Add($"Error restoring version: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsBusy = false;
        }
    }

    private string GetVersionBadgeClass(ContentNodeVersioningReason reason)
    {
        return reason switch
        {
            ContentNodeVersioningReason.ManualEdit => "version-badge-manual",
            ContentNodeVersioningReason.ValidationRun => "version-badge-validation",
            ContentNodeVersioningReason.AiEdit => "version-badge-ai",
            ContentNodeVersioningReason.System => "version-badge-system",
            _ => ""
        };
    }
}
