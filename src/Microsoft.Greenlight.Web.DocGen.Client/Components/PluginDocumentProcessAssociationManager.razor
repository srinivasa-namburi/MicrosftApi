@using Microsoft.Extensions.Logging
@using Microsoft.Greenlight.Shared.Contracts.DTO.Plugins
@using Microsoft.Greenlight.Web.Shared.ServiceClients
@using Microsoft.Greenlight.Shared.Contracts.DTO.Configuration

@inject IPluginApiClient PluginApiClient
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject ISnackbar Snackbar
@inject ILogger<PluginDocumentProcessAssociationManager> Logger
@inject IDialogService DialogService

<MudPaper Class="pa-4">
    <MudGrid>
        <MudItem xs="12">
            <MudText Typo="Typo.h6">@Title</MudText>
            
            <MudTable Items="AssociatedItems" Hover="true" Striped="true" Dense="true">
                <HeaderContent>
                    <MudTh>@SelectionColumnLabel</MudTh>
                    <MudTh>Version</MudTh>
                    <MudTh>Keep on Latest</MudTh>
                    <MudTh>Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd>@context.Name</MudTd>
                    <MudTd>
                        <MudSelect T="string" Dense="true" 
                                  Value="@context.Version" ValueChanged="@((string val) => OnVersionChanged(context, val))" Disabled="context.KeepOnLatestVersion">
                            @if (context.AvailableVersions != null)
                            {
                                @foreach (var version in context.AvailableVersions)
                                {
                                    <MudSelectItem Value="@version">@version</MudSelectItem>
                                }
                            }
                        </MudSelect>
                    </MudTd>
                    <MudTd>
                        <MudCheckBox Value="context.KeepOnLatestVersion" T="bool" 
                                     ValueChanged="@((bool val) => OnKeepOnLatestChanged(context, val))" />
                    </MudTd>
                    <MudTd>
                        @if (context.HasUnsavedChanges)
                        {
                            <MudIconButton Icon="@Icons.Material.Filled.Save" Color="Color.Primary" 
                                           OnClick="() => SaveAssociationChanges(context)" Size="Size.Small" />
                        }
                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" 
                                     OnClick="() => ConfirmDisassociate(context)" Size="Size.Small" />
                    </MudTd>
                </RowTemplate>
                <NoRecordsContent>
                    <MudText>No @(PluginCentric ? "document processes" : "plugins") associated.</MudText>
                </NoRecordsContent>
            </MudTable>
            
            <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="OpenAssociateDialog" Class="mt-3">
                @(PluginCentric ? "Associate Document Process" : "Associate Plugin")
            </MudButton>
        </MudItem>
    </MudGrid>
</MudPaper>

@code {
    [Parameter] public Guid? PluginId { get; set; }
    [Parameter] public Guid? DocumentProcessId { get; set; }
    [Parameter] public bool PluginCentric { get; set; } = true;
    [Parameter] public string Title { get; set; } = "Associated Items";
    [Parameter] public string SelectionColumnLabel { get; set; } = "Name";
    [Parameter] public EventCallback OnAssociationChanged { get; set; }
    
    private List<AssociationViewModel> AssociatedItems { get; set; } = new();
    private List<SelectableItem> AvailableItems { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await RefreshAssociations();
    }
    
    protected override async Task OnParametersSetAsync()
    {
        await RefreshAssociations();
    }

    private string GetVersionString(McpPluginVersionInfo? version)
        => version != null ? $"{version.Major}.{version.Minor}.{version.Patch}" : "Unknown Version";

    private async Task RefreshAssociations()
    {
        try
        {
            if (PluginCentric && PluginId.HasValue)
            {
                var associations = await PluginApiClient.GetPluginAssociationsByPluginIdAsync(PluginId.Value);
                AssociatedItems = associations.Select(a => new AssociationViewModel
                {
                    Id = a.AssociationId,
                    DocumentProcessId = a.DocumentProcessId,
                    PluginId = a.PluginId,
                    Name = a.Name,
                    Version = a.KeepOnLatestVersion
                        ? (a.AvailableVersions.FirstOrDefault() != null ? $"{a.AvailableVersions.First().Major}.{a.AvailableVersions.First().Minor}.{a.AvailableVersions.First().Patch}" : string.Empty)
                        : GetVersionString(a.CurrentVersion),
                    AvailableVersions = a.AvailableVersions.Select(v => $"{v.Major}.{v.Minor}.{v.Patch}").ToList(),
                    KeepOnLatestVersion = a.KeepOnLatestVersion,
                    OriginalVersion = a.KeepOnLatestVersion
                        ? (a.AvailableVersions.FirstOrDefault() != null ? $"{a.AvailableVersions.First().Major}.{a.AvailableVersions.First().Minor}.{a.AvailableVersions.First().Patch}" : string.Empty)
                        : GetVersionString(a.CurrentVersion),
                    OriginalKeepOnLatestVersion = a.KeepOnLatestVersion
                }).ToList();

                var allProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
                var associatedProcessIds = AssociatedItems.Select(a => a.DocumentProcessId).ToHashSet();
                AvailableItems = allProcesses
                    .Where(p => !associatedProcessIds.Contains(p.Id))
                    .Select(p => new SelectableItem
                    {
                        Id = p.Id,
                        Name = p.ShortName,
                        IsSelected = false
                    })
                    .ToList();
            }
            else if (!PluginCentric && DocumentProcessId.HasValue)
            {
                var associations = await PluginApiClient.GetPluginAssociationsByDocumentProcessIdAsync(DocumentProcessId.Value);
                AssociatedItems = associations.Select(a => new AssociationViewModel
                {
                    Id = a.AssociationId,
                    DocumentProcessId = a.DocumentProcessId,
                    PluginId = a.PluginId,
                    Name = a.Name,
                    Version = a.KeepOnLatestVersion
                        ? (a.AvailableVersions.FirstOrDefault() != null ? $"{a.AvailableVersions.First().Major}.{a.AvailableVersions.First().Minor}.{a.AvailableVersions.First().Patch}" : string.Empty)
                        : GetVersionString(a.CurrentVersion),
                    AvailableVersions = a.AvailableVersions.Select(v => $"{v.Major}.{v.Minor}.{v.Patch}").ToList(),
                    KeepOnLatestVersion = a.KeepOnLatestVersion,
                    OriginalVersion = a.KeepOnLatestVersion
                        ? (a.AvailableVersions.FirstOrDefault() != null ? $"{a.AvailableVersions.First().Major}.{a.AvailableVersions.First().Minor}.{a.AvailableVersions.First().Patch}" : string.Empty)
                        : GetVersionString(a.CurrentVersion),
                    OriginalKeepOnLatestVersion = a.KeepOnLatestVersion
                }).ToList();

                var allPlugins = await PluginApiClient.GetAllMcpPluginsAsync();
                var associatedPluginIds = AssociatedItems.Select(a => a.PluginId).ToHashSet();
                AvailableItems = allPlugins
                    .Where(p => !associatedPluginIds.Contains(p.Id))
                    .Select(p => new SelectableItem
                    {
                        Id = p.Id,
                        Name = p.Name,
                        IsSelected = false
                    })
                    .ToList();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error refreshing associations");
            Snackbar.Add($"Error loading associations: {ex.Message}", Severity.Error);
        }
    }

    private async Task OnVersionChanged(AssociationViewModel association, string newValue)
    {
        association.Version = newValue;
        await SaveAssociationChanges(association);
    }
    
    private async Task OnKeepOnLatestChanged(AssociationViewModel association, bool newValue)
    {
        association.KeepOnLatestVersion = newValue;
        if (!newValue)
        {
            // Set Version to the current version or first available version
            if (!string.IsNullOrWhiteSpace(association.OriginalVersion) && association.OriginalVersion != "Unknown Version")
            {
                association.Version = association.OriginalVersion;
            }
            else if (association.AvailableVersions != null && association.AvailableVersions.Count > 0)
            {
                association.Version = association.AvailableVersions[0];
            }
            else
            {
                association.Version = string.Empty;
            }
        }
        await SaveAssociationChanges(association);
    }

    private void OpenAssociateDialog()
    {
        if (AvailableItems.Count == 0)
        {
            Snackbar.Add($"No {(PluginCentric ? "document processes" : "plugins")} available to associate.", Severity.Info);
            return;
        }
        var parameters = new DialogParameters
        {
            { "Title", PluginCentric ? "Associate Document Process" : "Associate Plugin" },
            { "Items", AvailableItems },
            { "SelectionLabel", PluginCentric ? "Document Processes" : "Plugins" }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = DialogService.Show<SelectItemsDialog>(
            PluginCentric ? "Associate Document Process" : "Associate Plugin", 
            parameters, options);
        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Cancelled && result.Result.Data is List<SelectableItem> selectedItems)
            {
                await AssociateSelectedItems(selectedItems.Where(i => i.IsSelected).ToList());
            }
        });
    }

    private async Task AssociateSelectedItems(List<SelectableItem> selectedItems)
    {
        if (!selectedItems.Any()) return;
        try
        {
            foreach (var item in selectedItems)
            {
                if (PluginCentric && PluginId.HasValue)
                {
                    var plugin = await PluginApiClient.GetMcpPluginByIdAsync(PluginId.Value);
                    var latestVersion = plugin.LatestVersion;
                    if (latestVersion == null)
                    {
                        Snackbar.Add($"Plugin {plugin.Name} has no versions.", Severity.Warning);
                        continue;
                    }
                    await PluginApiClient.AssociateMcpPluginWithDocumentProcessAsync(PluginId.Value, item.Id, latestVersion);
                }
                else if (!PluginCentric && DocumentProcessId.HasValue)
                {
                    var plugin = await PluginApiClient.GetMcpPluginByIdAsync(item.Id);
                    var latestVersion = plugin.LatestVersion;
                    if (latestVersion == null)
                    {
                        Snackbar.Add($"Plugin {plugin.Name} has no versions.", Severity.Warning);
                        continue;
                    }
                    await PluginApiClient.AssociateMcpPluginWithDocumentProcessAsync(plugin.Id, DocumentProcessId.Value, latestVersion);
                }
            }
            await RefreshAssociations();
            await OnAssociationChanged.InvokeAsync();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error associating items");
            Snackbar.Add($"Error associating items: {ex.Message}", Severity.Error);
        }
    }

    private void ConfirmDisassociate(AssociationViewModel association)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", $"Are you sure you want to disassociate this {(PluginCentric ? "document process" : "plugin")}?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Confirm Disassociation", parameters, options);
        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Cancelled)
            {
                await DisassociateItem(association);
                await InvokeAsync(StateHasChanged);
            }
        });
    }

    private async Task DisassociateItem(AssociationViewModel association)
    {
        try
        {
            if (PluginCentric)
            {
                await PluginApiClient.DisassociateMcpPluginFromDocumentProcessAsync(PluginId.Value, association.DocumentProcessId);
            }
            else
            {
                await PluginApiClient.DisassociateMcpPluginFromDocumentProcessAsync(association.PluginId, DocumentProcessId.Value);
            }
            Snackbar.Add("Successfully disassociated.", Severity.Success);
            await RefreshAssociations();
            await OnAssociationChanged.InvokeAsync();
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error disassociating item");
            Snackbar.Add($"Error disassociating: {ex.Message}", Severity.Error);
        }
    }

    private async Task SaveAssociationChanges(AssociationViewModel association)
    {
        try
        {
            McpPluginVersionInfo? selectedVersion = null;
            if (!association.KeepOnLatestVersion)
            {
                var versionParts = association.Version.Split('.');
                if (versionParts.Length != 3 ||
                    !int.TryParse(versionParts[0], out int major) ||
                    !int.TryParse(versionParts[1], out int minor) ||
                    !int.TryParse(versionParts[2], out int patch))
                {
                    Snackbar.Add("Invalid version format. Expected format: Major.Minor.Patch", Severity.Error);
                    return;
                }
                selectedVersion = new McpPluginVersionInfo { Major = major, Minor = minor, Patch = patch };
            }
            var update = new McpPluginAssociationInfo
            {
                AssociationId = association.Id,
                PluginId = association.PluginId,
                DocumentProcessId = association.DocumentProcessId,
                KeepOnLatestVersion = association.KeepOnLatestVersion,
                CurrentVersion = selectedVersion,
                Name = association.Name
            };
            await PluginApiClient.UpdateMcpPluginAssociationAsync(
                association.DocumentProcessId, association.PluginId, update);
            association.OriginalVersion = association.Version;
            association.OriginalKeepOnLatestVersion = association.KeepOnLatestVersion;
            Snackbar.Add("Association updated successfully.", Severity.Success);
            await RefreshAssociations();
            await OnAssociationChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error saving association changes");
            Snackbar.Add($"Error saving association changes: {ex.Message}", Severity.Error);
        }
    }

    public class AssociationViewModel
    {
        public Guid Id { get; set; }
        public Guid PluginId { get; set; }
        public Guid DocumentProcessId { get; set; }
        public string Name { get; set; } = string.Empty;
        public string Version { get; set; } = string.Empty;
        public List<string>? AvailableVersions { get; set; }
        public bool KeepOnLatestVersion { get; set; } = false;
        public string? OriginalVersion { get; set; }
        public bool OriginalKeepOnLatestVersion { get; set; }
        public bool HasUnsavedChanges => Version != OriginalVersion || KeepOnLatestVersion != OriginalKeepOnLatestVersion;
    }

    public class SelectableItem
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public bool IsSelected { get; set; }
    }
}