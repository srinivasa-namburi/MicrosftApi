@using System.Text.Json
@inject IDocumentOutlineApiClient DocumentOutlineApiClient
@inject IDialogService DialogService
@inject ISnackbar Snackbar

<MudDialog Options="new DialogOptions { MaxWidth = MaxWidth.Medium }">
    <TitleContent>
        <MudText Typo="Typo.h6">@((IsEditMode ? "Edit Document Outline" : "Add Document Outline"))</MudText>
    </TitleContent>
    <DialogContent>
        @if (CurrentDocumentOutline != null)
        {
            <!-- Import Outline Button -->
            <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="ShowImportOutlineSection">
                Import Outline from Text
            </MudButton>

            <!-- Import Outline TextArea -->
            @if (ShowImportSection)
            {
                <MudPaper Class="pa-4 mt-4">
                    <MudTextField @bind-Value="OutlineText" Label="Paste Outline Text Here" Lines="10" FullWidth="true" 
                                  HelperText="Format: Use numbered sections like '1. Title', '1.1. Subtitle', '2.1.1. Sub-subtitle', etc." />
                    <MudStack Row="true" Spacing="2" Class="mt-2">
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ProcessOutlineText" Disabled="_isProcessing">
                            @if (_isProcessing)
                            {
                                <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                                <span>Processing...</span>
                            }
                            else
                            {
                                <span>Process</span>
                            }
                        </MudButton>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="HideImportOutlineSection" Disabled="_isProcessing">Cancel</MudButton>
                    </MudStack>
                </MudPaper>
            }

            <!-- Import Outline TextArea Confirmation Section -->
            @if (ShowImportConfirmationSection)
            {
                <MudPaper Class="pa-4 mt-4">
                    <MudText Typo="Typo.h6">Import Outline</MudText>
                    <MudText>You are about to import an outline with @TotalImportedItems sections. This will replace your current outline, and any custom section prompts and customizations will be cleared.</MudText>
                    <MudStack Row="true" Spacing="2" Class="mt-2">
                        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ConfirmImport">Import</MudButton>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="CancelImport">Cancel</MudButton>
                    </MudStack>
                </MudPaper>
            }

            <MudTreeView Items="@ConvertToTreeItemData(CurrentDocumentOutline.OutlineItems)" Hover="true" T="DocumentOutlineItemInfo">
                <ItemTemplate Context="item">
                    <MudTreeViewItem Items="@item.Children" Text="@item.Value.SectionTitle" Expanded T="DocumentOutlineItemInfo">
                        <BodyContent>
                            <!-- Delegating UI rendering of each item to the DocumentOutlineItemComponent -->
                            <DocumentOutlineItemComponent Item="@item.Value"
                                                          IsPasteDisabled="@(CopiedDocumentOutlineItemInfo is null)"
                                                          IsMoveUpDisabled="IsMoveUpDisabled(item.Value)"
                                                          IsMoveDownDisabled="IsMoveDownDisabled(item.Value)"
                                                          IsDeleteDisabled="IsLastItem(item.Value)"
                                                          GetTooltipText="GetTooltipText"
                                                          OnItemActionRequested="HandleItemActionRequested" />
                        </BodyContent>
                    </MudTreeViewItem>
                </ItemTemplate>
            </MudTreeView>
        }
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="SaveDocumentOutline">Save</MudButton>
        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="Cancel">Cancel</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public EventCallback<Guid> OnDocumentOutlineSaved { get; set; }
    [Parameter] public Guid DocumentOutlineId { get; set; }
    [Parameter] public bool IsEditMode { get; set; }

    private DocumentOutlineInfo? CurrentDocumentOutline { get; set; }
    private DocumentOutlineInfo? OriginalDocumentOutline { get; set; }

    private DocumentOutlineItemInfo? CopiedDocumentOutlineItemInfo { get; set; }

    private bool ShowImportSection { get; set; } = false;
    private bool ShowImportConfirmationSection { get; set; } = false;
    private bool _isProcessing { get; set; } = false;

    private string OutlineText { get; set; } = string.Empty;

    private List<DocumentOutlineItemInfo> ImportedOutlineItems { get; set; } = new();
    private int TotalImportedItems { get; set; } = 0;

    protected override async Task OnParametersSetAsync()
    {
        if (DocumentOutlineId != Guid.Empty)
        {
            OriginalDocumentOutline = await DocumentOutlineApiClient.GetDocumentOutlineByIdAsync(DocumentOutlineId);

            // Normalize to 0-based in UI; OrderIndex from DB is 1-based, but the UI compares by list position and rewrites on save
            int orderIndex = 0;
            foreach (DocumentOutlineItemInfo item in OriginalDocumentOutline.OutlineItems)
            {
                item.OrderIndex = orderIndex;
                UpdateOrderIndex(item);
                orderIndex++;
            }

            CurrentDocumentOutline = CloneDocumentOutline(OriginalDocumentOutline);
        }
    }

    private void ShowImportOutlineSection()
    {
        ShowImportSection = true;
        ShowImportConfirmationSection = false;
        StateHasChanged();
    }

    private void HideImportOutlineSection()
    {
        ShowImportSection = false;
        ImportedOutlineItems = new();
        TotalImportedItems = 0;
        StateHasChanged();
    }

    private void CancelImport()
    {
        ShowImportConfirmationSection = false;
        OutlineText = string.Empty;
        ImportedOutlineItems = new();
        TotalImportedItems = 0;
        StateHasChanged();
    }

    private async Task ProcessOutlineText()
    {
        if (string.IsNullOrWhiteSpace(OutlineText))
        {
            Snackbar.Add("Please enter some outline text to process.", Severity.Warning);
            return;
        }

        _isProcessing = true;
        StateHasChanged();

        try
        {
            var newOutlineItems = await DocumentOutlineApiClient.GenerateOutlineFromTextAsync(OutlineText);

            if (newOutlineItems != null && newOutlineItems.Any())
            {
                ImportedOutlineItems = newOutlineItems;
                TotalImportedItems = CountTotalItems(ImportedOutlineItems);
                ShowImportConfirmationSection = true;
                ShowImportSection = false;
                Snackbar.Add($"Successfully parsed {TotalImportedItems} outline sections.", Severity.Success);
            }
            else
            {
                ShowImportSection = false;
                Snackbar.Add("Unable to parse the outline text. Please check the format and try again. Use numbered sections like '1. Title', '1.1. Subtitle', etc.", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error processing outline text: {ex.Message}", Severity.Error);
            ShowImportSection = false;
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }

    private int CountTotalItems(List<DocumentOutlineItemInfo> items)
    {
        int count = 0;
        foreach (var item in items)
        {
            count += 1;
            if (item.Children != null && item.Children.Any())
            {
                count += CountTotalItems(item.Children);
            }
        }
        return count;
    }

    private async Task ConfirmImport()
    {
        CurrentDocumentOutline.OutlineItems = ImportedOutlineItems;
        ShowImportConfirmationSection = false;
        await InvokeAsync(StateHasChanged);
    }

    private DocumentOutlineInfo? CloneDocumentOutline(DocumentOutlineInfo? documentOutline)
    {
        return documentOutline != null ? JsonSerializer.Deserialize<DocumentOutlineInfo>(JsonSerializer.Serialize(documentOutline)) : null;
    }

    private async Task SaveDocumentOutline()
    {
        if (CurrentDocumentOutline != null)
        {
            int orderIndex = 0;
            foreach (DocumentOutlineItemInfo item in CurrentDocumentOutline.OutlineItems)
            {
                item.OrderIndex = orderIndex;
                UpdateOrderIndex(item);
                orderIndex++;
            }
            var changeRequest = CreateChangeRequest(OriginalDocumentOutline, CurrentDocumentOutline);
            await DocumentOutlineApiClient.UpdateDocumentOutlineAsync(OriginalDocumentOutline.Id, changeRequest);
            await OnDocumentOutlineSaved.InvokeAsync(CurrentDocumentOutline.Id);
            MudDialog.Close();
        }
    }

    private DocumentOutlineChangeRequest CreateChangeRequest(DocumentOutlineInfo? originalOutline, DocumentOutlineInfo? currentOutline)
    {
        var changeRequest = new DocumentOutlineChangeRequest
            {
                DocumentOutlineId = originalOutline?.Id ?? Guid.Empty
            };

        if (originalOutline == null || currentOutline == null)
        {
            changeRequest.DocumentOutlineInfo = currentOutline;
            return changeRequest;
        }

        if (!originalOutline.Equals(currentOutline))
        {
            changeRequest.DocumentOutlineInfo = currentOutline;
        }

        var changedItems = new List<DocumentOutlineItemInfo>();
        var deletedItems = new List<DocumentOutlineItemInfo>();

        CompareItems(originalOutline.OutlineItems, currentOutline.OutlineItems, changedItems, deletedItems);

        changeRequest.ChangedOutlineItems = changedItems;
        changeRequest.DeletedOutlineItems = deletedItems;

        return changeRequest;
    }

    private void CompareItems(List<DocumentOutlineItemInfo> originalItems, List<DocumentOutlineItemInfo> currentItems, List<DocumentOutlineItemInfo> changedItems, List<DocumentOutlineItemInfo> deletedItems)
    {
        var originalItemIds = originalItems.Select(o => o.Id).ToHashSet();
        var currentItemIds = currentItems.Select(c => c.Id).ToHashSet();
        var originalPositions = originalItems.Select((item, index) => new { item.Id, index }).ToDictionary(x => x.Id, x => x.index);

        foreach (var currentItem in currentItems)
        {
            var originalItem = originalItems.FirstOrDefault(o => o.Id == currentItem.Id);

            if (originalItem == null || !currentItem.Equals(originalItem))
            {
                changedItems.Add(currentItem);
            }
            else
            {
                if (originalPositions.TryGetValue(currentItem.Id, out var originalIndex) && originalIndex != currentItems.IndexOf(currentItem))
                {
                    changedItems.Add(currentItem);
                }
            }

            CompareItems(originalItem?.Children ?? new List<DocumentOutlineItemInfo>(), currentItem.Children, changedItems, deletedItems);
        }

        foreach (var originalItem in originalItems)
        {
            if (!currentItemIds.Contains(originalItem.Id))
            {
                deletedItems.Add(originalItem);
                List<DocumentOutlineItemInfo> allChildrenOfOriginalItem = GetAllChildrenRecursive(originalItem);
                deletedItems.AddRange(allChildrenOfOriginalItem);
            }
        }
    }

    private List<DocumentOutlineItemInfo> GetAllChildrenRecursive(DocumentOutlineItemInfo item)
    {
        var allChildren = new List<DocumentOutlineItemInfo>();

        foreach (var child in item.Children)
        {
            allChildren.Add(child);
            allChildren.AddRange(GetAllChildrenRecursive(child));
        }

        return allChildren;
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }

    // Unified item action handler:
    private void HandleItemActionRequested((DocumentOutlineItemInfo item, DocumentOutlineItemAction action) request)
    {
        var (item, action) = request;
        switch (action)
        {
            case DocumentOutlineItemAction.AddChild:
                AddChildItem(item);
                break;
            case DocumentOutlineItemAction.AddAbove:
                AddItemAbove(item);
                break;
            case DocumentOutlineItemAction.AddBelow:
                AddItemBelow(item);
                break;
            case DocumentOutlineItemAction.Copy:
                CopyItem(item);
                break;
            case DocumentOutlineItemAction.PasteAsChild:
                PasteAsChildItem(item);
                break;
            case DocumentOutlineItemAction.PasteAbove:
                PasteItemAtSameLevel(item, true);
                break;
            case DocumentOutlineItemAction.PasteBelow:
                PasteItemAtSameLevel(item, false);
                break;
            case DocumentOutlineItemAction.MoveUp:
                MoveItemUp(item);
                break;
            case DocumentOutlineItemAction.MoveDown:
                MoveItemDown(item);
                break;
            case DocumentOutlineItemAction.Delete:
                DeleteItem(item);
                break;
        }

        StateHasChanged();
    }

    private void CopyItem(DocumentOutlineItemInfo item)
    {
        Guid newId = Guid.NewGuid();
        CopiedDocumentOutlineItemInfo = new DocumentOutlineItemInfo
            {
                Id = newId,
                SectionNumber = item.SectionNumber,
                SectionTitle = item.SectionTitle,
                PromptInstructions = item.PromptInstructions,
                Level = item.Level,
                ParentId = item.ParentId,
                DocumentOutlineId = item.DocumentOutlineId,
                Children = CopyItemRecursiveHelper(item.Children, newId, item.Level),
                OrderIndex = item.OrderIndex,
            };
    }

    private List<DocumentOutlineItemInfo> CopyItemRecursiveHelper(List<DocumentOutlineItemInfo> children, Guid parentId, int parentLevel)
    {
        if (children == null)
        {
            return null;
        }

        var copiedChildren = new List<DocumentOutlineItemInfo>();
        foreach (var child in children)
        {
            Guid newId = Guid.NewGuid();
            var copiedChild = new DocumentOutlineItemInfo
                {
                    Id = newId,
                    SectionNumber = child.SectionNumber,
                    SectionTitle = child.SectionTitle,
                    PromptInstructions = child.PromptInstructions,
                    Level = parentLevel + 1,
                    ParentId = parentId,
                    DocumentOutlineId = child.DocumentOutlineId,
                    Children = CopyItemRecursiveHelper(child.Children, newId, parentLevel + 1),
                    OrderIndex = child.OrderIndex,
                };
            copiedChildren.Add(copiedChild);
        }
        return copiedChildren;
    }

    private void PasteAsChildItem(DocumentOutlineItemInfo parentItem)
    {
        if (CopiedDocumentOutlineItemInfo == null) return;

        Guid newId = Guid.NewGuid();
        CopiedDocumentOutlineItemInfo.Id = newId;
        CopiedDocumentOutlineItemInfo.ParentId = parentItem.Id;
        CopiedDocumentOutlineItemInfo.Level = parentItem.Level + 1;
        CopiedDocumentOutlineItemInfo.DocumentOutlineId = null;
        CopiedDocumentOutlineItemInfo.Children = CopyItemRecursiveHelper(CopiedDocumentOutlineItemInfo.Children, newId, CopiedDocumentOutlineItemInfo.Level);

        parentItem.Children.Add(CopiedDocumentOutlineItemInfo);
    }

    private void PasteItemAtSameLevel(DocumentOutlineItemInfo item, bool isAbove)
    {
        if (CopiedDocumentOutlineItemInfo == null) return;

        int pasteIndexAddend = isAbove ? 0 : 1;
        Guid newId = Guid.NewGuid();
        CopiedDocumentOutlineItemInfo.Id = newId;
        CopiedDocumentOutlineItemInfo.Level = item.Level;

        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            CopiedDocumentOutlineItemInfo.DocumentOutlineId = null;
            CopiedDocumentOutlineItemInfo.ParentId = parentId;
            CopiedDocumentOutlineItemInfo.Children = CopyItemRecursiveHelper(CopiedDocumentOutlineItemInfo.Children, newId, CopiedDocumentOutlineItemInfo.Level);

            int indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
            parentOutlineItemInfo.Children.Insert(indexOfItem + pasteIndexAddend, CopiedDocumentOutlineItemInfo);
        }
        else
        {
            CopiedDocumentOutlineItemInfo.DocumentOutlineId = item.DocumentOutlineId;
            CopiedDocumentOutlineItemInfo.ParentId = null;
            CopiedDocumentOutlineItemInfo.Children = CopyItemRecursiveHelper(CopiedDocumentOutlineItemInfo.Children, newId, CopiedDocumentOutlineItemInfo.Level);

            int indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
            CurrentDocumentOutline.OutlineItems.Insert(indexOfItem + pasteIndexAddend, CopiedDocumentOutlineItemInfo);
        }
    }

    private void AddItemAbove(DocumentOutlineItemInfo item)
    {
        var newItem = new DocumentOutlineItemInfo
            {
                Id = Guid.NewGuid(),
                ParentId = item.ParentId,
                Level = item.Level,
                SectionTitle = ""
            };

        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            int indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
            parentOutlineItemInfo.Children.Insert(indexOfItem, newItem);
        }
        else
        {
            int indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
            newItem.DocumentOutlineId = CurrentDocumentOutline.Id;
            CurrentDocumentOutline.OutlineItems.Insert(indexOfItem, newItem);
        }
    }

    private void AddItemBelow(DocumentOutlineItemInfo item)
    {
        var newItem = new DocumentOutlineItemInfo
            {
                Id = Guid.NewGuid(),
                ParentId = item.ParentId,
                Level = item.Level,
                SectionTitle = ""
            };
        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            int indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
            parentOutlineItemInfo.Children.Insert(indexOfItem + 1, newItem);
        }
        else
        {
            int indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
            newItem.DocumentOutlineId = CurrentDocumentOutline.Id;
            CurrentDocumentOutline.OutlineItems.Insert(indexOfItem + 1, newItem);
        }
    }

    private bool IsMoveUpDisabled(DocumentOutlineItemInfo item)
    {
        int indexOfItem;
        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
        }
        else
        {
            indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
        }
        return indexOfItem == 0;
    }

    private bool IsMoveDownDisabled(DocumentOutlineItemInfo item)
    {
        int indexOfItem;
        int maxIndex;
        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
            maxIndex = parentOutlineItemInfo.Children.Count;
        }
        else
        {
            indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
            maxIndex = CurrentDocumentOutline.OutlineItems.Count;
        }
        return indexOfItem == maxIndex - 1;
    }

    private void MoveItemUp(DocumentOutlineItemInfo item)
    {
        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            int indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
            parentOutlineItemInfo.Children.Remove(item);
            parentOutlineItemInfo.Children.Insert(indexOfItem - 1, item);
        }
        else
        {
            int indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
            CurrentDocumentOutline.OutlineItems.Remove(item);
            CurrentDocumentOutline.OutlineItems.Insert(indexOfItem - 1, item);
        }
    }

    private void MoveItemDown(DocumentOutlineItemInfo item)
    {
        if (item.ParentId is Guid parentId)
        {
            var parentOutlineItemInfo = FindItemByIdRecursive(CurrentDocumentOutline.OutlineItems, parentId);
            int indexOfItem = parentOutlineItemInfo.Children.IndexOf(item);
            parentOutlineItemInfo.Children.Remove(item);
            parentOutlineItemInfo.Children.Insert(indexOfItem + 1, item);
        }
        else
        {
            int indexOfItem = CurrentDocumentOutline.OutlineItems.IndexOf(item);
            CurrentDocumentOutline.OutlineItems.Remove(item);
            CurrentDocumentOutline.OutlineItems.Insert(indexOfItem + 1, item);
        }
    }

    private DocumentOutlineItemInfo? FindItemByIdRecursive(List<DocumentOutlineItemInfo> rootItemList, Guid itemId)
    {
        foreach (var i in rootItemList)
        {
            if (i.Id == itemId)
            {
                return i;
            }

            var foundItem = FindItemByIdRecursive(i.Children, itemId);
            if (foundItem != null)
            {
                return foundItem;
            }
        }

        return null;
    }

    private void AddChildItem(DocumentOutlineItemInfo parentItem)
    {
        var newItem = new DocumentOutlineItemInfo
            {
                Id = Guid.NewGuid(),
                ParentId = parentItem.Id,
                Level = parentItem.Level + 1,
                SectionTitle = ""
            };
        parentItem.Children.Add(newItem);
    }

    private bool IsLastItem(DocumentOutlineItemInfo item)
    {
        return (CurrentDocumentOutline.OutlineItems.Contains(item) && CurrentDocumentOutline.OutlineItems.Count == 1);
    }

    private void DeleteItem(DocumentOutlineItemInfo item)
    {
        if (CurrentDocumentOutline != null)
        {
            DeleteItemHelperRecursive(CurrentDocumentOutline.OutlineItems, item);
        }
    }

    private bool DeleteItemHelperRecursive(List<DocumentOutlineItemInfo> items, DocumentOutlineItemInfo itemToDelete)
    {
        foreach (var it in items.ToList())
        {
            if (it.Id == itemToDelete.Id)
            {
                items.Remove(it);
                return true;
            }

            if (DeleteItemHelperRecursive(it.Children, itemToDelete))
            {
                return true;
            }
        }

        return false;
    }

    private void UpdateOrderIndex(DocumentOutlineItemInfo parentItem)
    {
        List<DocumentOutlineItemInfo> children = parentItem.Children;

        for (int i = 0; i < children.Count; i++)
        {
            children[i].OrderIndex = i;
            UpdateOrderIndex(children[i]);
        }
    }

    private string GetTooltipText(DocumentOutlineItemInfo item)
    {
        return "Id: " + item.Id.ToString() +
               "\n Parent Id: " + item.ParentId.ToString() +
               "\n Level: " + item.Level.ToString() +
               "\n DocumentOutlineId: " + item.DocumentOutlineId.ToString() +
               "\n OrderIndex: " + item.OrderIndex;
    }

    private IReadOnlyCollection<TreeItemData<DocumentOutlineItemInfo>> ConvertToTreeItemData(IEnumerable<DocumentOutlineItemInfo> items)
    {
        return items.Select(item => new TreeItemData<DocumentOutlineItemInfo>
        {
            Value = item,
            Children = ConvertToTreeItemData(item.Children).ToList(),
            Text = item.SectionTitle,
            Expanded = false
        }).ToList();
    }
}
