@using Microsoft.Greenlight.Shared.Contracts.DTO.Document

@inject IContentNodeApiClient ContentNodeApiClient
@inject ValidationEditorService ValidationEditorService

@code {
    [CascadingParameter]
    private GeneratedDocumentDisplay? ParentDocumentDisplay { get; set; }

    [Parameter] public ContentNodeInfo? Node { get; set; }
    [Parameter] public bool Recursive { get; set; } = false;
    [Parameter] public bool EnableReferenceFrontend { get; set; } = false;

    private ContentNodeSystemItemInfo? SystemItem { get; set; }
    private bool ShowSystemInfo = false;
    private bool IsPanelExpanded = false;
    private bool IsLoadingSystemInfo = false;
    private bool HasVersions = false;

    private EditorComponentEditorMode EditorMode { get; set; } = EditorComponentEditorMode.SingleValue;
    private ContentNodeBodyTextComponent? BodyTextComponent;

    protected override async Task OnInitializedAsync()
    {
        // Check if body text node has versions
        if (Node?.Type == ContentNodeType.BodyText && Node.ContentNodeVersionTrackerId.HasValue)
        {
            try
            {
                HasVersions = await ContentNodeApiClient.HasPreviousVersionsAsync(Node.Id);
            }
            catch
            {
                HasVersions = false;
            }
        }

        // Subscribe to validation status changes
        ValidationEditorService.ValidationStatusChanged += HandleValidationStatusChanged;
    }

    private async void HandleValidationStatusChanged(Guid contentNodeId)
    {
        // If this notification is for a child node of our current node
        if (Node?.Children.Any(child => child.Id == contentNodeId) == true)
        {
            // Force UI update to reevaluate the HasPendingValidationChanges
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// Renders the validation UI for the content node.
    /// The content node expected here is the section heading node.
    /// </summary>
    /// <param name="node">Section requesting changes</param>
    private async Task ToggleValidationEditor(ContentNodeInfo node)
    {
        // Expand the panel to show child nodes
        IsPanelExpanded = true;
        await InvokeAsync(StateHasChanged);

        // Allow panel to expand
        await Task.Delay(50);

        var bodyTextNode = node.Children.FirstOrDefault();
        if (bodyTextNode is { ContentNodeIdContainingBodyTextChanges: not null })
        {
            if (bodyTextNode.ContentNodeIdContainingBodyTextChanges.HasValue)
            {
                // Get the parent GeneratedDocumentDisplay component
                var parentComponent = ParentDocumentDisplay;

                if (parentComponent != null)
                {
                    try
                    {
                        // Check if we already have editor data for this node
                        var existingData = ValidationEditorService.GetEditorData(bodyTextNode.Id);

                        if (existingData != null)
                        {
                            // Just update the visibility flag and trigger the editor
                            ValidationEditorService.SetEditorData(
                                bodyTextNode.Id,
                                existingData with { IsVisible = true }
                            );
                        }
                        else
                        {
                            // Get cached content or fetch if needed
                            var resultantNodeId = bodyTextNode.ContentNodeIdContainingBodyTextChanges.Value;
                            var suggestedText = await ValidationEditorService.GetValidationSuggestedTextAsync(resultantNodeId);

                            if (suggestedText != null)
                            {
                                // Look for existing validation changes in the parent document display
                                var validationChange = parentComponent.ValidationResults?.ContentChanges
                                    .FirstOrDefault(c => c.OriginalContentNodeId == bodyTextNode.Id);

                                // Set the editor data with complete information
                                ValidationEditorService.SetEditorData(
                                    bodyTextNode.Id,
                                    new ValidationEditorData(
                                        EditorMode: EditorComponentEditorMode.MultiValueDiffEditor,
                                        OriginalText: bodyTextNode.Text,
                                        SuggestedText: suggestedText,
                                        IsVisible: true,
                                        ValidationChangeInfo: validationChange
                                    )
                                );
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.Error.WriteLine($"Error in ToggleValidationEditor: {ex.Message}");
                    }
                }
            }
        }
    }

    private bool HasPendingValidationChanges(ContentNodeInfo node)
    {
        if (!node.Children.Any()) return false;

        // Check the body text node for pending validation changes
        var bodyTextNode = node.Children.FirstOrDefault();
        if (bodyTextNode == null) return false;

        // Use the validation service to check if there's actual validation data
        var editorData = ValidationEditorService.GetEditorData(bodyTextNode.Id);

        // Consider the change as pending if there's validation data with a non-null ValidationChangeInfo
        // and the status is not Accepted or Rejected
        return editorData?.ValidationChangeInfo != null &&
               editorData.ValidationChangeInfo.ApplicationStatus != ValidationContentNodeApplicationStatus.Accepted &&
               editorData.ValidationChangeInfo.ApplicationStatus != ValidationContentNodeApplicationStatus.Rejected;
    }

    private async Task ToggleSystemInfo(ContentNodeInfo node)
    {
        if (IsLoadingSystemInfo) return;

        IsLoadingSystemInfo = true;
        await ShowReferenceInformation(node);
        node.ContentNodeSystemItem = SystemItem;
        ShowSystemInfo = !ShowSystemInfo;
        if (ShowSystemInfo)
        {
            IsPanelExpanded = true;
        }

        IsLoadingSystemInfo = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ShowReferenceInformation(ContentNodeInfo node)
    {
        if (SystemItem == null && node.ContentNodeSystemItemId != null)
        {
            SystemItem = await ContentNodeApiClient.GetContentNodeSystemItemAsync((Guid)node.ContentNodeSystemItemId);
        }

        await InvokeAsync(StateHasChanged);
    }

    private string GetPanelClass(ContentNodeType nodeType)
    {
        return nodeType switch
        {
            ContentNodeType.Title => "mt-2",
            ContentNodeType.Heading => "mt-2",
            ContentNodeType.BodyText => "mt-2",
            _ => ""
        };
    }


    private async Task HandleNodeUpdated(ContentNodeInfo updatedNode)
    {
        // Copy the updated properties to the current node
        if (Node != null)
        {
            Node.Text = updatedNode.Text;
            Node.ContentNodeVersionTrackerId = updatedNode.ContentNodeVersionTrackerId;
            HasVersions = true;
        }
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        // Unsubscribe from the event when component is disposed
        ValidationEditorService.ValidationStatusChanged -= HandleValidationStatusChanged;
    }
}

@if (Node != null)
{
    if (Node.Type == ContentNodeType.Title || Node.Type == ContentNodeType.Heading)
    {
        <MudExpansionPanels>
            <MudExpansionPanel Class="@GetPanelClass(Node.Type)"
                               @bind-Expanded="IsPanelExpanded">
                <TitleContent>
                    <MudGrid>
                        <MudItem xs="1">
                            @if (Node.GenerationState == ContentNodeGenerationState.OutlineOnly)
                            {
                                <MudIcon Icon="@Icons.Material.Rounded.List" Color="Color.Info" Size="Size.Medium" />
                            }
                            else if (Node.GenerationState == ContentNodeGenerationState.InProgress)
                            {
                                <MudProgressCircular Indeterminate="true" Size="Size.Small" Color="Color.Info" />
                            }
                            else if (Node.GenerationState == ContentNodeGenerationState.Completed)
                            {
                                <MudIcon Icon="@Icons.Material.Rounded.CheckCircle" Color="Color.Success" Size="Size.Medium" />
                            }
                            else if (Node.GenerationState == ContentNodeGenerationState.Failed)
                            {
                                <MudIcon Icon="@Icons.Material.Rounded.Error" Color="Color.Error" Size="Size.Medium" />
                            }
                        </MudItem>

                        @if (Node.ContentNodeSystemItemId != null && EnableReferenceFrontend)
                        {
                            <MudItem xs="9">
                                @Node.Text
                            </MudItem>

                            <MudItem xs="1">
                                @if (Node.ValidationChangeRequested)
                                {
                                    var hasValidationData = HasPendingValidationChanges(Node);

                                    @if (hasValidationData)
                                    {
                                        <MudTooltip Text="View suggested changes">
                                            <MudIconButton OnClick="() => ToggleValidationEditor(Node)"
                                                           Icon="@Icons.Material.Rounded.ChangeHistory"
                                                           Color="Color.Warning"
                                                           Size="Size.Small" />
                                        </MudTooltip>
                                    }
                                    else
                                    {
                                        // If the validation flag is set but there's no actual data,
                                        // clear the flag to avoid showing the button permanently
                                        Node.ValidationChangeRequested = false;
                                    }
                                }
                            </MudItem>
                            <MudItem xs="1">
                                <MudTooltip Text="Reference information is available for this section. Click here to show it."
                                            Placement="Placement.Bottom">
                                    <MudIconButton OnClick="() => ToggleSystemInfo(Node)"
                                                   Icon="@Icons.Material.Rounded.Info"
                                                   Color="Color.Info"
                                                   Size="Size.Small" />
                                </MudTooltip>
                            </MudItem>
                        }
                        else
                        {
                            <MudItem xs="11">
                                @Node.Text
                            </MudItem>
                        }
                    </MudGrid>
                </TitleContent>
                <ChildContent>
                    @if (Node.Children != null && Node.Children.Any() && Recursive)
                    {
                        @if (ShowSystemInfo && SystemItem != null && EnableReferenceFrontend)
                        {
                            <ContentNodeSystemInfoDisplayComponent SystemItem="@SystemItem" />
                        }

                        <div class="section-content">
                            @foreach (var childNode in Node.Children)
                            {
                                <ContentNodeDisplay Node="childNode"
                                                    Recursive="true"
                                                    EnableReferenceFrontend="@EnableReferenceFrontend" />
                            }
                        </div>
                    }
                </ChildContent>
            </MudExpansionPanel>
        </MudExpansionPanels>
    }
    else if (Node.Type == ContentNodeType.BodyText)
    {
        <MudCard Class="@($"{GetPanelClass(Node.Type)} body-text-card mb-3")">
            <MudCardContent>
                <div class="position-relative">
                    <div class="content-node-actions">
                        @if (HasVersions)
                        {
                            <MudTooltip Text="View version history">
                                <MudIconButton Icon="@Icons.Material.Filled.History"
                                               Size="Size.Small"
                                               Color="Color.Info"
                                               OnClick="@(() => BodyTextComponent?.ShowVersionHistory())" />
                            </MudTooltip>
                        }
                        @if (Node.Type == ContentNodeType.BodyText)
                        {
                            <MudTooltip Text="Edit content">
                                <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                               Size="Size.Small"
                                               Color="Color.Primary"
                                               OnClick="@(() => BodyTextComponent?.StartEdit())" />
                            </MudTooltip>
                    
                            <MudTooltip Text="Get AI assistance">
                                <MudIconButton Icon="@Icons.Material.Filled.Chat"
                                               Size="Size.Small"
                                               Color="Color.Secondary"
                                               OnClick="@(() => BodyTextComponent?.OpenAiAssistant())" />
                            </MudTooltip>
                        }
                    </div>
                    <ContentNodeBodyTextComponent @ref="BodyTextComponent"
                                                  Node="@Node"
                                                  OnNodeUpdated="@HandleNodeUpdated" />
                </div>
            </MudCardContent>
        </MudCard>
    }
}
