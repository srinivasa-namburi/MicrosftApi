@inject IJSRuntime JSRuntime
@inject IContentReferenceApiClient ContentReferenceApiClient
@inject ISnackbar Snackbar

@using System.Text.Json
@using System.Text.RegularExpressions

<div class="chat-input-row" style="position: relative;">
    <MudTextField @ref="_mudChatTextField" T="string"
                  OnKeyDown="OnChatTextKeyDown"
                  ValueChanged="OnChatTextFieldUpdated"
                  Value="@_displayMessage"
                  Immediate="false"
                  DebounceInterval="100"
                  Lines="2"
                  MaxLines="6"
                  AutoGrow="true"
                  AutoFocus="true"
                  FullWidth="true"
                  Placeholder="Type a message... Hit the # key to insert document references"
                  Variant="Variant.Outlined"
                  AdornmentColor="Color.Primary"
                  AdornmentIcon="@Icons.Material.Filled.Send" />

    <MudIconButton Icon="@Icons.Material.Filled.Send"
                   Color="Color.Primary"
                   OnClick="@SendMessage"
                   Size="Size.Medium"
                   Class="mb-1" />

    <div id="caretAnchor" @ref="_caretPositionAnchor" class="caret-position-anchor" style="position:absolute;width:1px;height:1px;display:none;z-index:1499;"></div>

    <AiAssistantReferenceSelector @ref="_referenceSelector"
                              IsOpen="@_showReferenceSelector"
                              References="@AllReferences"
                              SearchTerm="@_currentSearchTerm"
                              AnchorElement="@_caretPositionAnchor"
                              OnReferenceSelected="HandleReferenceSelected"
                              OnClose="HandleReferenceSelectorClosed" />
</div>

@if (!DisableFileUpload)
{
    <div class="mt-2">
        <FileReferenceUploadComponent 
            OnFileUploaded="HandleFileUploaded"
            OnFilesUploaded="HandleMultipleFilesUploaded"
            AllowMultiple="true"
            MaxFileCount="10" />
    </div>
}

@code {
    [Parameter] public EventCallback<string> OnMessageSubmit { get; set; }
    [Parameter] public EventCallback<bool> OnInputFocusChanged { get; set; }
    [Parameter] public EventCallback<List<ContentReferenceItemInfo>> OnAttachedReferencesChanged { get; set; }
    [Parameter] public List<ContentReferenceItemInfo>? AllReferences { get; set; }
    [Parameter] public bool DisableFileUpload { get; set; } = false;

    private MudTextField<string>? _mudChatTextField;
    private AiAssistantReferenceSelector? _referenceSelector;
    private ElementReference _caretPositionAnchor;

    // Input state
    private string _rawMessage = string.Empty;
    private string _displayMessage = string.Empty;
    private string _previousDisplayMessage = string.Empty;
    private bool _chatTextLastKeyWasEnter = false;
    private DotNetObjectReference<AiAssistantInputComponent>? _componentReference;
    private InputState _currentState = InputState.Ready;

    // Reference selection state
    private bool _showReferenceSelector = false;
    private string _currentSearchTerm = string.Empty;
    private int _hashTagPosition = -1;

    // Attached references for pending send
    private readonly List<ContentReferenceItemInfo> _attachedReferences = new();
    public IReadOnlyList<ContentReferenceItemInfo> AttachedReferences => _attachedReferences;

    private enum InputState
    {
        Ready,
        ProcessingInput,
        SelectingReference,
        Sending
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _componentReference = DotNetObjectReference.Create(this);
        await LoadReferencesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("import", "/js/contentReferenceUtils.js");
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("registerInputComponent", _componentReference);
                if (_mudChatTextField != null)
                {
                    string elementId = await JSRuntime.InvokeAsync<string>("eval", "document.querySelector('.chat-input-row .mud-input').id");
                    await JSRuntime.InvokeVoidAsync("setupKeyboardInterceptor", elementId, _componentReference);
                }
            }
            catch (Exception ex)
            {
                await Console.Error.WriteLineAsync($"Error in AiAssistantInputComponent.OnAfterRenderAsync: {ex.Message}");
            }
        }
        if (_showReferenceSelector)
        {
            await UpdateCaretPositionAnchor();
        }
    }

    private async Task NotifyAttachedReferencesChanged()
    {
        if (OnAttachedReferencesChanged.HasDelegate)
        {
            await OnAttachedReferencesChanged.InvokeAsync(_attachedReferences.ToList());
        }
    }

    private async Task HandleFileUploaded(ContentReferenceItemInfo uploadedReference)
    {
        if (uploadedReference == null)
        {
            Snackbar.Add("Error: Uploaded reference is null.", Severity.Error);
            return;
        }
        if (!_attachedReferences.Any(r => r.Id == uploadedReference.Id))
        {
            _attachedReferences.Add(uploadedReference);
            if (AllReferences != null && !AllReferences.Any(r => r.Id == uploadedReference.Id))
            {
                AllReferences.Add(uploadedReference);
            }
            await NotifyAttachedReferencesChanged();
            StateHasChanged();
        }
    }

    private async Task HandleMultipleFilesUploaded(List<ContentReferenceItemInfo> uploadedReferences)
    {
        if (uploadedReferences == null || !uploadedReferences.Any()) { return; }
        bool changed = false;
        foreach (var reference in uploadedReferences)
        {
            if (!_attachedReferences.Any(r => r.Id == reference.Id))
            {
                _attachedReferences.Add(reference);
                if (AllReferences != null && !AllReferences.Any(r => r.Id == reference.Id))
                {
                    AllReferences.Add(reference);
                }
                changed = true;
            }
        }
        if (changed)
        {
            await NotifyAttachedReferencesChanged();
            StateHasChanged();
        }
    }

    private async Task RemoveReference(ContentReferenceItemInfo reference)
    {
        if (_attachedReferences.Remove(reference))
        {
            await NotifyAttachedReferencesChanged();
            StateHasChanged();
        }
    }

    private Color GetReferenceChipColor(ContentReferenceType type) => type switch
    {
        ContentReferenceType.GeneratedDocument => Color.Primary,
        ContentReferenceType.ExternalFile => Color.Secondary,
        ContentReferenceType.ReviewItem => Color.Tertiary,
        _ => Color.Default
    };

    private string GetReferenceIcon(ContentReferenceType type) => type switch
    {
        ContentReferenceType.GeneratedDocument => Icons.Material.Filled.Description,
        ContentReferenceType.ExternalFile => Icons.Material.Filled.AttachFile,
        ContentReferenceType.ReviewItem => Icons.Material.Filled.RateReview,
        ContentReferenceType.GeneratedSection => Icons.Material.Filled.Subject,
        _ => Icons.Material.Filled.Link
    };

    private async Task UpdateCaretPositionAnchor()
    {
        try
        {
            if (_mudChatTextField != null)
            {
                var inputId = await JSRuntime.InvokeAsync<string>("eval", "document.querySelector('.mud-input-slot')?.id || ''");
                if (!string.IsNullOrEmpty(inputId))
                {
                    await JSRuntime.InvokeVoidAsync("positionCaretAnchorById", inputId, "caretAnchor");
                }
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error positioning caret anchor: {ex.Message}");
        }
    }

    public void Dispose() => _componentReference?.Dispose();

    private async Task LoadReferencesAsync()
    {
        if (ContentReferenceApiClient == null) { return; }
        if (AllReferences == null)
        {
            try { AllReferences = await ContentReferenceApiClient.GetAssistantReferenceListAsync(200); }
            catch { AllReferences = new List<ContentReferenceItemInfo>(); }
            StateHasChanged();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_displayMessage) || _currentState == InputState.Sending) { return; }
        try
        {
            _currentState = InputState.Sending;
            string messageToSend = BuildMessageWithReferences(_displayMessage);
            await OnMessageSubmit.InvokeAsync(messageToSend);
            _rawMessage = _displayMessage = _previousDisplayMessage = string.Empty;
            _attachedReferences.Clear();
            await NotifyAttachedReferencesChanged();
            if (_mudChatTextField != null)
            {
                await _mudChatTextField.Clear();
                await _mudChatTextField.FocusAsync();
            }
        }
        finally
        {
            _currentState = InputState.Ready;
            StateHasChanged();
        }
    }

    private string BuildMessageWithReferences(string message)
    {
        if (!_attachedReferences.Any()) { return message; }
        var msg = message;
        foreach (var reference in _attachedReferences)
        {
            msg += $" #(Reference:{reference.ReferenceType}:{reference.Id})";
        }
        return msg;
    }

    private async Task OnChatTextKeyDown(KeyboardEventArgs e)
    {
        if (_currentState == InputState.Sending) { return; }
        if (e.Key == "#" && _currentState == InputState.Ready)
        {
            _hashTagPosition = _displayMessage.Length;
            _currentSearchTerm = string.Empty;
            _showReferenceSelector = true;
            _currentState = InputState.SelectingReference;
            await JSRuntime.InvokeVoidAsync("preventDefaultForKey", e.Key);
            StateHasChanged();
            await Task.Delay(10);
            await UpdateCaretPositionAnchor();
            return;
        }
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            if (_showReferenceSelector) { return; }
            await JSRuntime.InvokeVoidAsync("preventDefaultForKey", e.Key);
            await SendMessage();
        }
    }

    private async Task OnChatTextFieldUpdated(string newText)
    {
        if (_currentState is InputState.ProcessingInput or InputState.Sending) { return; }
        _currentState = InputState.ProcessingInput;
        try
        {
            string oldText = _previousDisplayMessage;
            _previousDisplayMessage = newText;
            _displayMessage = newText;
            if (_showReferenceSelector && _hashTagPosition >= 0)
            {
                UpdateSearchTerm(newText);
                await UpdateCaretPositionAnchor();
            }
            if (!string.IsNullOrWhiteSpace(newText) && _chatTextLastKeyWasEnter && !_showReferenceSelector)
            {
                await SendMessage();
                return;
            }
        }
        finally
        {
            _currentState = _showReferenceSelector ? InputState.SelectingReference : InputState.Ready;
            StateHasChanged();
        }
    }

    private void UpdateSearchTerm(string text)
    {
        if (_hashTagPosition < 0 || _hashTagPosition >= text.Length || text[_hashTagPosition] != '#')
        {
            CloseReferenceSelector();
            return;
        }
        int startPos = _hashTagPosition + 1;
        if (startPos >= text.Length) { _currentSearchTerm = string.Empty; return; }
        int endPos = text.IndexOf(' ', startPos);
        if (endPos == -1) { endPos = text.Length; }
        var searchTerm = text.Substring(startPos, endPos - startPos);
        if (_currentSearchTerm != searchTerm) { _currentSearchTerm = searchTerm; }
    }

    private void HandleReferenceSelected(ContentReferenceItemInfo reference) => Task.Run(async () => await InsertReference(reference));
    private void HandleReferenceSelectorClosed() => CloseReferenceSelector();

    private async Task InsertReference(ContentReferenceItemInfo reference)
    {
        if (_hashTagPosition < 0 || _currentState != InputState.SelectingReference) { return; }
        await InvokeAsync(async () =>
        {
            _currentState = InputState.ProcessingInput;
            try
            {
                if (!_attachedReferences.Any(r => r.Id == reference.Id))
                {
                    _attachedReferences.Add(reference);
                    await NotifyAttachedReferencesChanged();
                }
                string currentDisplayText = _displayMessage;
                int displayStartPos = _hashTagPosition;
                int displayEndPos = currentDisplayText.IndexOf(' ', displayStartPos);
                if (displayEndPos == -1) { displayEndPos = currentDisplayText.Length; }
                string newDisplayText = currentDisplayText.Substring(0, displayStartPos);
                if (displayEndPos < currentDisplayText.Length) { newDisplayText += currentDisplayText.Substring(displayEndPos); }
                CloseReferenceSelector();
                _displayMessage = newDisplayText.TrimEnd();
                _previousDisplayMessage = _displayMessage;
                if (_mudChatTextField != null)
                {
                    await _mudChatTextField.SetText(_displayMessage);
                }
                StateHasChanged();
                await Task.Delay(50);
                await JSRuntime.InvokeVoidAsync("setCaretPosition", _displayMessage.Length);
            }
            finally
            {
                _currentState = InputState.Ready;
                StateHasChanged();
            }
        });
    }

    private void CloseReferenceSelector()
    {
        _showReferenceSelector = false;
        _hashTagPosition = -1;
        _currentSearchTerm = string.Empty;
        _currentState = InputState.Ready;
        _chatTextLastKeyWasEnter = false;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task OnFocusChanged(bool hasFocus) => await OnInputFocusChanged.InvokeAsync(hasFocus);

    public async Task Clear()
    {
        _rawMessage = _displayMessage = _previousDisplayMessage = string.Empty;
        _attachedReferences.Clear();
        await NotifyAttachedReferencesChanged();
        if (_mudChatTextField != null) { await _mudChatTextField.Clear(); }
        StateHasChanged();
    }

    public async Task Focus()
    {
        if (_mudChatTextField != null) { await _mudChatTextField.FocusAsync(); }
    }
}
