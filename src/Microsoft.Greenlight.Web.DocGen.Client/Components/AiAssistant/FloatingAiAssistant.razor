@* Copyright (c) Microsoft Corporation. All rights reserved. *@

@implements IAsyncDisposable

@inject IChatApiClient ChatApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime
@inject ILogger<FloatingAiAssistant> Logger

@code {
    private bool _isChatOpen = false;
    private bool _isExpanded = false;
    private string? _userId;
    private int _unreadNotifications = 0;
    private bool _isResizing = false;

    // Increased default sizes
    private double _chatHeight = 620;   // was 500
    private double _chatWidth = 420;    // was 350
    private double _expandedHeight = 840; // was 700
    private double _expandedWidth = 720;  // was 600
    private bool _isInitialized = false;
    private DotNetObjectReference<FloatingAiAssistant>? _dotNetRef;
    private AiAssistantComponent? _aiAssistantComponent;
    private Guid _conversationId = Guid.NewGuid();

    // Size limits
    private const double MIN_HEIGHT = 400;
    private const double MAX_HEIGHT = 1100; // allow a bit larger now
    private const double MIN_WIDTH = 320;
    private const double MAX_WIDTH = 900;

    // Flow-only mode
    private const bool UseFlow = true;
    private const string FlowConversationStorageKeySuffix = "_flow_conversationId";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            _userId = authState.User?.FindFirst("sub")?.Value ?? "anonymous";
            await LoadSavedState();
            _isInitialized = true;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error initializing FloatingAiAssistant");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("FloatingChat.initialize", _dotNetRef);
        }
    }

    private async Task LoadSavedState()
    {
        try
        {
            var savedConversationId = await JSRuntime.InvokeAsync<string?>(
                "localStorage.getItem",
                $"floatingChat_{_userId}{FlowConversationStorageKeySuffix}");
            if (!string.IsNullOrEmpty(savedConversationId) && Guid.TryParse(savedConversationId, out var convId))
            {
                _conversationId = convId;
            }
            else
            {
                _conversationId = Guid.NewGuid();
                await JSRuntime.InvokeVoidAsync(
                    "localStorage.setItem",
                    $"floatingChat_{_userId}{FlowConversationStorageKeySuffix}",
                    _conversationId.ToString());
            }

            var savedDimensions = await JSRuntime.InvokeAsync<string?>(
                "localStorage.getItem",
                $"floatingChat_{_userId}_dimensions");
            if (!string.IsNullOrEmpty(savedDimensions))
            {
                var parts = savedDimensions.Split(',');
                if (parts.Length == 4)
                {
                    if (double.TryParse(parts[0], out var h)) _chatHeight = Math.Max(MIN_HEIGHT, Math.Min(MAX_HEIGHT, h));
                    if (double.TryParse(parts[1], out var w)) _chatWidth = Math.Max(MIN_WIDTH, Math.Min(MAX_WIDTH, w));
                    if (double.TryParse(parts[2], out var eh)) _expandedHeight = Math.Max(MIN_HEIGHT, Math.Min(MAX_HEIGHT, eh));
                    if (double.TryParse(parts[3], out var ew)) _expandedWidth = Math.Max(MIN_WIDTH, Math.Min(MAX_WIDTH, ew));
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error loading saved state");
        }
    }

    private async Task SaveState()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync(
                "localStorage.setItem",
                $"floatingChat_{_userId}_dimensions",
                $"{_chatHeight},{_chatWidth},{_expandedHeight},{_expandedWidth}");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error saving state");
        }
    }

    private async Task ToggleChat()
    {
        _isChatOpen = !_isChatOpen;
        if (_isChatOpen)
        {
            _unreadNotifications = 0;
            await Task.Delay(120); // let component mount & subscribe
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleExpanded()
    {
        _isExpanded = !_isExpanded;
        await SaveState();
        await InvokeAsync(StateHasChanged);
    }

    private async Task StartNewConversation()
    {
        try
        {
            _conversationId = Guid.NewGuid();
            await JSRuntime.InvokeVoidAsync(
                "localStorage.setItem",
                $"floatingChat_{_userId}{FlowConversationStorageKeySuffix}",
                _conversationId.ToString());

            // Update the AiAssistantComponent with the new conversation ID before calling StartNewConversation
            if (_aiAssistantComponent != null)
            {
                _aiAssistantComponent.ConversationId = _conversationId;
                _aiAssistantComponent.StartNewConversation();
            }
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error starting new flow conversation");
        }
    }

    private void StartResize() => _isResizing = true;

    private async Task StopResize()
    {
        if (_isResizing)
        {
            _isResizing = false;
            await SaveState();
        }
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (_isResizing)
        {
            var viewportHeight = 1200; // updated assumption
            var viewportWidth = 1700;
            if (_isExpanded)
            {
                _expandedHeight = Math.Max(MIN_HEIGHT, Math.Min(MAX_HEIGHT, viewportHeight - e.ClientY - 20));
                _expandedWidth = Math.Max(MIN_WIDTH, Math.Min(MAX_WIDTH, viewportWidth - e.ClientX - 20));
            }
            else
            {
                _chatHeight = Math.Max(MIN_HEIGHT, Math.Min(MAX_HEIGHT, viewportHeight - e.ClientY - 20));
                _chatWidth = Math.Max(MIN_WIDTH, Math.Min(MAX_WIDTH, viewportWidth - e.ClientX - 20));
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task HandleKeyboardShortcut(string shortcut)
    {
        switch (shortcut)
        {
            case "toggle":
                await ToggleChat();
                break;
            case "close":
                if (_isChatOpen)
                {
                    _isChatOpen = false;
                    await InvokeAsync(StateHasChanged);
                }
                break;
        }
    }

    public void IncrementNotifications()
    {
        if (!_isChatOpen)
        {
            _unreadNotifications++;
            InvokeAsync(StateHasChanged);
        }
    }

    private string GetChatBoxStyle()
    {
        var height = _isExpanded ? _expandedHeight : _chatHeight;
        var width = _isExpanded ? _expandedWidth : _chatWidth;
        return $"height:{height}px;width:{width}px;";
    }

    public async ValueTask DisposeAsync()
    {
        if (_dotNetRef != null)
        {
            await JSRuntime.InvokeVoidAsync("FloatingChat.dispose");
            _dotNetRef.Dispose();
        }
    }
}

<div class="floating-chat-container" @onmousemove="OnMouseMove" @onmouseup="StopResize">
    @if (!_isChatOpen)
    {
        <MudBadge Content="@_unreadNotifications" Visible="@(_unreadNotifications > 0)" Color="Color.Error" Overlap="true">
            <MudFab Class="floating-chat-button" Color="Color.Secondary" Icon="fas fa-brain" Size="Size.Large" OnClick="ToggleChat" AriaLabel="Open AI Assistant" />
        </MudBadge>
    }

    @if (_isChatOpen)
    {
        <MudPaper Class="@( $"floating-chat-box {( _isExpanded ? "expanded" : string.Empty)}" )" Elevation="8" Style="@GetChatBoxStyle()">
            <MudStack Spacing="0" Class="floating-chat-stack">
                <MudToolBar Dense="true" Class="floating-chat-header">
                    <MudIcon Icon="fas fa-brain" Color="Color.Info" Class="mr-1" />
                    <MudText Typo="Typo.subtitle2" Class="ml-1">AI Assistant (Flow)</MudText>
                    <MudSpacer />
                    <MudTooltip Text="New Conversation (Flow)">
                        <MudIconButton Icon="@Icons.Material.Filled.Refresh" Size="Size.Small" Color="Color.Inherit" OnClick="StartNewConversation" />
                    </MudTooltip>
                    <MudTooltip Text="@(_isExpanded ? "Collapse" : "Expand")">
                        <MudIconButton Icon="@(_isExpanded ? Icons.Material.Filled.FullscreenExit : Icons.Material.Filled.Fullscreen)" Size="Size.Small" Color="Color.Inherit" OnClick="ToggleExpanded" />
                    </MudTooltip>
                    <MudTooltip Text="Close (Esc)">
                        <MudIconButton Icon="@Icons.Material.Filled.Close" Size="Size.Small" Color="Color.Inherit" OnClick="ToggleChat" />
                    </MudTooltip>
                </MudToolBar>
                <div class="floating-chat-resize-handle" @onmousedown="StartResize" @onmousedown:preventDefault="true">
                    <MudIcon Icon="@Icons.Material.Filled.DragHandle" Size="Size.Small" />
                </div>
                <div class="floating-chat-content">
                    @if (_isInitialized)
                    {
                        <AiAssistantComponent @ref="_aiAssistantComponent"
                                              ConversationId="@_conversationId"
                                              DocumentProcessName="flow"
                                              UseFlow="@UseFlow"
                                              IsEmbedded="true"
                                              FillContainer="true"
                                              HideInitialContentDisplay="true"
                                              StartWithCompactUI="true"
                                              OnNewMessage="IncrementNotifications" />
                    }
                </div>
            </MudStack>
        </MudPaper>
    }
</div>
