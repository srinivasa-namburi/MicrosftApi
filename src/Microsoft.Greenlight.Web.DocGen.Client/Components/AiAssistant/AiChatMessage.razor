@* Copyright (c) Microsoft Corporation. All rights reserved. *@

@using Microsoft.Greenlight.Shared.Contracts.Chat
@using System.Timers
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events
@using Microsoft.JSInterop

@implements IAsyncDisposable
@inject IFileApiClient FileApiClient
@inject IContentReferenceApiClient ContentReferenceApiClient
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation

@code {
    [Parameter] public ChatMessageDTO ChatMessage { get; set; }
    [Parameter] public UserInfoDTO CurrentUser { get; set; }
    [Parameter] public List<ContentReferenceItemInfo> ConversationReferences { get; set; } = new();
    [Parameter] public bool IsContextEditMode { get; set; } = false;
    [Parameter] public EventCallback<string> OnContentSuggestionSelected { get; set; }

    // Direct parameter for dark mode (used when component is in a dialog)
    [Parameter] public bool IsDarkMode { get; set; }

    // For use within normal component hierarchy
    [CascadingParameter(Name = "IsDarkMode")]
    public bool CascadingIsDarkMode { get; set; }

    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    // Use either direct or cascading parameter
    private bool EffectiveIsDarkMode => IsDarkMode || CascadingIsDarkMode;

    private Timer? _timer;
    private bool _showTypingIndicator = true;
    private readonly Regex _referenceRegex = new Regex(@"#\(Reference:([^:]+):([^)]+)\)", RegexOptions.Compiled);
    private List<MessageReference> _messageReferences = new();

    // Status notification properties
    private string? _statusMessage = null;
    private bool _showStatusMessage = false;
    private Timer? _statusTimer;
    private bool _statusProcessingComplete = false;
    private bool _statusPersistent = false;

    protected override void OnInitialized()
    {
        InitializeOrRestartTimer();
        ExtractReferences();
        RegisterForStatusUpdates();
    }

    protected override void OnParametersSet()
    {
        InitializeOrRestartTimer();
        ExtractReferences();
    }

    private void RegisterForStatusUpdates()
    {
        if (HubConnection != null && ChatMessage != null)
        {
            // Register for message-specific status updates
            HubConnection.On<ChatMessageStatusNotification>(
                "ReceiveChatMessageStatusNotification",
                HandleChatMessageStatusNotification);

            // Join message-specific group for targeted updates
            _ = HubConnection.SendAsync("AddToGroup", ChatMessage.Id.ToString());
        }
    }

    private async Task HandleChatMessageStatusNotification(ChatMessageStatusNotification notification)
    {
        if (notification.ChatMessageId == ChatMessage.Id)
        {
            _statusMessage = notification.StatusMessage;
            _showStatusMessage = true;
            _statusProcessingComplete = notification.ProcessingComplete;
            _statusPersistent = notification.Persistent;

            if (notification.ProcessingComplete)
            {
                _statusPersistent = false;
                _statusTimer?.Dispose();
                _statusTimer = new Timer(2000);
                _statusTimer.Elapsed += HideStatusMessage;
                _statusTimer.AutoReset = false;
                _statusTimer.Start();
            }
            else if (!notification.Persistent)
            {
                _statusTimer?.Dispose();
                _statusTimer = new Timer(10000);
                _statusTimer.Elapsed += HideStatusMessage;
                _statusTimer.AutoReset = false;
                _statusTimer.Start();
            }
            else
            {
                _statusTimer?.Dispose();
                _statusTimer = null;
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private void HideStatusMessage(object? sender, ElapsedEventArgs e)
    {
        if (_statusPersistent)
        {
            return;
        }

        _showStatusMessage = false;
        InvokeAsync(StateHasChanged);
        _statusTimer?.Dispose();
    }

    private void ExtractReferences()
    {
        _messageReferences.Clear();
        var content = GetOriginalMessageContent();

        int referenceNumber = 1;
        foreach (Match match in _referenceRegex.Matches(content))
        {
            if (match.Success && Enum.TryParse<ContentReferenceType>(match.Groups[1].Value, out var referenceType)
                              && Guid.TryParse(match.Groups[2].Value, out var referenceId))
            {
                var referenceInfo = ConversationReferences.FirstOrDefault(r => r.Id == referenceId);

                var reference = new MessageReference
                {
                    Number = referenceNumber++,
                    ReferenceType = referenceType,
                    ReferenceId = referenceId,
                    FullMatch = match.Value,
                    DisplayName = referenceInfo?.DisplayName ?? $"Reference {referenceId.ToString().Substring(0, 8)}"
                };

                _messageReferences.Add(reference);
            }
        }

        // Update display names for file-based references
        foreach (var reference in _messageReferences.Where(r => 
            r.ReferenceType == ContentReferenceType.ExternalFile || 
            r.ReferenceType == ContentReferenceType.ExternalLinkAsset))
        {
            var fileReference = ConversationReferences.FirstOrDefault(r => r.Id == reference.ReferenceId);
            if (fileReference != null)
            {
                reference.DisplayName = fileReference.DisplayName;
            }
        }
    }

    private string GetFormattedMessageContent()
    {
        var content = ChatMessage.Message ?? string.Empty;

        bool hasContentReference = !string.IsNullOrEmpty(ChatMessage.ContentText) &&
                                   content.Contains("Content included as reference");

        if (hasContentReference)
        {
            content = content.Replace("(Content included as reference)", "");
            content = content.Trim() + "\n\n[Content reference attached]";
        }

        foreach (var reference in _messageReferences)
        {
            content = content.Replace(reference.FullMatch, $"[{reference.Number}]");
        }

        return content;
    }

    private string GetOriginalMessageContent()
    {
        return !string.IsNullOrEmpty(ChatMessage.ContentText)
            ? ChatMessage.ContentText
            : ChatMessage.Message ?? string.Empty;
    }

    private void InitializeOrRestartTimer()
    {
        if (ChatMessage.Source == ChatMessageSource.Assistant &&
            ChatMessage.State == ChatMessageCreationState.InProgress)
        {
            _timer?.Dispose();
            _timer = new Timer(10000); // 10 seconds
            _timer.Elapsed += HideTypingIndicator;
            _timer.AutoReset = false;
            _timer.Start();
        }
        else
        {
            _showTypingIndicator = false;
        }
    }

    private void HideTypingIndicator(object? sender, ElapsedEventArgs e)
    {
        _showTypingIndicator = false;
        InvokeAsync(StateHasChanged);
        _timer?.Dispose();
    }

    private bool IsCurrentUser =>
        ChatMessage.Source == ChatMessageSource.User &&
        ChatMessage.UserId == CurrentUser?.ProviderSubjectId;

    private string GetInitials()
    {
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "AI";

        if (ChatMessage.Source == ChatMessageSource.System)
            return "SYS";

        if (string.IsNullOrEmpty(ChatMessage.UserFullName))
            return "?";

        var parts = ChatMessage.UserFullName.Split(' ');
        if (parts.Length == 1)
            return parts[0].Substring(0, 1).ToUpper();

        return $"{parts[0].Substring(0, 1)}{parts[^1].Substring(0, 1)}".ToUpper();
    }

    private string GetDisplayName()
    {
        if (IsCurrentUser)
            return "You";
        
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "AI Assistant";
        
        if (ChatMessage.Source == ChatMessageSource.System)
            return "System";
        
        return ChatMessage.UserFullName ?? "Unknown User";
    }

    private string FormatDateTime(DateTime dateTime)
    {
        if (dateTime.Date == DateTime.Today)
            return $"Today at {dateTime:HH:mm}";
        if (dateTime.Date == DateTime.Today.AddDays(-1))
            return $"Yesterday at {dateTime:HH:mm}";
        return $"{dateTime:MMM d, yyyy HH:mm}";
    }

    private string GetReferenceIcon(ContentReferenceType referenceType)
    {
        return referenceType switch
        {
            ContentReferenceType.GeneratedDocument => Icons.Material.Filled.Description,
            ContentReferenceType.GeneratedSection => Icons.Material.Filled.Subject,
            ContentReferenceType.ExternalFile => Icons.Material.Filled.AttachFile,
            ContentReferenceType.ReviewItem => Icons.Material.Filled.RateReview,
            ContentReferenceType.ExternalLinkAsset => Icons.Material.Filled.Link,
            _ => Icons.Material.Filled.Link,
        };
    }

    private Color GetBubbleColor()
    {
        if (IsCurrentUser)
            return Color.Info; // Lighter blue instead of Primary
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return Color.Default;
        if (ChatMessage.Source == ChatMessageSource.System)
            return Color.Info;
        return Color.Default;
    }

    private Color GetAvatarColor()
    {
        if (IsCurrentUser)
            return Color.Primary;
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return Color.Secondary;
        if (ChatMessage.Source == ChatMessageSource.System)
            return Color.Info;
        return Color.Default;
    }

    private async Task ApplySuggestion()
    {
        if (IsContextEditMode && !string.IsNullOrEmpty(ChatMessage.ContentText))
        {
            await OnContentSuggestionSelected.InvokeAsync(ChatMessage.ContentText);
        }
    }

    private async Task DownloadFile(MessageReference reference, bool openInline = true)
    {
        if (reference.ReferenceId == null)
            return;

        // Prefer centralized resolver via API (supports both ExternalFile and ExternalLinkAsset paths)
        var downloadUrl = await ContentReferenceApiClient.GetDownloadUrlForContentReferenceAsync(reference.ReferenceId);
        if (!string.IsNullOrWhiteSpace(downloadUrl))
        {
            // Open in new tab for viewing (inline) or download
            await JSRuntime.InvokeVoidAsync("window.open", downloadUrl, "_blank");
        }
    }

    public async ValueTask DisposeAsync()
    {
        _timer?.Dispose();
        _statusTimer?.Dispose();

        if (HubConnection != null && ChatMessage != null)
        {
            await HubConnection.SendAsync("RemoveFromGroup", ChatMessage.Id.ToString());
            HubConnection.Remove("ReceiveChatMessageStatusNotification");
        }
    }

    private class MessageReference
    {
        public int Number { get; set; }
        public ContentReferenceType ReferenceType { get; set; }
        public Guid ReferenceId { get; set; }
        public string? FullMatch { get; set; }
        public string? DisplayName { get; set; }
    }
}

<MudChat ChatPosition="@(IsCurrentUser ? ChatBubblePosition.End : ChatBubblePosition.Start)" Class="mb-2">
    <MudAvatar Color="@GetAvatarColor()" Size="Size.Small">
        @GetInitials()
    </MudAvatar>
    
    <MudChatHeader>
        <ChildContent>
            <MudText Typo="Typo.subtitle2">@GetDisplayName()</MudText>
            <MudText Typo="Typo.caption">@FormatDateTime(ChatMessage.CreatedUtc)</MudText>
        </ChildContent>
    </MudChatHeader>
    
    <MudChatBubble Variant="Variant.Filled" 
                   Color="@GetBubbleColor()">
        <div>
            <RenderMultilineText Value="@GetFormattedMessageContent()" />

            @if (_messageReferences.Any())
            {
                <MudDivider Class="my-2" />
                <div class="chat-message-attachments">
                    @foreach (var reference in _messageReferences)
                    {
                        @if (reference.ReferenceType == ContentReferenceType.ExternalFile || 
                             reference.ReferenceType == ContentReferenceType.ExternalLinkAsset)
                        {
                            <MudChip T="string" Size="Size.Small" 
                                     Icon="@GetReferenceIcon(reference.ReferenceType)" 
                                     Variant="Variant.Outlined"
                                     Color="Color.Default"
                                     Class="mud-chip-clickable reference-chip"
                                     data-testid="@($"chat-ref-{reference.ReferenceId}")"
                                     OnClick="async () => await DownloadFile(reference)">
                                [@reference.Number] @reference.DisplayName
                            </MudChip>
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" 
                                     Icon="@GetReferenceIcon(reference.ReferenceType)" 
                                     Variant="Variant.Outlined"
                                     Color="Color.Default"
                                     Class="reference-chip"
                                     data-testid="@($"chat-ref-{reference.ReferenceId}")">
                                [@reference.Number] @reference.DisplayName
                            </MudChip>
                        }
                    }
                </div>
            }

            @if (IsContextEditMode && ChatMessage.Source == ChatMessageSource.Assistant && !string.IsNullOrEmpty(ChatMessage.ContentText))
            {
                <MudDivider Class="my-2" />
                <MudText Typo="Typo.subtitle2" Class="mt-2">Suggested Content:</MudText>
                <MudPaper Elevation="0" Class="pa-2 my-2" Style="background-color: var(--mud-palette-background-gray); max-height: 200px; overflow-y: auto;">
                    <MudText Typo="Typo.body2" Style="white-space: pre-wrap;">@ChatMessage.ContentText</MudText>
                </MudPaper>
                <MudButton Color="Color.Primary"
                           Variant="Variant.Filled"
                           Size="Size.Small"
                           OnClick="ApplySuggestion"
                           Class="mt-1">
                    Apply Suggestion
                </MudButton>
            }

            @if (_showStatusMessage && !string.IsNullOrEmpty(_statusMessage))
            {
                <MudDivider Class="mt-2 mb-1" />
                <MudStack Row="true" Spacing="1" AlignItems="AlignItems.Center">
                    @if (!_statusProcessingComplete)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" />
                    }
                    <MudText Typo="Typo.caption">@_statusMessage</MudText>
                </MudStack>
            }
        </div>
    </MudChatBubble>
    
    @if (ChatMessage.State != ChatMessageCreationState.Complete)
    {
        <MudChatFooter>
            <MudText Typo="Typo.caption">@(ChatMessage.State == ChatMessageCreationState.InProgress ? "In progress..." : "Failed")</MudText>
        </MudChatFooter>
    }
    
    @if (ChatMessage.Source == ChatMessageSource.Assistant && 
         ChatMessage.State == ChatMessageCreationState.InProgress && 
         _showTypingIndicator)
    {
        <div class="typing-indicator">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
        </div>
    }
</MudChat>

<style>
    .chat-message-attachments {
        margin-top: 8px;
    }

    .chat-message-attachments .mud-chip-clickable {
        cursor: pointer !important;
        transition: all 0.2s ease;
    }

    .chat-message-attachments .mud-chip-clickable:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .typing-indicator {
        display: flex;
        gap: 4px;
        padding: 8px;
    }

    .typing-dot {
        width: 8px;
        height: 8px;
        background-color: var(--mud-palette-text-secondary);
        border-radius: 50%;
        animation: typing 1.4s infinite;
    }

    .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
    }

    .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
    }

    @@keyframes typing {
        0%, 60%, 100% {
            transform: translateY(0);
        }
        30% {
            transform: translateY(-10px);
        }
    }
</style>
