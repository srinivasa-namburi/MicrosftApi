@* Copyright (c) Microsoft Corporation. All rights reserved. *@

@using Microsoft.Greenlight.Shared.Contracts.Chat
@using System.Timers
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Messages.Chat.Events
@using Microsoft.JSInterop
@using System.Text.Json

@implements IAsyncDisposable
@inject IFileApiClient FileApiClient
@inject IContentReferenceApiClient ContentReferenceApiClient
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation

@code {
    [Parameter] public ChatMessageDTO ChatMessage { get; set; }
    [Parameter] public UserInfoDTO CurrentUser { get; set; }
    [Parameter] public List<ContentReferenceItemInfo> ConversationReferences { get; set; } = new();
    [Parameter] public bool IsContextEditMode { get; set; } = false;
    [Parameter] public EventCallback<string> OnContentSuggestionSelected { get; set; }
    [Parameter] public EventCallback<(string message, bool isProcessing)> OnStatusMessage { get; set; }

    // Direct parameter for dark mode (used when component is in a dialog)
    [Parameter] public bool IsDarkMode { get; set; }

    // For use within normal component hierarchy
    [CascadingParameter(Name = "IsDarkMode")]
    public bool CascadingIsDarkMode { get; set; }

    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    // Use either direct or cascading parameter
    private bool EffectiveIsDarkMode => IsDarkMode || CascadingIsDarkMode;

    private Timer? _timer;
    private bool _showTypingIndicator = true;
    private readonly Regex _referenceRegex = new Regex(@"#\(Reference:([^:]+):([^)]+)\)", RegexOptions.Compiled);
    private List<MessageReference> _messageReferences = new();

    // Status notification properties
    private string? _statusMessage = null;
    private bool _showStatusMessage = false;
    private Timer? _statusTimer;
    private bool _statusProcessingComplete = false;
    private bool _statusPersistent = false;

    // Flow aggregation UI
    private bool _flowDetailsExpanded = false;
    private List<FlowAggregationSection> _flowSections = new();
    private bool _flowExtraDataParsed = false;
    private bool _supersededMessageExpanded = false;
    private bool _showSupersededMessages = false;
    private bool HasSupersededMessages => ChatMessage?.SupersededMessageIds?.Any() == true;

    protected override void OnInitialized()
    {
        InitializeOrRestartTimer();
        ExtractReferences();
        RegisterForStatusUpdates();
        ParseFlowAggregationExtraData();
    }

    protected override void OnParametersSet()
    {
        InitializeOrRestartTimer();
        ExtractReferences();
        ParseFlowAggregationExtraData();
    }

    private void RegisterForStatusUpdates()
    {
        // Don't register for status updates on Flow aggregation messages
        // Status should only appear in the global status bar, not on the message itself
        if (HubConnection != null && ChatMessage != null && ChatMessage.IsFlowAggregation != true)
        {
            // Register for message-specific status updates
            HubConnection.On<ChatMessageStatusNotification>(
                "ReceiveChatMessageStatusNotification",
                HandleChatMessageStatusNotification);

            // Join message-specific group for targeted updates
            _ = HubConnection.SendAsync("AddToGroup", ChatMessage.Id.ToString());
        }
    }

    private async Task HandleChatMessageStatusNotification(ChatMessageStatusNotification notification)
    {
        if (notification.ChatMessageId == ChatMessage.Id)
        {
            // Forward to parent for global status display
            if (OnStatusMessage.HasDelegate)
            {
                await OnStatusMessage.InvokeAsync((notification.StatusMessage, !notification.ProcessingComplete));
            }

            _statusMessage = notification.StatusMessage;
            _showStatusMessage = true;
            _statusProcessingComplete = notification.ProcessingComplete;
            _statusPersistent = notification.Persistent;

            if (notification.ProcessingComplete)
            {
                _statusPersistent = false;
                _statusTimer?.Dispose();
                _statusTimer = new Timer(2000);
                _statusTimer.Elapsed += HideStatusMessage;
                _statusTimer.AutoReset = false;
                _statusTimer.Start();
            }
            else if (!notification.Persistent)
            {
                _statusTimer?.Dispose();
                _statusTimer = new Timer(10000);
                _statusTimer.Elapsed += HideStatusMessage;
                _statusTimer.AutoReset = false;
                _statusTimer.Start();
            }
            else
            {
                _statusTimer?.Dispose();
                _statusTimer = null;
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private void HideStatusMessage(object? sender, ElapsedEventArgs e)
    {
        if (_statusPersistent)
        {
            return;
        }

        _showStatusMessage = false;
        InvokeAsync(StateHasChanged);
        _statusTimer?.Dispose();
    }

    private void ParseFlowAggregationExtraData()
    {
        if (ChatMessage?.IsFlowAggregation != true)
        {
            _flowSections.Clear();
            _flowExtraDataParsed = false;
            return;
        }
        if (string.IsNullOrWhiteSpace(ChatMessage.ExtraDataJson)) { return; }
        try
        {
            using var doc = JsonDocument.Parse(ChatMessage.ExtraDataJson);
            var root = doc.RootElement;
            if (root.TryGetProperty("sections", out var sections) && sections.ValueKind == JsonValueKind.Array)
            {
                _flowSections = sections
                    .EnumerateArray()
                    .Select(s => new FlowAggregationSection
                    {
                        Process = s.TryGetProperty("process", out var p) ? p.GetString() ?? "(unknown)" : "(unknown)",
                        Text = s.TryGetProperty("text", out var t) ? t.GetString() ?? string.Empty : string.Empty,
                        Complete = s.TryGetProperty("complete", out var c) && c.GetBoolean()
                    })
                    .OrderBy(s => s.Process)
                    .ToList();
                _flowExtraDataParsed = true;
            }
        }
        catch { _flowExtraDataParsed = false; }
    }

    private bool ShowFlowHeader => ChatMessage?.IsFlowAggregation == true;
    private bool IsSupersededMessage => ChatMessage?.SupersededByMessageId != null;
    private void ToggleFlowDetails() => _flowDetailsExpanded = !_flowDetailsExpanded;
    private void ToggleSupersededMessage() => _supersededMessageExpanded = !_supersededMessageExpanded;

    private void ExtractReferences()
    {
        _messageReferences.Clear();
        var content = GetOriginalMessageContent();

        int referenceNumber = 1;
        foreach (Match match in _referenceRegex.Matches(content))
        {
            if (match.Success && Enum.TryParse<ContentReferenceType>(match.Groups[1].Value, out var referenceType)
                              && Guid.TryParse(match.Groups[2].Value, out var referenceId))
            {
                var referenceInfo = ConversationReferences.FirstOrDefault(r => r.Id == referenceId);

                var reference = new MessageReference
                {
                    Number = referenceNumber++,
                    ReferenceType = referenceType,
                    ReferenceId = referenceId,
                    FullMatch = match.Value,
                    DisplayName = referenceInfo?.DisplayName ?? $"Reference {referenceId.ToString().Substring(0, 8)}"
                };

                _messageReferences.Add(reference);
            }
        }

        // Update display names for file-based references
        foreach (var reference in _messageReferences.Where(r => 
            r.ReferenceType == ContentReferenceType.ExternalFile || 
            r.ReferenceType == ContentReferenceType.ExternalLinkAsset))
        {
            var fileReference = ConversationReferences.FirstOrDefault(r => r.Id == reference.ReferenceId);
            if (fileReference != null)
            {
                reference.DisplayName = fileReference.DisplayName;
            }
        }
    }

    private string GetFormattedMessageContent()
    {
        var content = ChatMessage.Message ?? string.Empty;

        bool hasContentReference = !string.IsNullOrEmpty(ChatMessage.ContentText) &&
                                   content.Contains("Content included as reference");

        if (hasContentReference)
        {
            content = content.Replace("(Content included as reference)", "");
            content = content.Trim() + "\n\n[Content reference attached]";
        }

        foreach (var reference in _messageReferences)
        {
            content = content.Replace(reference.FullMatch, $"[{reference.Number}]");
        }

        return content;
    }

    private string GetOriginalMessageContent()
    {
        return !string.IsNullOrEmpty(ChatMessage.ContentText)
            ? ChatMessage.ContentText
            : ChatMessage.Message ?? string.Empty;
    }

    private void InitializeOrRestartTimer()
    {
        if (ChatMessage.Source == ChatMessageSource.Assistant &&
            ChatMessage.State == ChatMessageCreationState.InProgress)
        {
            _timer?.Dispose();
            _timer = new Timer(10000); // 10 seconds
            _timer.Elapsed += HideTypingIndicator;
            _timer.AutoReset = false;
            _timer.Start();
        }
        else
        {
            _showTypingIndicator = false;
        }
    }

    private void HideTypingIndicator(object? sender, ElapsedEventArgs e)
    {
        _showTypingIndicator = false;
        InvokeAsync(StateHasChanged);
        _timer?.Dispose();
    }

    private bool IsCurrentUser =>
        ChatMessage.Source == ChatMessageSource.User &&
        ChatMessage.UserId == CurrentUser?.ProviderSubjectId;

    private string GetInitials()
    {
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "AI";

        if (ChatMessage.Source == ChatMessageSource.System)
            return "SYS";

        if (string.IsNullOrEmpty(ChatMessage.UserFullName))
            return "?";

        var parts = ChatMessage.UserFullName.Split(' ');
        if (parts.Length == 1)
            return parts[0].Substring(0, 1).ToUpper();

        return $"{parts[0].Substring(0, 1)}{parts[^1].Substring(0, 1)}".ToUpper();
    }

    private string GetDisplayName()
    {
        if (IsCurrentUser)
            return "You";
        
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return "AI Assistant";
        
        if (ChatMessage.Source == ChatMessageSource.System)
            return "System";
        
        return ChatMessage.UserFullName ?? "Unknown User";
    }

    private string FormatDateTime(DateTime dateTime)
    {
        if (dateTime.Date == DateTime.Today)
            return $"Today at {dateTime:HH:mm}";
        if (dateTime.Date == DateTime.Today.AddDays(-1))
            return $"Yesterday at {dateTime:HH:mm}";
        return $"{dateTime:MMM d, yyyy HH:mm}";
    }

    private string GetReferenceIcon(ContentReferenceType referenceType)
    {
        return referenceType switch
        {
            ContentReferenceType.GeneratedDocument => Icons.Material.Filled.Description,
            ContentReferenceType.GeneratedSection => Icons.Material.Filled.Subject,
            ContentReferenceType.ExternalFile => Icons.Material.Filled.AttachFile,
            ContentReferenceType.ReviewItem => Icons.Material.Filled.RateReview,
            ContentReferenceType.ExternalLinkAsset => Icons.Material.Filled.Link,
            _ => Icons.Material.Filled.Link,
        };
    }

    private Color GetBubbleColor()
    {
        if (IsCurrentUser)
            return Color.Info; // Lighter blue instead of Primary
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return Color.Default;
        if (ChatMessage.Source == ChatMessageSource.System)
            return Color.Info;
        return Color.Default;
    }

    private Color GetAvatarColor()
    {
        if (IsCurrentUser)
            return Color.Primary;
        if (ChatMessage.Source == ChatMessageSource.Assistant)
            return Color.Secondary;
        if (ChatMessage.Source == ChatMessageSource.System)
            return Color.Info;
        return Color.Default;
    }

    private async Task ApplySuggestion()
    {
        if (IsContextEditMode && !string.IsNullOrEmpty(ChatMessage.ContentText))
        {
            await OnContentSuggestionSelected.InvokeAsync(ChatMessage.ContentText);
        }
    }

    private async Task DownloadFile(MessageReference reference, bool openInline = true)
    {
        if (reference.ReferenceId == null)
            return;

        // Prefer centralized resolver via API (supports both ExternalFile and ExternalLinkAsset paths)
        var downloadUrl = await ContentReferenceApiClient.GetDownloadUrlForContentReferenceAsync(reference.ReferenceId);
        if (!string.IsNullOrWhiteSpace(downloadUrl))
        {
            // Open in new tab for viewing (inline) or download
            await JSRuntime.InvokeVoidAsync("window.open", downloadUrl, "_blank");
        }
    }

    public async ValueTask DisposeAsync()
    {
        _timer?.Dispose();
        _statusTimer?.Dispose();

        // Only unsubscribe if we subscribed (non-Flow messages)
        if (HubConnection != null && ChatMessage != null && ChatMessage.IsFlowAggregation != true)
        {
            await HubConnection.SendAsync("RemoveFromGroup", ChatMessage.Id.ToString());
            HubConnection.Remove("ReceiveChatMessageStatusNotification");
        }
    }

    private class MessageReference
    {
        public int Number { get; set; }
        public ContentReferenceType ReferenceType { get; set; }
        public Guid ReferenceId { get; set; }
        public string? FullMatch { get; set; }
        public string? DisplayName { get; set; }
    }

    private sealed class FlowAggregationSection
    {
        public string Process { get; set; } = string.Empty;
        public string Text { get; set; } = string.Empty;
        public bool Complete { get; set; }
    }
}

<MudChat ChatPosition="@(IsCurrentUser ? ChatBubblePosition.End : ChatBubblePosition.Start)"
         Class="mb-2"
         Dense="true">
    <MudAvatar Color="@GetAvatarColor()" Size="Size.Small">
        @GetInitials()
    </MudAvatar>

    <MudChatHeader Name="@GetDisplayName()" Time="@FormatDateTime(ChatMessage.CreatedUtc)" />
    
    <MudChatBubble Variant="@(IsCurrentUser ? Variant.Filled : Variant.Outlined)"
                   Color="@GetBubbleColor()"
                   Elevation="@(IsCurrentUser ? 0 : 1)">
        <div>
            @* Flow aggregation UI *@
            @if (ShowFlowHeader)
            {
                // Show Flow header for aggregation messages
                <div class="d-flex align-center mb-2">
                    <MudChip T="string"
                             Color="@(ChatMessage.IsIntermediate ? Color.Warning : (IsSupersededMessage ? Color.Default : Color.Success))"
                             Variant="Variant.Filled"
                             Size="Size.Small"
                             Class="mr-2">
                        @(ChatMessage.IsIntermediate ? "Flow Aggregation" : (IsSupersededMessage ? "Previous Aggregation" : "Flow Synthesis"))
                    </MudChip>
                    @if (ChatMessage.IsIntermediate)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                        @* Don't show status on the message for Flow aggregations - it goes to status bar *@
                    }
                    else if (!IsSupersededMessage)
                    {
                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="Color.Success" Class="mr-1" />
                        <MudText Typo="Typo.caption" Class="ml-1" Color="Color.Success">Final synthesis</MudText>
                        @if (HasSupersededMessages)
                        {
                            <MudChip T="string"
                                     Size="Size.Small"
                                     Icon="@Icons.Material.Filled.History"
                                     Color="Color.Info"
                                     Variant="Variant.Text"
                                     Class="ml-2 cursor-pointer"
                                     OnClick="() => _showSupersededMessages = !_showSupersededMessages">
                                @(ChatMessage.SupersededMessageIds.Count) intermediate @(ChatMessage.SupersededMessageIds.Count == 1 ? "step" : "steps")
                            </MudChip>
                        }
                    }
                    <MudSpacer />
                    @if (_flowSections.Any())
                    {
                        <MudButton Variant="Variant.Text" Size="Size.Small" OnClick="ToggleFlowDetails">
                            @(_flowDetailsExpanded ? "Hide details" : "Show details")
                        </MudButton>
                    }
                </div>
            }

            @if (!_flowDetailsExpanded || !_flowSections.Any())
            {
                <RenderMultilineText Value="@GetFormattedMessageContent()" />
            }
            else
            {
                // Show Flow sections when expanded
                <MudStack Spacing="2">
                    @foreach (var flowSection in _flowSections)
                    {
                        <MudPaper Elevation="1" Outlined="@(!flowSection.Complete)" Class="pa-2">
                            <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-1">
                                @if (flowSection.Complete)
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="Color.Success" />
                                }
                                else
                                {
                                    <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                                }
                                <MudText Typo="Typo.subtitle2">@flowSection.Process</MudText>
                            </MudStack>
                            <RenderMultilineText Value="@flowSection.Text" />
                        </MudPaper>
                    }
                </MudStack>
            }

            @if (_messageReferences.Any())
            {
                <MudDivider Class="my-2" />
                <div class="chat-message-attachments">
                    @foreach (var reference in _messageReferences)
                    {
                        @if (reference.ReferenceType == ContentReferenceType.ExternalFile || 
                             reference.ReferenceType == ContentReferenceType.ExternalLinkAsset)
                        {
                            <MudChip T="string" Size="Size.Small" 
                                     Icon="@GetReferenceIcon(reference.ReferenceType)" 
                                     Variant="Variant.Outlined"
                                     Color="Color.Default"
                                     Class="mud-chip-clickable reference-chip"
                                     data-testid="@($"chat-ref-{reference.ReferenceId}")"
                                     OnClick="async () => await DownloadFile(reference)">
                                [@reference.Number] @reference.DisplayName
                            </MudChip>
                        }
                        else
                        {
                            <MudChip T="string" Size="Size.Small" 
                                     Icon="@GetReferenceIcon(reference.ReferenceType)" 
                                     Variant="Variant.Outlined"
                                     Color="Color.Default"
                                     Class="reference-chip"
                                     data-testid="@($"chat-ref-{reference.ReferenceId}")">
                                [@reference.Number] @reference.DisplayName
                            </MudChip>
                        }
                    }
                </div>
            }

            @if (IsContextEditMode && ChatMessage.Source == ChatMessageSource.Assistant && !string.IsNullOrEmpty(ChatMessage.ContentText))
            {
                <MudDivider Class="my-2" />
                <MudText Typo="Typo.subtitle2" Class="mt-2">Suggested Content:</MudText>
                <MudPaper Elevation="0" Class="pa-2 my-2" Style="background-color: var(--mud-palette-background-gray); max-height: 200px; overflow-y: auto;">
                    <MudText Typo="Typo.body2" Style="white-space: pre-wrap;">@ChatMessage.ContentText</MudText>
                </MudPaper>
                <MudButton Color="Color.Primary"
                           Variant="Variant.Filled"
                           Size="Size.Small"
                           OnClick="ApplySuggestion"
                           Class="mt-1">
                    Apply Suggestion
                </MudButton>
            }

            @* Status messages are now displayed globally in the parent component *@
        </div>
    </MudChatBubble>
    
    @if (ChatMessage.State != ChatMessageCreationState.Complete)
    {
        <MudChatFooter>
            <MudText Typo="Typo.caption">@(ChatMessage.State == ChatMessageCreationState.InProgress ? "In progress..." : "Failed")</MudText>
        </MudChatFooter>
    }
    
    @if (ChatMessage.Source == ChatMessageSource.Assistant &&
         ChatMessage.State == ChatMessageCreationState.InProgress &&
         _showTypingIndicator)
    {
        <MudChatFooter>
            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
            <MudText Typo="Typo.caption">Assistant is typing...</MudText>
        </MudChatFooter>
    }
</MudChat>

