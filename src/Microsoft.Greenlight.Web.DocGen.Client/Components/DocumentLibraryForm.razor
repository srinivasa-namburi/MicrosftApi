@using System.Net
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Messages.Reindexing.Events
@using Microsoft.Greenlight.Shared.Contracts.DTO.Configuration
@using Microsoft.Greenlight.Shared.Contracts.DTO
@using Microsoft.Greenlight.Shared.Enums
@inject IConfigurationApiClient ConfigurationApiClient
@inject IDocumentLibraryApiClient DocumentLibraryApiClient
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject IFileApiClient FileApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@inject IDocumentReindexApiClient DocumentReindexApiClient
@inject SignalRConnectionService SignalRConnectionService
@inject SignalRSubscriptionFactory SignalRSubscriptionFactory
@implements IAsyncDisposable

<MudPaper Class="pa-4">
    <MudGrid>
        <MudItem xs="12">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                <MudText Typo="Typo.h6">@FormTitle</MudText>
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.body2" Class="text-right">
                        <strong>Logic Type:</strong> @DocumentLibraryInfo.LogicType.ToString()
                    </MudText>
                    @if (IsEditMode && DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                    {
                        <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="OpenVectorSearchDialog">
                            <MudIcon Icon="@Icons.Material.Filled.Search" Class="mr-1" />
                            Search Vector Store
                        </MudButton>
                    }
                </MudStack>
            </MudStack>
        </MudItem>
    </MudGrid>

    @if (IsEditMode && ShouldShowLibraryBanner)
    {
        <!-- Inline Reindex Status for this library when actively running, or completed if seen in-session -->
        <MudGrid Class="mb-2">
            <MudItem xs="12">
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.subtitle2">Reindexing Status:</MudText>

                    <MudChip Color="@GetStatusColor(_libraryReindexStatus!.Status)" Variant="Variant.Filled">
                        Library: @_libraryReindexStatus!.Status.ToString() (@_libraryReindexStatus!.ProcessedDocuments/@_libraryReindexStatus!.TotalDocuments)
                    </MudChip>
                    <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="OpenLibraryReindexProgress">View details</MudButton>

                    <MudSpacer />
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" Title="Refresh reindex status" OnClick="RefreshReindexStatusesAsync" />
                </MudStack>
            </MudItem>
        </MudGrid>
    }
    
    <MudForm @ref="form" Model="DocumentLibraryInfo">
        <MudTextField Label="Short Name" @bind-Value="DocumentLibraryInfo.ShortName" For="@(() => DocumentLibraryInfo.ShortName)" Required="true" OnBlur="ValidateAndFormatShortName" />
        <MudTextField Label="Description of Contents" @bind-Value="DocumentLibraryInfo.DescriptionOfContents" For="@(() => DocumentLibraryInfo.DescriptionOfContents)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Description of When to Use" @bind-Value="DocumentLibraryInfo.DescriptionOfWhenToUse" For="@(() => DocumentLibraryInfo.DescriptionOfWhenToUse)" Required="true" Lines="3" TextArea="true" />

        <MudExpansionPanels Class="mt-2">
            <MudExpansionPanel Text="Storage & Index" Expanded="true">
                <MudTextField Label="Index Name" @bind-Value="DocumentLibraryInfo.IndexName" For="@(() => DocumentLibraryInfo.IndexName)" Required="true" Disabled="IsEditMode" />
                <MudTextField Label="Blob Storage Container Name" @bind-Value="DocumentLibraryInfo.BlobStorageContainerName" For="@(() => DocumentLibraryInfo.BlobStorageContainerName)" Required="true" Disabled="IsEditMode" />
                <MudTextField Label="Blob Storage Auto Import Folder Name" @bind-Value="DocumentLibraryInfo.BlobStorageAutoImportFolderName" For="@(() => DocumentLibraryInfo.BlobStorageAutoImportFolderName)" />
            </MudExpansionPanel>

            <MudExpansionPanel Text="Advanced (Vector Store & Embeddings)" Expanded="true">
                @if (DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                {
                    <MudSelect T="TextChunkingMode?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkingMode" Label="Chunking Mode">
                        @foreach (var mode in Enum.GetValues<TextChunkingMode>())
                        {
                            <MudSelectItem Value="@(mode as TextChunkingMode?)">@mode.ToString()</MudSelectItem>
                        }
                    </MudSelect>
                    
                    <MudNumericField T="int?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkSize" 
                                   Label="Chunk Size (tokens)" 
                                   HelperText="Number of tokens per chunk. Leave empty to use global default."
                                   Min="100" Max="8000" />
                    
                    <MudNumericField T="int?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkOverlap" 
                                   Label="Chunk Overlap (tokens)" 
                                   HelperText="Number of overlapping tokens between chunks. Leave empty to use global default."
                                   Min="0" Max="2000" />
                                   
                    <MudDivider Class="my-2" />

                    <MudSelect T="AiModelDeploymentInfo" Label="Embedding Model Deployment" @bind-Value="SelectedEmbeddingDeployment" ToStringFunc="@(d => d.DeploymentName)">
                        @foreach (var deployment in _aiModelDeployments.Where(d => d.AiModel?.ModelType == AiModelType.Embedding))
                        {
                            <MudSelectItem Value="@deployment">@deployment.DeploymentName</MudSelectItem>
                        }
                    </MudSelect>

                    <MudSelect T="int?" @bind-Value="DocumentLibraryInfo.EmbeddingDimensionsOverride" Label="Embedding Size Override (dimensions)">
                        <MudSelectItem T="int?" Value="@(default(int?))">Use deployment default</MudSelectItem>
                        <MudSelectItem T="int?" Value="256">256</MudSelectItem>
                        <MudSelectItem T="int?" Value="512">512</MudSelectItem>
                        <MudSelectItem T="int?" Value="1024">1024</MudSelectItem>
                        <MudSelectItem T="int?" Value="1536">1536</MudSelectItem>
                        <MudSelectItem T="int?" Value="3072">3072</MudSelectItem>
                    </MudSelect>

                    <MudAlert Severity="Severity.Info" Class="mt-2">
                        <strong>Note:</strong> Changing chunk size or overlap will only apply to newly ingested documents. 
                        Existing documents in the index will retain their original chunking. 
                        You can reindex existing documents to apply new chunk settings.
                    </MudAlert>
                }
                else
                {
                    <MudAlert Severity="Severity.Info">
                        Embedding Model and Embedding Size are only available when Logic Type is SemanticKernelVectorStore.
                    </MudAlert>
                }
            </MudExpansionPanel>
        </MudExpansionPanels>

        @if (IsEditMode && DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            <MudStack Class="mt-4" Spacing="2">
                <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.Refresh" OnClick="ShowReindexDialog">
                    Reindex Documents
                </MudButton>
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    This will recreate vector embeddings for all previously ingested documents in this library (using the currently set chunk size)
                </MudText>
            </MudStack>
        }

        <MudDivider Class="my-2" />

        <MudStack Row="false" Spacing="2">
            <MudStack Row="true" Spacing="2">
                <MudButton OnClick="(()=>HandleValidSubmit())" Variant="Variant.Filled" Color="Color.Primary" Style="min-width:150px">Save</MudButton>
                <MudButton OnClick="@Cancel" Variant="Variant.Outlined" Color="Color.Default" Style="min-width:150px">Cancel</MudButton>
                @if (IsEditMode)
                {
                    <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="ConfirmDeleteLibrary" Style="min-width:150px">
                        Delete Library
                    </MudButton>
                }
            </MudStack>
        </MudStack>
    </MudForm>
</MudPaper>

@if (IsEditMode)
{
    <MudDivider Class="my-4" />

    <!-- File Upload Section -->
    <MudPaper Class="pa-4">
        <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                       FilesChanged="HandleFileSelected"
                       MaximumFileCount="16384">
            <ButtonTemplate>
                <MudButton HtmlTag="label"
                           Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.CloudUpload"
                           for="@context">
                    Upload Files to Document Library
                </MudButton>
            </ButtonTemplate>
        </MudFileUpload>
    </MudPaper>

    <MudDivider Class="my-4" />

    <!-- Associated Document Processes Section -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6">Associated Document Processes</MudText>

        <MudTable Items="AssociatedDocumentProcesses" Hover="true">
            <HeaderContent>
                <MudTh>Process Name</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Process Name">@context.ShortName</MudTd>
                <MudTd DataLabel="Actions">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="() => ConfirmDisassociateProcess(context.Id)" />
                </MudTd>
            </RowTemplate>
        </MudTable>

        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowAssociateProcessDialog">Associate Document Process</MudButton>
    </MudPaper>
}

@code {
    [Parameter]
    public DocumentLibraryInfo DocumentLibraryInfo { get; set; } = new DocumentLibraryInfo();

    [Parameter]
    public EventCallback<DocumentLibraryInfo> OnSaved { get; set; }

    private MudForm form = new();
    private string FormTitle => DocumentLibraryInfo.Id == Guid.Empty ? "Create Document Library" : "Edit Document Library";
    private bool IsEditMode => DocumentLibraryInfo.Id != Guid.Empty;

    private List<DocumentProcessInfo> AssociatedDocumentProcesses = new();
    private List<DocumentProcessInfo> AvailableDocumentProcesses = new();

    // Reindex status state
    private string LibraryOrchestrationId => string.IsNullOrWhiteSpace(DocumentLibraryInfo?.ShortName) ? string.Empty : $"library-{DocumentLibraryInfo.ShortName}";
    private DocumentReindexStateInfo? _libraryReindexStatus;
    private bool _sawLibraryRunThisSession; // true after a Running/Progress event this session

    // SignalR management
    private HubConnection? _hubConnection;
    private SignalRSubscriptionManager? _subMgr;

    private bool ShouldShowLibraryBanner => _libraryReindexStatus is not null && (
        _libraryReindexStatus.Status == ReindexOrchestrationState.ClearingVectorStore ||
        _libraryReindexStatus.Status == ReindexOrchestrationState.Running ||
        (_libraryReindexStatus.Status == ReindexOrchestrationState.Completed && _sawLibraryRunThisSession)
    );

    private List<AiModelDeploymentInfo> _aiModelDeployments = new();

    private AiModelDeploymentInfo? SelectedEmbeddingDeployment
    {
        get => _aiModelDeployments.FirstOrDefault(d => d.Id == DocumentLibraryInfo.EmbeddingModelDeploymentId);
        set => DocumentLibraryInfo.EmbeddingModelDeploymentId = value?.Id;
    }

    private Guid? _initialEmbeddingModelDeploymentId;
    private int? _initialEmbeddingDimensionsOverride;

    protected override async Task OnInitializedAsync()
    {
        if (IsEditMode)
        {
            _initialEmbeddingModelDeploymentId = DocumentLibraryInfo.EmbeddingModelDeploymentId;
            _initialEmbeddingDimensionsOverride = DocumentLibraryInfo.EmbeddingDimensionsOverride;
            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
            // Seed status once, but do not show completed-from-previous-session banner
            await RefreshReindexStatusesAsync();
            await InitializeSignalRAsync();
        }

        // Load embedding model deployments for dropdown
        _aiModelDeployments = await ConfigurationApiClient.GetAiModelDeploymentsAsync();
    }

    private async Task InitializeSignalRAsync()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(LibraryOrchestrationId))
            {
                return;
            }

            _hubConnection ??= await SignalRConnectionService.GetOrCreateAsync();
            _subMgr ??= SignalRSubscriptionFactory.Create(_hubConnection);

            _subMgr.RegisterHandlerOnce<DocumentReindexStartedNotification>("ReceiveDocumentReindexStartedNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _sawLibraryRunThisSession = true;
                    await RefreshReindexStatusesAsync();
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexProgressNotification>("ReceiveDocumentReindexProgressNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _sawLibraryRunThisSession = true;
                    _libraryReindexStatus ??= new DocumentReindexStateInfo();
                    _libraryReindexStatus.Status = ReindexOrchestrationState.Running;
                    _libraryReindexStatus.TotalDocuments = n.TotalDocuments;
                    _libraryReindexStatus.ProcessedDocuments = n.ProcessedDocuments;
                    _libraryReindexStatus.FailedDocuments = n.FailedDocuments;
                    await InvokeAsync(StateHasChanged);
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexCompletedNotification>("ReceiveDocumentReindexCompletedNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _libraryReindexStatus ??= new DocumentReindexStateInfo();
                    _libraryReindexStatus.Status = ReindexOrchestrationState.Completed;
                    _libraryReindexStatus.TotalDocuments = n.TotalDocuments;
                    _libraryReindexStatus.ProcessedDocuments = n.ProcessedDocuments;
                    _libraryReindexStatus.FailedDocuments = n.FailedDocuments;
                    await InvokeAsync(StateHasChanged);
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexFailedNotification>("ReceiveDocumentReindexFailedNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _libraryReindexStatus ??= new DocumentReindexStateInfo();
                    _libraryReindexStatus.Status = ReindexOrchestrationState.Failed;
                    await InvokeAsync(StateHasChanged);
                }
            });

            await _subMgr.EnsureConnectedAsync();
            await _subMgr.JoinGroupAsync(LibraryOrchestrationId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR init failed: {ex.Message}");
        }
    }

    private async Task OpenVectorSearchDialog()
    {
        var parameters = new DialogParameters
        {
            ["IsLibraryScope"] = true,
            ["ScopeShortName"] = DocumentLibraryInfo.ShortName
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Large, FullWidth = true };
        await DialogService.ShowAsync<VectorStoreSearchDialog>("Search Vector Store", parameters, options);
    }

    private Color GetStatusColor(ReindexOrchestrationState status) => status switch
    {
        ReindexOrchestrationState.Running => Color.Info,
        ReindexOrchestrationState.Completed => Color.Success,
        ReindexOrchestrationState.Failed => Color.Error,
        ReindexOrchestrationState.ClearingVectorStore => Color.Warning,
        _ => Color.Default
    };

    private async Task RefreshReindexStatusesAsync()
    {
        try
        {
            _libraryReindexStatus = null;

            if (!string.IsNullOrWhiteSpace(LibraryOrchestrationId))
            {
                _libraryReindexStatus = await DocumentReindexApiClient.GetReindexingStatusAsync(LibraryOrchestrationId);
                // If we're just landing on the page and it's already completed from earlier, do not flip the session flag
                if (_libraryReindexStatus?.Status == ReindexOrchestrationState.Running || _libraryReindexStatus?.Status == ReindexOrchestrationState.ClearingVectorStore)
                {
                    _sawLibraryRunThisSession = true;
                }
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing reindex statuses: {ex.Message}");
        }
    }

    private async Task OpenLibraryReindexProgress()
    {
        if (string.IsNullOrWhiteSpace(LibraryOrchestrationId))
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "OrchestrationId", LibraryOrchestrationId },
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "Reason", _libraryReindexStatus?.Reason ?? string.Empty }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    private void ValidateAndFormatShortName()
    {
        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name cannot be empty.", Severity.Error);
            return;
        }

        // Replace spaces with periods
        DocumentLibraryInfo.ShortName = DocumentLibraryInfo.ShortName.Replace(" ", ".");

        // Remove any characters that are not letters, digits, or periods
        DocumentLibraryInfo.ShortName = new string(DocumentLibraryInfo.ShortName.Where(c => char.IsLetterOrDigit(c) || c == '.').ToArray());

        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name must contain valid characters.", Severity.Error);
            return;
        }

        // After formatting ShortName, update IndexName and BlobStorageContainerName for new libraries only
        if (!IsEditMode)
        {
            UpdateIndexAndBlobNames();
        }
    }

    private void UpdateIndexAndBlobNames()
    {
        // Convert ShortName to lowercase and replace periods with dashes
        var formattedName = DocumentLibraryInfo.ShortName.ToLowerInvariant().Replace(".", "-");

        // Set IndexName and BlobStorageContainerName
        DocumentLibraryInfo.IndexName = $"index-additional-{formattedName}";
        DocumentLibraryInfo.BlobStorageContainerName = $"blob-additional-{formattedName}";
    }

    private async Task LoadAssociatedDocumentProcesses()
    {
        // Fetch associated document processes
        AssociatedDocumentProcesses = await DocumentLibraryApiClient.GetDocumentProcessesByLibraryIdAsync(DocumentLibraryInfo.Id);
    }

    private async Task LoadAvailableDocumentProcesses()
    {
        // Fetch all document processes and exclude those already associated
        var allProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
        AvailableDocumentProcesses = allProcesses.Where(p => AssociatedDocumentProcesses.All(ap => ap.Id != p.Id)).ToList();
    }

    private bool EmbeddingConfigChanged()
    {
        return _initialEmbeddingModelDeploymentId != DocumentLibraryInfo.EmbeddingModelDeploymentId
            || _initialEmbeddingDimensionsOverride != DocumentLibraryInfo.EmbeddingDimensionsOverride;
    }

    private async Task<bool> ConfirmReindexIfEmbeddingChangedAsync()
    {
        if (!IsEditMode)
        {
            return true;
        }
        if (!EmbeddingConfigChanged())
        {
            return true;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "IsDocumentProcess", false },
            { "Reason", "Embedding model/dimensions changed" },
            { "WarningMessage", "Changing the embedding model or dimensions requires deleting and rebuilding the library vector index. Proceed?" }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Required", parameters, options);
        var result = await dialog.Result;
        return !result.Canceled;
    }

    private async Task StartImmediateReindexAsync(string reason)
    {
        try
        {
            var orchestrationId = await DocumentReindexApiClient.StartDocumentLibraryReindexingAsync(DocumentLibraryInfo.ShortName, reason);

            // show progress dialog directly
            var parameters = new DialogParameters
            {
                { "OrchestrationId", orchestrationId },
                { "TargetName", DocumentLibraryInfo.ShortName },
                { "Reason", reason }
            };
            var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
            await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);

            // refresh banners/status
            await RefreshReindexStatusesAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to start reindex: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleValidSubmit()
    {
        await form.Validate();

        if (!form.IsValid)
        {
            return;
        }

        if (IsEditMode && DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            var ok = await ConfirmReindexIfEmbeddingChangedAsync();
            if (!ok)
            {
                return;
            }
        }

        // Ensure embedding settings are only applied for SemanticKernelVectorStore
        if (DocumentLibraryInfo.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            DocumentLibraryInfo.EmbeddingModelDeploymentId = null;
            DocumentLibraryInfo.EmbeddingDimensionsOverride = null;
        }

        if (DocumentLibraryInfo.Id == Guid.Empty)
        {
            // Create new document library
            var createdLibrary = await DocumentLibraryApiClient.CreateDocumentLibraryAsync(DocumentLibraryInfo);
            Snackbar.Add("Document Library saved", Severity.Success);
            DocumentLibraryInfo = createdLibrary;
            await OnSaved.InvokeAsync(createdLibrary);
            NavigationManager.NavigateTo($"/document-library/{DocumentLibraryInfo.Id}");
        }
        else
        {
            // Update existing document library
            var updatedLibrary = await DocumentLibraryApiClient.UpdateDocumentLibraryAsync(DocumentLibraryInfo);
            Snackbar.Add("Document Library updated", Severity.Success);
            await OnSaved.InvokeAsync(updatedLibrary);

            // Trigger immediate reindex if embedding config changed
            if (DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore && EmbeddingConfigChanged())
            {
                await StartImmediateReindexAsync("Embedding model/dimensions changed");
            }

            // Reset baseline after save
            _initialEmbeddingModelDeploymentId = DocumentLibraryInfo.EmbeddingModelDeploymentId;
            _initialEmbeddingDimensionsOverride = DocumentLibraryInfo.EmbeddingDimensionsOverride;
        }

        if (IsEditMode)
        {
            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
            await RefreshReindexStatusesAsync();
        }
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/document-libraries");
    }

    private void ShowAssociateProcessDialog()
    {
        var parameters = new DialogParameters
        {
            { "AvailableProcesses", AvailableDocumentProcesses },
            { "DocumentLibraryId", DocumentLibraryInfo.Id }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<AssociateDocumentProcessWithDocumentLibraryDialog>("Associate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private void ConfirmDisassociateProcess(Guid processId)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", "Are you sure you want to disassociate this document process?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Disassociate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await DisassociateProcess(processId);
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private async Task DisassociateProcess(Guid processId)
    {
        try
        {
            await DocumentLibraryApiClient.DisassociateDocumentProcessAsync(DocumentLibraryInfo.Id, processId);
            Snackbar.Add("Document process disassociated successfully.", Severity.Success);

            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error disassociating document process: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleFileSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files == null || files.Count == 0)
        {
            Snackbar.Add("No files selected for upload.", Severity.Warning);
            return;
        }
        foreach (var file in files)
        {
            var fileName = $"{DocumentLibraryInfo.BlobStorageAutoImportFolderName}/{file.Name}";
            // URL encode the file name
            fileName = WebUtility.UrlEncode(fileName);

            try
            {
                var result = await FileApiClient.UploadFileDirectAsync(DocumentLibraryInfo.BlobStorageContainerName, fileName, file);
                Snackbar.Add($"File '{file.Name}' uploaded successfully.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error uploading file '{file.Name}': {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task ShowReindexDialog()
    {
        if (!IsEditMode || DocumentLibraryInfo.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "IsDocumentProcess", false },
            { "Reason", "Manual reindexing" },
            { "WarningMessage", "This will delete and rebuild the library repository index." }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Documents", parameters, options);
    }

    private async Task ConfirmDeleteLibrary()
    {
        var parameters = new DialogParameters
        {
            { "ContentText", $"Are you sure you want to delete the document library '{DocumentLibraryInfo.ShortName}'? This deletes the vector index/collection (if SK), its blob container and all ingested document records." },
            { "ButtonText", "Delete" },
            { "DialogColor", Color.Error }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Delete Document Library", parameters, options);
        var result = await dialog.Result;
        if (!result.Canceled)
        {
            try
            {
                await DocumentLibraryApiClient.DeleteDocumentLibraryAsync(DocumentLibraryInfo.Id);
                Snackbar.Add("Document library deleted.", Severity.Success);
                NavigationManager.NavigateTo("/document-libraries");
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to delete library: {ex.Message}", Severity.Error);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_subMgr != null)
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(LibraryOrchestrationId))
                {
                    await _subMgr.LeaveGroupAsync(LibraryOrchestrationId);
                }
            }
            catch { }
            await _subMgr.DisposeAsync();
        }
    }
}
