@using System.Net
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Greenlight.Shared.Contracts.Messages.Reindexing.Events
@inject IDocumentLibraryApiClient DocumentLibraryApiClient
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject IFileApiClient FileApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@inject IDocumentReindexApiClient DocumentReindexApiClient
@inject SignalRConnectionService SignalRConnectionService
@inject SignalRSubscriptionFactory SignalRSubscriptionFactory
@using Microsoft.Greenlight.Shared.Enums
@using Microsoft.Greenlight.Shared.Contracts.DTO
@implements IAsyncDisposable

<MudPaper Class="pa-4">
    <MudGrid>
        <MudItem xs="12">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                <MudText Typo="Typo.h6">@FormTitle</MudText>
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.body2" Class="text-right">
                        <strong>Logic Type:</strong> @DocumentLibraryInfo.LogicType.ToString()
                    </MudText>
                    @if (IsEditMode && DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
                    {
                        <MudButton Variant="Variant.Outlined" Color="Color.Primary" Size="Size.Small" OnClick="OpenVectorSearchDialog">
                            <MudIcon Icon="@Icons.Material.Filled.Search" Class="mr-1" />
                            Search Vector Store
                        </MudButton>
                    }
                </MudStack>
            </MudStack>
        </MudItem>
    </MudGrid>

    @if (IsEditMode && ShouldShowLibraryBanner)
    {
        <!-- Inline Reindex Status for this library when actively running, or completed if seen in-session -->
        <MudGrid Class="mb-2">
            <MudItem xs="12">
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.subtitle2">Reindexing Status:</MudText>

                    <MudChip Color="@GetStatusColor(_libraryReindexStatus!.Status)" Variant="Variant.Filled">
                        Library: @_libraryReindexStatus!.Status.ToString() (@_libraryReindexStatus!.ProcessedDocuments/@_libraryReindexStatus!.TotalDocuments)
                    </MudChip>
                    <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="OpenLibraryReindexProgress">View details</MudButton>

                    <MudSpacer />
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" Title="Refresh reindex status" OnClick="RefreshReindexStatusesAsync" />
                </MudStack>
            </MudItem>
        </MudGrid>
    }
    
    <MudForm @ref="form" Model="DocumentLibraryInfo">
        <MudTextField Label="Short Name" @bind-Value="DocumentLibraryInfo.ShortName" For="@(() => DocumentLibraryInfo.ShortName)" Required="true" OnBlur="ValidateAndFormatShortName" />
        <MudTextField Label="Description of Contents" @bind-Value="DocumentLibraryInfo.DescriptionOfContents" For="@(() => DocumentLibraryInfo.DescriptionOfContents)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Description of When to Use" @bind-Value="DocumentLibraryInfo.DescriptionOfWhenToUse" For="@(() => DocumentLibraryInfo.DescriptionOfWhenToUse)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Index Name" @bind-Value="DocumentLibraryInfo.IndexName" For="@(() => DocumentLibraryInfo.IndexName)" Required="true" Disabled="IsEditMode" />
        <MudTextField Label="Blob Storage Container Name" @bind-Value="DocumentLibraryInfo.BlobStorageContainerName" For="@(() => DocumentLibraryInfo.BlobStorageContainerName)" Required="true" Disabled="IsEditMode" />
        <MudTextField Label="Blob Storage Auto Import Folder Name" @bind-Value="DocumentLibraryInfo.BlobStorageAutoImportFolderName" For="@(() => DocumentLibraryInfo.BlobStorageAutoImportFolderName)" />
        
        @if (DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            <MudSelect T="TextChunkingMode?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkingMode" Label="Chunking Mode">
                @foreach (var mode in Enum.GetValues<TextChunkingMode>())
                {
                    <MudSelectItem Value="@(mode as TextChunkingMode?)">@mode.ToString()</MudSelectItem>
                }
            </MudSelect>
            
            <MudNumericField T="int?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkSize" 
                           Label="Chunk Size (tokens)" 
                           HelperText="Number of tokens per chunk. Leave empty to use global default."
                           Min="100" Max="8000" />
            
            <MudNumericField T="int?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkOverlap" 
                           Label="Chunk Overlap (tokens)" 
                           HelperText="Number of overlapping tokens between chunks. Leave empty to use global default."
                           Min="0" Max="2000" />
                           
            <MudAlert Severity="Severity.Info" Class="mt-2">
                <strong>Note:</strong> Changing chunk size or overlap will only apply to newly ingested documents. 
                Existing documents in the index will retain their original chunking. 
                You can reindex existing documents to apply new chunk settings.
            </MudAlert>
        }

        @if (IsEditMode && DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            <MudStack Class="mt-4" Spacing="2">
                <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.Refresh" OnClick="ShowReindexDialog">
                    Reindex Documents
                </MudButton>
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    This will recreate vector embeddings for all previously ingested documents in this library (using the currently set chunk size)
                </MudText>
            </MudStack>
        }

        <MudDivider Class="my-2" />

        <MudStack Row="true" Spacing="2">
            <MudButton OnClick="(()=>HandleValidSubmit())" Variant="Variant.Filled" Color="Color.Primary">Save</MudButton>
            <MudButton OnClick="@Cancel" Variant="Variant.Text" Color="Color.Default">Cancel</MudButton>
        </MudStack>
    </MudForm>
</MudPaper>

@if (IsEditMode)
{
    <MudDivider Class="my-4" />

    <!-- File Upload Section -->
    <MudPaper Class="pa-4">
        <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                       FilesChanged="HandleFileSelected"
                       MaximumFileCount="16384">
            <ButtonTemplate>
                <MudButton HtmlTag="label"
                           Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.CloudUpload"
                           for="@context">
                    Upload Files to Document Library
                </MudButton>
            </ButtonTemplate>
        </MudFileUpload>
    </MudPaper>



    <MudDivider Class="my-4" />

    <!-- Associated Document Processes Section -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6">Associated Document Processes</MudText>

        <MudTable Items="AssociatedDocumentProcesses" Hover="true">
            <HeaderContent>
                <MudTh>Process Name</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Process Name">@context.ShortName</MudTd>
                <MudTd DataLabel="Actions">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="() => ConfirmDisassociateProcess(context.Id)" />
                </MudTd>
            </RowTemplate>
        </MudTable>

        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowAssociateProcessDialog">Associate Document Process</MudButton>
    </MudPaper>
}

@code {
    [Parameter]
    public DocumentLibraryInfo DocumentLibraryInfo { get; set; } = new DocumentLibraryInfo();

    [Parameter]
    public EventCallback<DocumentLibraryInfo> OnSaved { get; set; }

    private MudForm form = new();
    private string FormTitle => DocumentLibraryInfo.Id == Guid.Empty ? "Create Document Library" : "Edit Document Library";
    private bool IsEditMode => DocumentLibraryInfo.Id != Guid.Empty;

    private List<DocumentProcessInfo> AssociatedDocumentProcesses = new();
    private List<DocumentProcessInfo> AvailableDocumentProcesses = new();

    // Reindex status state
    private string LibraryOrchestrationId => string.IsNullOrWhiteSpace(DocumentLibraryInfo?.ShortName) ? string.Empty : $"library-{DocumentLibraryInfo.ShortName}";
    private DocumentReindexStateInfo? _libraryReindexStatus;
    private bool _sawLibraryRunThisSession; // true after a Running/Progress event this session

    // SignalR management
    private HubConnection? _hubConnection;
    private SignalRSubscriptionManager? _subMgr;

    private bool ShouldShowLibraryBanner => _libraryReindexStatus is not null && (
        _libraryReindexStatus.Status == ReindexOrchestrationState.ClearingVectorStore ||
        _libraryReindexStatus.Status == ReindexOrchestrationState.Running ||
        (_libraryReindexStatus.Status == ReindexOrchestrationState.Completed && _sawLibraryRunThisSession)
    );

    protected override async Task OnInitializedAsync()
    {
        if (IsEditMode)
        {
            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
            // Seed status once, but do not show completed-from-previous-session banner
            await RefreshReindexStatusesAsync();
            await InitializeSignalRAsync();
        }
    }

    private async Task InitializeSignalRAsync()
    {
        try
        {
            if (string.IsNullOrWhiteSpace(LibraryOrchestrationId))
            {
                return;
            }

            _hubConnection ??= await SignalRConnectionService.GetOrCreateAsync();
            _subMgr ??= SignalRSubscriptionFactory.Create(_hubConnection);

            _subMgr.RegisterHandlerOnce<DocumentReindexStartedNotification>("ReceiveDocumentReindexStartedNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _sawLibraryRunThisSession = true;
                    await RefreshReindexStatusesAsync();
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexProgressNotification>("ReceiveDocumentReindexProgressNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _sawLibraryRunThisSession = true;
                    _libraryReindexStatus ??= new DocumentReindexStateInfo();
                    _libraryReindexStatus.Status = ReindexOrchestrationState.Running;
                    _libraryReindexStatus.TotalDocuments = n.TotalDocuments;
                    _libraryReindexStatus.ProcessedDocuments = n.ProcessedDocuments;
                    _libraryReindexStatus.FailedDocuments = n.FailedDocuments;
                    await InvokeAsync(StateHasChanged);
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexCompletedNotification>("ReceiveDocumentReindexCompletedNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _libraryReindexStatus ??= new DocumentReindexStateInfo();
                    _libraryReindexStatus.Status = ReindexOrchestrationState.Completed;
                    _libraryReindexStatus.TotalDocuments = n.TotalDocuments;
                    _libraryReindexStatus.ProcessedDocuments = n.ProcessedDocuments;
                    _libraryReindexStatus.FailedDocuments = n.FailedDocuments;
                    await InvokeAsync(StateHasChanged);
                }
            });
            _subMgr.RegisterHandlerOnce<DocumentReindexFailedNotification>("ReceiveDocumentReindexFailedNotification", async n =>
            {
                if (n.OrchestrationId == LibraryOrchestrationId)
                {
                    _libraryReindexStatus ??= new DocumentReindexStateInfo();
                    _libraryReindexStatus.Status = ReindexOrchestrationState.Failed;
                    await InvokeAsync(StateHasChanged);
                }
            });

            await _subMgr.EnsureConnectedAsync();
            await _subMgr.JoinGroupAsync(LibraryOrchestrationId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR init failed: {ex.Message}");
        }
    }

    private async Task OpenVectorSearchDialog()
    {
        var parameters = new DialogParameters
        {
            ["IsLibraryScope"] = true,
            ["ScopeShortName"] = DocumentLibraryInfo.ShortName
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Large, FullWidth = true };
        await DialogService.ShowAsync<VectorStoreSearchDialog>("Search Vector Store", parameters, options);
    }

    private Color GetStatusColor(ReindexOrchestrationState status) => status switch
    {
        ReindexOrchestrationState.Running => Color.Info,
        ReindexOrchestrationState.Completed => Color.Success,
        ReindexOrchestrationState.Failed => Color.Error,
        ReindexOrchestrationState.ClearingVectorStore => Color.Warning,
        _ => Color.Default
    };

    private async Task RefreshReindexStatusesAsync()
    {
        try
        {
            _libraryReindexStatus = null;

            if (!string.IsNullOrWhiteSpace(LibraryOrchestrationId))
            {
                _libraryReindexStatus = await DocumentReindexApiClient.GetReindexingStatusAsync(LibraryOrchestrationId);
                // If we're just landing on the page and it's already completed from earlier, do not flip the session flag
                if (_libraryReindexStatus?.Status == ReindexOrchestrationState.Running || _libraryReindexStatus?.Status == ReindexOrchestrationState.ClearingVectorStore)
                {
                    _sawLibraryRunThisSession = true;
                }
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing reindex statuses: {ex.Message}");
        }
    }

    private async Task OpenLibraryReindexProgress()
    {
        if (string.IsNullOrWhiteSpace(LibraryOrchestrationId))
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "OrchestrationId", LibraryOrchestrationId },
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "Reason", _libraryReindexStatus?.Reason ?? string.Empty }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    private void ValidateAndFormatShortName()
    {
        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name cannot be empty.", Severity.Error);
            return;
        }

        // Replace spaces with periods
        DocumentLibraryInfo.ShortName = DocumentLibraryInfo.ShortName.Replace(" ", ".");

        // Remove any characters that are not letters, digits, or periods
        DocumentLibraryInfo.ShortName = new string(DocumentLibraryInfo.ShortName.Where(c => char.IsLetterOrDigit(c) || c == '.').ToArray());

        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name must contain valid characters.", Severity.Error);
            return;
        }

        // After formatting ShortName, update IndexName and BlobStorageContainerName for new libraries only
        if (!IsEditMode)
        {
            UpdateIndexAndBlobNames();
        }
    }

    private void UpdateIndexAndBlobNames()
    {
        // Convert ShortName to lowercase and replace periods with dashes
        var formattedName = DocumentLibraryInfo.ShortName.ToLowerInvariant().Replace(".", "-");

        // Set IndexName and BlobStorageContainerName
        DocumentLibraryInfo.IndexName = $"index-additional-{formattedName}";
        DocumentLibraryInfo.BlobStorageContainerName = $"blob-additional-{formattedName}";
    }

    private async Task LoadAssociatedDocumentProcesses()
    {
        // Fetch associated document processes
        AssociatedDocumentProcesses = await DocumentLibraryApiClient.GetDocumentProcessesByLibraryIdAsync(DocumentLibraryInfo.Id);
    }

    private async Task LoadAvailableDocumentProcesses()
    {
        // Fetch all document processes and exclude those already associated
        var allProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
        AvailableDocumentProcesses = allProcesses.Where(p => AssociatedDocumentProcesses.All(ap => ap.Id != p.Id)).ToList();
    }

    private async Task HandleValidSubmit()
    {
        await form.Validate();

        if (form.IsValid)
        {
            if (DocumentLibraryInfo.Id == Guid.Empty)
            {
                // Create new document library
                var createdLibrary = await DocumentLibraryApiClient.CreateDocumentLibraryAsync(DocumentLibraryInfo);
                Snackbar.Add("Document Library saved", Severity.Success);
                DocumentLibraryInfo = createdLibrary;
                await OnSaved.InvokeAsync(createdLibrary);
                NavigationManager.NavigateTo($"/document-library/{DocumentLibraryInfo.Id}");
            }
            else
            {
                // Update existing document library
                var updatedLibrary = await DocumentLibraryApiClient.UpdateDocumentLibraryAsync(DocumentLibraryInfo);
                Snackbar.Add("Document Library updated", Severity.Success);
                await OnSaved.InvokeAsync(updatedLibrary);
            }

            // Reload associated processes after save
            if (IsEditMode)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
                await RefreshReindexStatusesAsync();
            }
        }
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/document-libraries");
    }

    private void ShowAssociateProcessDialog()
    {
        var parameters = new DialogParameters
        {
            { "AvailableProcesses", AvailableDocumentProcesses },
            { "DocumentLibraryId", DocumentLibraryInfo.Id }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<AssociateDocumentProcessWithDocumentLibraryDialog>("Associate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private void ConfirmDisassociateProcess(Guid processId)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", "Are you sure you want to disassociate this document process?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Disassociate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await DisassociateProcess(processId);
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private async Task DisassociateProcess(Guid processId)
    {
        try
        {
            await DocumentLibraryApiClient.DisassociateDocumentProcessAsync(DocumentLibraryInfo.Id, processId);
            Snackbar.Add("Document process disassociated successfully.", Severity.Success);

            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error disassociating document process: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleFileSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files == null || files.Count == 0)
        {
            Snackbar.Add("No files selected for upload.", Severity.Warning);
            return;
        }
        foreach (var file in files)
        {
            var fileName = $"{DocumentLibraryInfo.BlobStorageAutoImportFolderName}/{file.Name}";
            // URL encode the file name
            fileName = WebUtility.UrlEncode(fileName);

            try
            {
                var result = await FileApiClient.UploadFileDirectAsync(DocumentLibraryInfo.BlobStorageContainerName, fileName, file);
                Snackbar.Add($"File '{file.Name}' uploaded successfully.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error uploading file '{file.Name}': {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task ShowReindexDialog()
    {
        if (!IsEditMode || DocumentLibraryInfo.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "IsDocumentProcess", false },
            { "Reason", "Manual reindexing" },
            { "WarningMessage", "This will delete and rebuild the library repository index." }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Documents", parameters, options);
    }

    public async ValueTask DisposeAsync()
    {
        if (_subMgr != null)
        {
            try
            {
                if (!string.IsNullOrWhiteSpace(LibraryOrchestrationId))
                {
                    await _subMgr.LeaveGroupAsync(LibraryOrchestrationId);
                }
            }
            catch { }
            await _subMgr.DisposeAsync();
        }
    }
}
