@using System.Net
@inject IDocumentLibraryApiClient DocumentLibraryApiClient
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject IFileApiClient FileApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager NavigationManager

<MudPaper Class="pa-4">
    <MudForm @ref="form" Model="DocumentLibraryInfo">
        <MudText Typo="Typo.h6">@FormTitle</MudText>

        <MudTextField Label="Short Name" @bind-Value="DocumentLibraryInfo.ShortName" For="@(() => DocumentLibraryInfo.ShortName)" Required="true" OnBlur="ValidateAndFormatShortName" />
        <MudTextField Label="Description of Contents" @bind-Value="DocumentLibraryInfo.DescriptionOfContents" For="@(() => DocumentLibraryInfo.DescriptionOfContents)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Description of When to Use" @bind-Value="DocumentLibraryInfo.DescriptionOfWhenToUse" For="@(() => DocumentLibraryInfo.DescriptionOfWhenToUse)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Index Name" @bind-Value="DocumentLibraryInfo.IndexName" For="@(() => DocumentLibraryInfo.IndexName)" Required="true" />
        <MudTextField Label="Blob Storage Container Name" @bind-Value="DocumentLibraryInfo.BlobStorageContainerName" For="@(() => DocumentLibraryInfo.BlobStorageContainerName)" Required="true" />
        <MudTextField Label="Blob Storage Auto Import Folder Name" @bind-Value="DocumentLibraryInfo.BlobStorageAutoImportFolderName" For="@(() => DocumentLibraryInfo.BlobStorageAutoImportFolderName)" />

        <MudDivider Class="my-2" />

        <MudStack Row="true" Spacing="2">
            <MudButton OnClick="(()=>HandleValidSubmit())" Variant="Variant.Filled" Color="Color.Primary">Save</MudButton>
            <MudButton OnClick="@Cancel" Variant="Variant.Text" Color="Color.Default">Cancel</MudButton>
        </MudStack>
    </MudForm>
</MudPaper>

<MudDivider Class="my-4" />

<!-- File Upload Section -->
<MudPaper Class="pa-4">
    <MudFileUpload T="IReadOnlyList<IBrowserFile>" 
    FilesChanged="HandleFileSelected"
    MaximumFileCount="16384"
    >
        <ButtonTemplate>
            <MudButton HtmlTag="label"
            Variant="Variant.Filled"
            Color="Color.Primary"
            StartIcon="@Icons.Material.Filled.CloudUpload"
            for="@context">
                Upload Files to Document Library
            </MudButton>
        </ButtonTemplate>
    </MudFileUpload>
</MudPaper>


@if (IsEditMode)
{
    <MudDivider Class="my-4" />

    <!-- Associated Document Processes Section -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6">Associated Document Processes</MudText>

        <MudTable Items="AssociatedDocumentProcesses" Hover="true">
            <HeaderContent>
                <MudTh>Process Name</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Process Name">@context.ShortName</MudTd>
                <MudTd DataLabel="Actions">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="() => ConfirmDisassociateProcess(context.Id)" />
                </MudTd>
            </RowTemplate>
        </MudTable>

        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowAssociateProcessDialog">Associate Document Process</MudButton>
    </MudPaper>
}

@code {
    [Parameter]
    public DocumentLibraryInfo DocumentLibraryInfo { get; set; } = new DocumentLibraryInfo();

    [Parameter]
    public EventCallback<DocumentLibraryInfo> OnSaved { get; set; }

    private MudForm form = new();
    private string FormTitle => DocumentLibraryInfo.Id == Guid.Empty ? "Create Document Library" : "Edit Document Library";
    private bool IsEditMode => DocumentLibraryInfo.Id != Guid.Empty;

    private List<DocumentProcessInfo> AssociatedDocumentProcesses = new();
    private List<DocumentProcessInfo> AvailableDocumentProcesses = new();

    protected override async Task OnInitializedAsync()
    {
        if (IsEditMode)
        {
            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
        }
    }

    private void ValidateAndFormatShortName()
    {
        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name cannot be empty.", Severity.Error);
            return;
        }

        // Replace spaces with periods
        DocumentLibraryInfo.ShortName = DocumentLibraryInfo.ShortName.Replace(" ", ".");

        // Remove any characters that are not letters, digits, or periods
        DocumentLibraryInfo.ShortName = new string(DocumentLibraryInfo.ShortName.Where(c => char.IsLetterOrDigit(c) || c == '.').ToArray());

        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name must contain valid characters.", Severity.Error);
            return;
        }

        // After formatting ShortName, update IndexName and BlobStorageContainerName
        UpdateIndexAndBlobNames();
    }

    private void UpdateIndexAndBlobNames()
    {
        // Convert ShortName to lowercase and replace periods with dashes
        var formattedName = DocumentLibraryInfo.ShortName.ToLowerInvariant().Replace(".", "-");

        // Set IndexName and BlobStorageContainerName
        DocumentLibraryInfo.IndexName = $"index-additional-{formattedName}";
        DocumentLibraryInfo.BlobStorageContainerName = $"blob-additional-{formattedName}";
    }

    private async Task LoadAssociatedDocumentProcesses()
    {
        // Fetch associated document processes
        AssociatedDocumentProcesses = await DocumentLibraryApiClient.GetDocumentProcessesByLibraryIdAsync(DocumentLibraryInfo.Id);
    }

    private async Task LoadAvailableDocumentProcesses()
    {
        // Fetch all document processes and exclude those already associated
        var allProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
        AvailableDocumentProcesses = allProcesses.Where(p => AssociatedDocumentProcesses.All(ap => ap.Id != p.Id)).ToList();
    }

    private async Task HandleValidSubmit()
    {
        await form.Validate();

        if (form.IsValid)
        {
            if (DocumentLibraryInfo.Id == Guid.Empty)
            {
                // Create new document library
                var createdLibrary = await DocumentLibraryApiClient.CreateDocumentLibraryAsync(DocumentLibraryInfo);
                Snackbar.Add("Document Library saved", Severity.Success);
                DocumentLibraryInfo = createdLibrary;
                await OnSaved.InvokeAsync(createdLibrary);
                NavigationManager.NavigateTo($"/document-library/{DocumentLibraryInfo.Id}");
            }
            else
            {
                // Update existing document library
                var updatedLibrary = await DocumentLibraryApiClient.UpdateDocumentLibraryAsync(DocumentLibraryInfo);
                Snackbar.Add("Document Library updated", Severity.Success);
                await OnSaved.InvokeAsync(updatedLibrary);
            }

            // Reload associated processes after save
            if (IsEditMode)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
            }
        }
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/document-libraries");
    }

    private void ShowAssociateProcessDialog()
    {
        var parameters = new DialogParameters
        {
            { "AvailableProcesses", AvailableDocumentProcesses },
            { "DocumentLibraryId", DocumentLibraryInfo.Id }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<AssociateDocumentProcessWithDocumentLibraryDialog>("Associate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Cancelled)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
                StateHasChanged();
            }
        });
    }

    private void ConfirmDisassociateProcess(Guid processId)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", "Are you sure you want to disassociate this document process?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Disassociate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Cancelled)
            {
                await DisassociateProcess(processId);
                StateHasChanged();
            }
        });
    }

    private async Task DisassociateProcess(Guid processId)
    {
        try
        {
            await DocumentLibraryApiClient.DisassociateDocumentProcessAsync(DocumentLibraryInfo.Id, processId);
            Snackbar.Add("Document process disassociated successfully.", Severity.Success);

            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error disassociating document process: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleFileSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files == null || files.Count == 0)
        {
            Snackbar.Add("No files selected for upload.", Severity.Warning);
            return;
        }
        foreach (var file in files)
        {
            var fileName = $"{DocumentLibraryInfo.BlobStorageAutoImportFolderName}/{file.Name}";
            // URL encode the file name
            fileName = WebUtility.UrlEncode(fileName);
            
            try
            {
                var result = await FileApiClient.UploadFileDirectAsync(DocumentLibraryInfo.BlobStorageContainerName, fileName, file);
                Snackbar.Add($"File '{file.Name}' uploaded successfully.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error uploading file '{file.Name}': {ex.Message}", Severity.Error);
            }
        }
    }
}
