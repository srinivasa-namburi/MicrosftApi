@using System.Net
@inject IDocumentLibraryApiClient DocumentLibraryApiClient
@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject IFileApiClient FileApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@inject IDocumentReindexApiClient DocumentReindexApiClient
@using Microsoft.Greenlight.Shared.Enums
@using Microsoft.Greenlight.Shared.Contracts.DTO

<MudPaper Class="pa-4">
    <MudGrid>
        <MudItem xs="12">
            <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                <MudText Typo="Typo.h6">@FormTitle</MudText>
                <MudText Typo="Typo.body2" Class="text-right">
                    <strong>Logic Type:</strong> @DocumentLibraryInfo.LogicType.ToString()
                </MudText>
            </MudStack>
        </MudItem>
    </MudGrid>

    @if (IsEditMode)
    {
        <!-- Inline Reindex Status for this library and associated processes -->
        <MudGrid Class="mb-2">
            <MudItem xs="12">
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    <MudText Typo="Typo.subtitle2">Reindexing Status:</MudText>

                    @if (_libraryReindexStatus != null)
                    {
                        <MudChip Color="@GetStatusColor(_libraryReindexStatus.Status)" Variant="Variant.Filled">
                            Library: @_libraryReindexStatus.Status.ToString() (@_libraryReindexStatus.ProcessedDocuments/@_libraryReindexStatus.TotalDocuments)
                        </MudChip>
                        <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="OpenLibraryReindexProgress">View details</MudButton>
                    }
                    else
                    {
                        <MudChip Color="Color.Default" Variant="Variant.Outlined">No active reindex for library</MudChip>
                    }

                    @if (_processReindexStatuses.Any())
                    {
                        <MudDivider Vertical="true" Class="mx-2" />
                        @foreach (var kvp in _processReindexStatuses)
                        {
                            <MudChip Color="@GetStatusColor(kvp.Value.Status)" Variant="Variant.Filled" Class="mr-1">
                                Associated Document Process @kvp.Key: @kvp.Value.Status.ToString() (@kvp.Value.ProcessedDocuments/@kvp.Value.TotalDocuments)
                            </MudChip>
                            <MudButton Size="Size.Small" Variant="Variant.Text" OnClick="() => OpenProcessReindexProgress(kvp.Key)">View</MudButton>
                        }
                    }

                    <MudSpacer />
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh" Title="Refresh reindex status" OnClick="RefreshReindexStatusesAsync" />
                </MudStack>
            </MudItem>
        </MudGrid>
    }
    
    <MudForm @ref="form" Model="DocumentLibraryInfo">
        <MudTextField Label="Short Name" @bind-Value="DocumentLibraryInfo.ShortName" For="@(() => DocumentLibraryInfo.ShortName)" Required="true" OnBlur="ValidateAndFormatShortName" />
        <MudTextField Label="Description of Contents" @bind-Value="DocumentLibraryInfo.DescriptionOfContents" For="@(() => DocumentLibraryInfo.DescriptionOfContents)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Description of When to Use" @bind-Value="DocumentLibraryInfo.DescriptionOfWhenToUse" For="@(() => DocumentLibraryInfo.DescriptionOfWhenToUse)" Required="true" Lines="3" TextArea="true" />
        <MudTextField Label="Index Name" @bind-Value="DocumentLibraryInfo.IndexName" For="@(() => DocumentLibraryInfo.IndexName)" Required="true" />
        <MudTextField Label="Blob Storage Container Name" @bind-Value="DocumentLibraryInfo.BlobStorageContainerName" For="@(() => DocumentLibraryInfo.BlobStorageContainerName)" Required="true" />
        <MudTextField Label="Blob Storage Auto Import Folder Name" @bind-Value="DocumentLibraryInfo.BlobStorageAutoImportFolderName" For="@(() => DocumentLibraryInfo.BlobStorageAutoImportFolderName)" />
        
        @if (DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            <MudSelect T="TextChunkingMode?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkingMode" Label="Chunking Mode">
                @foreach (var mode in Enum.GetValues<TextChunkingMode>())
                {
                    <MudSelectItem Value="@(mode as TextChunkingMode?)">@mode.ToString()</MudSelectItem>
                }
            </MudSelect>
            
            <MudNumericField T="int?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkSize" 
                           Label="Chunk Size (tokens)" 
                           HelperText="Number of tokens per chunk. Leave empty to use global default."
                           Min="100" Max="8000" />
            
            <MudNumericField T="int?" @bind-Value="DocumentLibraryInfo.VectorStoreChunkOverlap" 
                           Label="Chunk Overlap (tokens)" 
                           HelperText="Number of overlapping tokens between chunks. Leave empty to use global default."
                           Min="0" Max="2000" />
                           
            <MudAlert Severity="Severity.Info" Class="mt-2">
                <strong>Note:</strong> Changing chunk size or overlap will only apply to newly ingested documents. 
                Existing documents in the index will retain their original chunking. 
                You can reindex existing documents to apply new chunk settings.
            </MudAlert>
        }

        @if (IsEditMode && DocumentLibraryInfo.LogicType == DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            <MudStack Class="mt-4" Spacing="2">
                <MudButton Variant="Variant.Filled" Color="Color.Warning" StartIcon="@Icons.Material.Filled.Refresh" OnClick="ShowReindexDialog">
                    Reindex Documents
                </MudButton>
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    This will recreate vector embeddings for all previously ingested documents in this library (using the currently set chunk size)
                </MudText>
            </MudStack>
        }

        <MudDivider Class="my-2" />

        <MudStack Row="true" Spacing="2">
            <MudButton OnClick="(()=>HandleValidSubmit())" Variant="Variant.Filled" Color="Color.Primary">Save</MudButton>
            <MudButton OnClick="@Cancel" Variant="Variant.Text" Color="Color.Default">Cancel</MudButton>
        </MudStack>
    </MudForm>
</MudPaper>

@if (IsEditMode)
{
    <MudDivider Class="my-4" />

    <!-- File Upload Section -->
    <MudPaper Class="pa-4">
        <MudFileUpload T="IReadOnlyList<IBrowserFile>"
                       FilesChanged="HandleFileSelected"
                       MaximumFileCount="16384">
            <ButtonTemplate>
                <MudButton HtmlTag="label"
                           Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.CloudUpload"
                           for="@context">
                    Upload Files to Document Library
                </MudButton>
            </ButtonTemplate>
        </MudFileUpload>
    </MudPaper>



    <MudDivider Class="my-4" />

    <!-- Associated Document Processes Section -->
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h6">Associated Document Processes</MudText>

        <MudTable Items="AssociatedDocumentProcesses" Hover="true">
            <HeaderContent>
                <MudTh>Process Name</MudTh>
                <MudTh>Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Process Name">@context.ShortName</MudTd>
                <MudTd DataLabel="Actions">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="() => ConfirmDisassociateProcess(context.Id)" />
                </MudTd>
            </RowTemplate>
        </MudTable>

        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="ShowAssociateProcessDialog">Associate Document Process</MudButton>
    </MudPaper>
}

@code {
    [Parameter]
    public DocumentLibraryInfo DocumentLibraryInfo { get; set; } = new DocumentLibraryInfo();

    [Parameter]
    public EventCallback<DocumentLibraryInfo> OnSaved { get; set; }

    private MudForm form = new();
    private string FormTitle => DocumentLibraryInfo.Id == Guid.Empty ? "Create Document Library" : "Edit Document Library";
    private bool IsEditMode => DocumentLibraryInfo.Id != Guid.Empty;

    private List<DocumentProcessInfo> AssociatedDocumentProcesses = new();
    private List<DocumentProcessInfo> AvailableDocumentProcesses = new();

    // Reindex status state
    private string LibraryOrchestrationId => string.IsNullOrWhiteSpace(DocumentLibraryInfo?.ShortName) ? string.Empty : $"library-{DocumentLibraryInfo.ShortName}";
    private DocumentReindexStateInfo? _libraryReindexStatus;
    private Dictionary<string, DocumentReindexStateInfo> _processReindexStatuses = new();

    protected override async Task OnInitializedAsync()
    {
        if (IsEditMode)
        {
            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
            await RefreshReindexStatusesAsync();
        }
    }

    private Color GetStatusColor(ReindexOrchestrationState status) => status switch
    {
        ReindexOrchestrationState.Running => Color.Info,
        ReindexOrchestrationState.Completed => Color.Success,
        ReindexOrchestrationState.Failed => Color.Error,
        _ => Color.Default
    };

    private async Task RefreshReindexStatusesAsync()
    {
        try
        {
            _libraryReindexStatus = null;
            _processReindexStatuses.Clear();

            if (!string.IsNullOrWhiteSpace(LibraryOrchestrationId))
            {
                _libraryReindexStatus = await DocumentReindexApiClient.GetReindexingStatusAsync(LibraryOrchestrationId);
            }

            foreach (var proc in AssociatedDocumentProcesses)
            {
                var procOrchId = $"process-{proc.ShortName}";
                var status = await DocumentReindexApiClient.GetReindexingStatusAsync(procOrchId);
                if (status != null && status.Status != ReindexOrchestrationState.NotStarted)
                {
                    _processReindexStatuses[proc.ShortName] = status;
                }
            }

            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error refreshing reindex statuses: {ex.Message}");
        }
    }

    private async Task OpenLibraryReindexProgress()
    {
        if (string.IsNullOrWhiteSpace(LibraryOrchestrationId)) return;

        var parameters = new DialogParameters
        {
            { "OrchestrationId", LibraryOrchestrationId },
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "Reason", _libraryReindexStatus?.Reason ?? string.Empty }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    private async Task OpenProcessReindexProgress(string processShortName)
    {
        var orchestrationId = $"process-{processShortName}";
        var parameters = new DialogParameters
        {
            { "OrchestrationId", orchestrationId },
            { "TargetName", processShortName },
            { "Reason", _processReindexStatuses.TryGetValue(processShortName, out var st) ? (st.Reason ?? string.Empty) : string.Empty }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexProgressDisplay>("Reindexing Progress", parameters, options);
    }

    private void ValidateAndFormatShortName()
    {
        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name cannot be empty.", Severity.Error);
            return;
        }

        // Replace spaces with periods
        DocumentLibraryInfo.ShortName = DocumentLibraryInfo.ShortName.Replace(" ", ".");

        // Remove any characters that are not letters, digits, or periods
        DocumentLibraryInfo.ShortName = new string(DocumentLibraryInfo.ShortName.Where(c => char.IsLetterOrDigit(c) || c == '.').ToArray());

        if (string.IsNullOrWhiteSpace(DocumentLibraryInfo.ShortName))
        {
            Snackbar.Add("Short Name must contain valid characters.", Severity.Error);
            return;
        }

        // After formatting ShortName, update IndexName and BlobStorageContainerName
        UpdateIndexAndBlobNames();
    }

    private void UpdateIndexAndBlobNames()
    {
        // Convert ShortName to lowercase and replace periods with dashes
        var formattedName = DocumentLibraryInfo.ShortName.ToLowerInvariant().Replace(".", "-");

        // Set IndexName and BlobStorageContainerName
        DocumentLibraryInfo.IndexName = $"index-additional-{formattedName}";
        DocumentLibraryInfo.BlobStorageContainerName = $"blob-additional-{formattedName}";
    }

    private async Task LoadAssociatedDocumentProcesses()
    {
        // Fetch associated document processes
        AssociatedDocumentProcesses = await DocumentLibraryApiClient.GetDocumentProcessesByLibraryIdAsync(DocumentLibraryInfo.Id);
    }

    private async Task LoadAvailableDocumentProcesses()
    {
        // Fetch all document processes and exclude those already associated
        var allProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
        AvailableDocumentProcesses = allProcesses.Where(p => AssociatedDocumentProcesses.All(ap => ap.Id != p.Id)).ToList();
    }

    private async Task HandleValidSubmit()
    {
        await form.Validate();

        if (form.IsValid)
        {
            if (DocumentLibraryInfo.Id == Guid.Empty)
            {
                // Create new document library
                var createdLibrary = await DocumentLibraryApiClient.CreateDocumentLibraryAsync(DocumentLibraryInfo);
                Snackbar.Add("Document Library saved", Severity.Success);
                DocumentLibraryInfo = createdLibrary;
                await OnSaved.InvokeAsync(createdLibrary);
                NavigationManager.NavigateTo($"/document-library/{DocumentLibraryInfo.Id}");
            }
            else
            {
                // Update existing document library
                var updatedLibrary = await DocumentLibraryApiClient.UpdateDocumentLibraryAsync(DocumentLibraryInfo);
                Snackbar.Add("Document Library updated", Severity.Success);
                await OnSaved.InvokeAsync(updatedLibrary);
            }

            // Reload associated processes after save
            if (IsEditMode)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
                await RefreshReindexStatusesAsync();
            }
        }
    }

    private void Cancel()
    {
        NavigationManager.NavigateTo("/document-libraries");
    }

    private void ShowAssociateProcessDialog()
    {
        var parameters = new DialogParameters
        {
            { "AvailableProcesses", AvailableDocumentProcesses },
            { "DocumentLibraryId", DocumentLibraryInfo.Id }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<AssociateDocumentProcessWithDocumentLibraryDialog>("Associate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await LoadAssociatedDocumentProcesses();
                await LoadAvailableDocumentProcesses();
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private void ConfirmDisassociateProcess(Guid processId)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", "Are you sure you want to disassociate this document process?" },
            { "ButtonText", "Disassociate" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = DialogService.Show<ConfirmationDialog>("Disassociate Document Process", parameters, options);

        dialog.Result.ContinueWith(async result =>
        {
            if (!result.Result.Canceled)
            {
                await DisassociateProcess(processId);
                await RefreshReindexStatusesAsync();
                StateHasChanged();
            }
        });
    }

    private async Task DisassociateProcess(Guid processId)
    {
        try
        {
            await DocumentLibraryApiClient.DisassociateDocumentProcessAsync(DocumentLibraryInfo.Id, processId);
            Snackbar.Add("Document process disassociated successfully.", Severity.Success);

            await LoadAssociatedDocumentProcesses();
            await LoadAvailableDocumentProcesses();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error disassociating document process: {ex.Message}", Severity.Error);
        }
    }

    private async Task HandleFileSelected(IReadOnlyList<IBrowserFile>? files)
    {
        if (files == null || files.Count == 0)
        {
            Snackbar.Add("No files selected for upload.", Severity.Warning);
            return;
        }
        foreach (var file in files)
        {
            var fileName = $"{DocumentLibraryInfo.BlobStorageAutoImportFolderName}/{file.Name}";
            // URL encode the file name
            fileName = WebUtility.UrlEncode(fileName);

            try
            {
                var result = await FileApiClient.UploadFileDirectAsync(DocumentLibraryInfo.BlobStorageContainerName, fileName, file);
                Snackbar.Add($"File '{file.Name}' uploaded successfully.", Severity.Success);
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error uploading file '{file.Name}': {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task ShowReindexDialog()
    {
        if (!IsEditMode || DocumentLibraryInfo.LogicType != DocumentProcessLogicType.SemanticKernelVectorStore)
        {
            return;
        }

        var parameters = new DialogParameters
        {
            { "TargetName", DocumentLibraryInfo.ShortName },
            { "IsDocumentProcess", false },
            { "Reason", "Manual reindexing" },
            { "WarningMessage", "This will delete and rebuild the library repository index." }
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        await DialogService.ShowAsync<DocumentReindexConfirmationDialog>("Reindex Documents", parameters, options);
    }
}
