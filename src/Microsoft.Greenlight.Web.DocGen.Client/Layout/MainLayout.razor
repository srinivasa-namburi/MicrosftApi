@* Copyright (c) Microsoft Corporation. All rights reserved. *@
@inherits LayoutComponentBase
@implements IDisposable
@using Microsoft.AspNetCore.SignalR.Client
@inject ILogger<MainLayout> Logger
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject SignalRConnectionService SignalRConnectionService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IPermissionService PermissionService
@using Microsoft.Greenlight.Shared.Contracts.DTO.Auth
@using Microsoft.Greenlight.Web.DocGen.Client.ServiceClients

<MyMudThemeProvider @bind-IsDarkMode="@IsDarkMode" />
<MyMudProviders />

@if (_isInitializing)
{
    <div class="loading-container d-flex justify-center align-center" style="height: 100vh;">
        <MudStack Spacing="3" AlignItems="AlignItems.Center">
            <MudProgressCircular Color="Color.Primary" Indeterminate="true" Size="Size.Large" />
            <MudText Typo="Typo.h6">Loading application...</MudText>
        </MudStack>
    </div>
}
else
{
    <MudLayout Class="@(IsDarkMode ? "dark-mode" : "light-mode")" data-testid="main-layout">
        <MudAppBar Elevation="3" Style="height: 48px; min-height: 48px;">
            <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Style="width: 100%; height: 100%; padding: 0 8px;">
                <MudIconButton Icon="@Icons.Material.Filled.Menu" Color="Color.Inherit" Edge="Edge.Start" Size="Size.Medium" OnClick="@((e) => ToggleDrawer())" />
                <AppBarUserArea @bind-IsDarkMode="IsDarkMode" />
            </MudStack>
        </MudAppBar>
        <MudDrawer @bind-Open="_drawerOpen"
                   Elevation="3"
                   Variant="DrawerVariant.Persistent"
                   ClipMode="DrawerClipMode.Always"
                   Width="270px">
            <MudDrawerHeader Class="d-flex align-center pa-3" Style="height: 48px; min-height: 48px;">
                <MudStack Row AlignItems="AlignItems.Center" Spacing="2" Style="flex-grow: 1;">
                    <MudIcon Icon="@Icons.Material.Filled.Science" Color="Color.Primary" Size="Size.Small" />
                    <MudText Typo="Typo.subtitle1" Class="flex-grow-1">@_siteName</MudText>
                </MudStack>
            </MudDrawerHeader>
            <NavMenu />
        </MudDrawer>
        <CascadingValue TValue="HubConnection" Value="@HubConnection">
            <CascadingValue Name="IsDarkMode" Value="IsDarkMode">
                <MudMainContent>
                    <MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="pa-4">
                        @Body
                    </MudContainer>
                </MudMainContent>
            </CascadingValue>
        </CascadingValue>
        <FloatingAiAssistant />
    </MudLayout>
}

@code {
    private bool _isInitializing = true;
    private bool _drawerOpen = true;

    private string _siteName = "Generative AI for Industry Permitting";

    public bool IsDarkMode { get; set; } = true;
    public HubConnection? HubConnection { get; set; }

    void ToggleDrawer()
    {
        _drawerOpen = !_drawerOpen;
    }

    protected override async Task OnInitializedAsync()
    {
        Logger.LogInformation("MainLayout initialization starting");

        try
        {
            // Step 1: Load site name from configuration
            await LoadSiteNameAsync();

            // Step 2: Check authentication and preload permissions
            await PreloadUserDataAsync();

            // Step 3: Start SignalR connections if authenticated
            await StartHubConnectionsAsync();

            Logger.LogInformation("MainLayout initialization completed");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error during MainLayout initialization");
        }
        finally
        {
            _isInitializing = false;
            StateHasChanged();
        }

        // Listen for auth state changes for future updates
        AuthenticationStateProvider.AuthenticationStateChanged += OnAuthenticationStateChanged;
    }

    private async Task LoadSiteNameAsync()
    {
        try
        {
            var frontendOptions = await ConfigurationApiClient.GetFrontEndAsync();
            _siteName = frontendOptions.SiteName;
            Logger.LogDebug("Site name loaded: {SiteName}", _siteName);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to get site name from configuration API, keeping default name");
        }
    }

    private async Task PreloadUserDataAsync()
    {
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;

            if (user.Identity?.IsAuthenticated == true)
            {
                Logger.LogInformation("User authenticated, preloading permissions");

                // Preload permissions early to populate the cache
                // This prevents multiple API calls when NavMenu components check permissions
                await PreloadPermissionsAsync();
                
                // Push user access token to backend for Orleans/MCP usage
                await PushUserTokenAsync();
            }
            else
            {
                Logger.LogInformation("User not authenticated, skipping permission preload");
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error during user data preload");
        }
    }

    private async Task PreloadPermissionsAsync()
    {
        try
        {
            Logger.LogInformation("Preloading user permissions to populate cache");
            var permissions = await PermissionService.GetUserPermissionsAsync();
            Logger.LogInformation("Successfully preloaded {PermissionCount} permissions", permissions.Count);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to preload permissions, will be loaded on demand");
        }
    }

    private async Task PushUserTokenAsync()
    {
        try
        {
            Logger.LogInformation("Pushing user access token to backend for Orleans/MCP usage");

            // Get the access token from the client-side authentication state
            var accessToken = await ((AuthorizationApiClient)AuthorizationApiClient).GetAccessTokenAsync();
            
            // Get user information from authentication state
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            var providerSubjectId = user.FindFirst("sub")?.Value;

            if (string.IsNullOrWhiteSpace(providerSubjectId))
            {
                Logger.LogWarning("Cannot push user token - missing subject ID");
                return;
            }

            if (string.IsNullOrWhiteSpace(accessToken))
            {
                Logger.LogWarning("Cannot push user token - missing access token");
                return;
            }

            // Create the token DTO
            var tokenDto = new UserTokenDTO
            {
                ProviderSubjectId = providerSubjectId,
                AccessToken = accessToken,
                ExpiresOnUtc = null // We don't have expiry information from the client-side token
            };

            // Use the client-side API client with proper authorization
            await AuthorizationApiClient.SetUserTokenAsync(tokenDto);

            Logger.LogInformation("Successfully pushed user access token for subject {Subject}", providerSubjectId);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to push user token to backend - will retry on next authentication state change");
        }
    }

    private async Task StartHubConnectionsAsync()
    {
        try
        {
            // Use the shared connection service to ensure a single shared HubConnection instance
            HubConnection = await SignalRConnectionService.GetOrCreateAsync();
            Logger.LogDebug("SignalR connections established");
        }
        catch (InvalidOperationException)
        {
            // User isn't authenticated yet - ignore.
            Logger.LogDebug("SignalR connection skipped - user not authenticated");
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to establish SignalR connections");
        }
    }


    private async void OnAuthenticationStateChanged(Task<AuthenticationState> task)
    {
        try
        {
            var state = await task;
            if (state.User.Identity?.IsAuthenticated == true)
            {
                Logger.LogInformation("Auth state changed: user signed in; refreshing data");

                // Preload permissions for the newly authenticated user
                await PreloadPermissionsAsync();

                // Push user access token to backend for Orleans/MCP usage
                await PushUserTokenAsync();

                // (Re)start hub connections when user signs in
                try { await StartHubConnectionsAsync(); } catch (InvalidOperationException) { /* ignore */ }
            }
            else
            {
                Logger.LogInformation("Auth state changed: user signed out; invalidating cache");

                // Invalidate permission cache when user signs out
                await PermissionService.InvalidatePermissionCacheAsync();
            }
        }
        catch (Exception ex)
        {
            Logger.LogDebug(ex, "Authentication state changed handler failed");
        }
    }

    public void Dispose()
    {
        AuthenticationStateProvider.AuthenticationStateChanged -= OnAuthenticationStateChanged;
    }
}
