@page "/document-processes"
@using System.Text.Json

@inject IDocumentProcessApiClient DocumentProcessApiClient
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject NavigationManager Navigation

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    <MudPaper Class="pa-4">
        <MudDataGrid Items="_documentProcesses"
                     T="DocumentProcessInfo"
                     Hover="true"
                     Filterable="false"
                     SortMode="SortMode.Single"
                     Groupable="false"
                     RowClick="@RowClicked"
                     Dense="true">
            <ToolBarContent>
                <MudText Typo="Typo.h6">Document Processes</MudText>
                <MudSpacer />
                <MudButton Variant="Variant.Outlined" Color="Color.Secondary" OnClick="OpenImportDialog">Import</MudButton>
                <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="AddProcess">Add New Process</MudButton>
            </ToolBarContent>
            <Columns>
                <PropertyColumn Property="x => x.ShortName" Title="Short Name" />
                <PropertyColumn Property="x => x.Description" Title="Description" />
                <PropertyColumn Property="x => x.LogicType" Title="Logic Type" />
                <TemplateColumn Title="Actions" CellClass="d-flex justify-end">
                    <CellTemplate>
                        <MudStack Row="true" Spacing="3">
                            <MudTooltip Delay="400" Text="Edit Document Process">
                                <MudIconButton Disabled="@IsStaticProcess(context.Item)" OnClick="() => EditProcess(context.Item.Id)" Size="@Size.Small" Icon="@Icons.Material.Filled.StickyNote2"></MudIconButton>
                            </MudTooltip>
                            <MudTooltip Delay="400" Text="Delete Document Process (you will be asked to confirm)">
                                <MudIconButton Disabled="@IsStaticProcess(context.Item)" OnClick="() => ShowDeleteConfirmation(context.Item)" Size="@Size.Small" Icon="@Icons.Material.Filled.Delete"></MudIconButton>
                            </MudTooltip>
                            <MudTooltip Delay="400" Text="Export Document Process as Json (you will be asked to confirm)">
                                <MudIconButton Disabled="@IsStaticProcess(context.Item)" OnClick="() => ExportProcess(context.Item.Id)" Size="@Size.Small" Icon="@Icons.Material.Filled.ArrowDownward"></MudIconButton>
                            </MudTooltip>
                        </MudStack>
                    </CellTemplate>
                </TemplateColumn>
            </Columns>
        </MudDataGrid>
    </MudPaper>
</MudContainer>

@code {
    private List<DocumentProcessInfo> _documentProcesses = new();
    private Guid? SelectedProcessId;

    protected override async Task OnInitializedAsync()
    {
        _documentProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
    }

    private async Task OpenImportDialog()
    {
        var parameters = new DialogParameters
        {
            ["IsProcessMode"] = true
        };
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Medium, FullWidth = true };
        var dialog = await DialogService.ShowAsync<Microsoft.Greenlight.Web.DocGen.Client.Components.Definitions.ImportDefinitionDialog>("Import Document Process", parameters, options);
        var result = await dialog.Result;
        if (!result.Canceled)
        {
            _documentProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
            await InvokeAsync(StateHasChanged);
        }
    }

    private void AddProcess()
    {
        Navigation.NavigateTo("/document-processes/edit");
    }

    private void EditProcess(Guid processId)
    {
        Navigation.NavigateTo($"/document-processes/edit/{processId}");
    }

    private async Task ExportProcess(Guid processId)
    {
        var documentProcess = await DocumentProcessApiClient.ExportDocumentProcessByIdAsync(processId);
        var json = JsonSerializer.Serialize(documentProcess, new JsonSerializerOptions { WriteIndented = true });
        //var fileName = $"{documentProcess.ShortName}.json";
        //await JSRuntime.InvokeVoidAsync("downloadFile", fileName, json);
    }

    private async Task ShowDeleteConfirmation(DocumentProcessInfo process)
    {
        var parameters = new DialogParameters
        {
            { "ContentText", $"Are you sure you want to delete the document process '{process.ShortName}'? This deletes the vector index/collection (if SK), its blob container and all ingested document records." },
            { "ButtonText", "Delete" },
            { "DialogColor", Color.Error }
        };

        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.Small, FullWidth = true };
        var dialog = await DialogService.ShowAsync<ConfirmationDialog>("Delete Document Process", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await DeleteDocumentProcess(process.Id);
        }
    }

    private async Task DeleteDocumentProcess(Guid processId)
    {
        if (processId != Guid.Empty)
        {
            var deleteResult = await DocumentProcessApiClient.DeleteDocumentProcessAsync(processId);
            if (deleteResult)
            {
                _documentProcesses = await DocumentProcessApiClient.GetAllDocumentProcessInfoAsync();
                Snackbar.Add("Document process deleted successfully.", Severity.Success);
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                Snackbar.Add("Document process NOT deleted due to an error", Severity.Error);
            }
        }
    }

    private void RowClicked(DataGridRowClickEventArgs<DocumentProcessInfo> args)
    {
        if (!IsStaticProcess(args.Item))
        {
            EditProcess(args.Item.Id);
        }
    }

    private bool IsStaticProcess(DocumentProcessInfo process)
    {
        return process.Source == ProcessSource.Static;
    }
}
