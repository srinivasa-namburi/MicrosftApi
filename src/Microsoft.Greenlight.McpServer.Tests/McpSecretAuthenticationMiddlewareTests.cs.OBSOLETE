// Copyright (c) Microsoft Corporation. All rights reserved.
using System.Security.Claims;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.Greenlight.McpServer.Flow.Auth;
using Microsoft.Greenlight.Shared.Configuration;
using System.Net.Http.Json;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.TestHost;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Greenlight.McpServer.Flow.Services;
using Moq;
using Microsoft.EntityFrameworkCore;
using Microsoft.Greenlight.Shared.Data.Sql;
using Microsoft.Greenlight.Shared.Models.Configuration;
using Microsoft.Greenlight.Shared.Services.Security;
using Microsoft.Extensions.Primitives;

namespace Microsoft.Greenlight.McpServer.Tests;

public class McpSecretAuthenticationMiddlewareTests
{
    private sealed class TestOptionsMonitor : IOptionsMonitor<ServiceConfigurationOptions.McpOptions>
    {
        public ServiceConfigurationOptions.McpOptions CurrentValue { get; }
        public TestOptionsMonitor(ServiceConfigurationOptions.McpOptions value) => CurrentValue = value;
        public ServiceConfigurationOptions.McpOptions Get(string? name) => CurrentValue;
        public IDisposable? OnChange(Action<ServiceConfigurationOptions.McpOptions, string?> listener) => null;
    }

    private static DefaultHttpContext CreateContext(string path)
    {
        var ctx = new DefaultHttpContext();
        ctx.Request.Path = path;
        return ctx;
    }

    [Fact]
    public async Task SecretAuth_Succeeds_SetsPrincipalAndCallsNext()
    {
        var plainSecret = "s3cret";
        var userOid = "test-user-oid";
        var secretName = "test-secret";
        var salt = "test-salt";
        var hash = "test-hash";
        
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true,
            SecretHeaderName = "X-MCP-Secret"
        };

        // Setup in-memory database
        var dbOptions = new DbContextOptionsBuilder<DocGenerationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        using var dbContext = new DocGenerationDbContext(dbOptions);
        await dbContext.Database.EnsureCreatedAsync();
        
        var mcpSecret = new McpSecret
        {
            Name = secretName,
            ProviderSubjectId = userOid,
            SecretSalt = salt,
            SecretHash = hash,
            IsActive = true
        };
        dbContext.Set<McpSecret>().Add(mcpSecret);
        await dbContext.SaveChangesAsync();

        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        mockDbContextFactory.Setup(f => f.CreateDbContextAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(() => new DocGenerationDbContext(dbOptions));

        var mockHashingService = new Mock<ISecretHashingService>();
        mockHashingService.Setup(h => h.Verify(plainSecret, salt, hash)).Returns(true);

        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => Task.CompletedTask,
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/mcp/tools");
        context.Request.Headers[options.SecretHeaderName!] = plainSecret;

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.True(context.User?.Identity?.IsAuthenticated, "User should be authenticated with valid database-backed secret.");
        Assert.Equal("McpSecret", context.User?.Identity?.AuthenticationType);
        Assert.Equal(userOid, context.User?.FindFirst("oid")?.Value);
        Assert.Equal(secretName, context.User?.FindFirst("mcp_secret_name")?.Value);
        Assert.Equal("secret", context.User?.FindFirst("mcp_auth")?.Value);
    }

    [Fact]
    public async Task SecretAuth_WithCustomHeaderName_Succeeds()
    {
        var plainSecret = "custom-secret";
        var userOid = "custom-user-oid";
        var secretName = "custom-secret";
        var salt = "custom-salt";
        var hash = "custom-hash";
        var customHeaderName = "X-Custom-API-Key";
        
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true,
            SecretHeaderName = customHeaderName
        };

        // Setup in-memory database
        var dbOptions = new DbContextOptionsBuilder<DocGenerationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        using var dbContext = new DocGenerationDbContext(dbOptions);
        await dbContext.Database.EnsureCreatedAsync();
        
        var mcpSecret = new McpSecret
        {
            Name = secretName,
            ProviderSubjectId = userOid,
            SecretSalt = salt,
            SecretHash = hash,
            IsActive = true
        };
        dbContext.Set<McpSecret>().Add(mcpSecret);
        await dbContext.SaveChangesAsync();

        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        mockDbContextFactory.Setup(f => f.CreateDbContextAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(() => new DocGenerationDbContext(dbOptions));

        var mockHashingService = new Mock<ISecretHashingService>();
        mockHashingService.Setup(h => h.Verify(plainSecret, salt, hash)).Returns(true);

        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => Task.CompletedTask,
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/mcp/tools");
        context.Request.Headers[customHeaderName] = plainSecret;

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.True(context.User?.Identity?.IsAuthenticated);
        Assert.Equal("McpSecret", context.User?.Identity?.AuthenticationType);
        Assert.Equal(userOid, context.User?.FindFirst("oid")?.Value);
    }

    [Fact]
    public async Task SecretAuth_InactiveSecret_Returns401()
    {
        var plainSecret = "inactive-secret";
        var salt = "test-salt";
        var hash = "test-hash";
        
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true,
            SecretHeaderName = "X-MCP-Secret"
        };

        // Setup in-memory database with inactive secret
        var dbOptions = new DbContextOptionsBuilder<DocGenerationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        using var dbContext = new DocGenerationDbContext(dbOptions);
        await dbContext.Database.EnsureCreatedAsync();
        
        var mcpSecret = new McpSecret
        {
            Name = "inactive-secret",
            ProviderSubjectId = "test-user",
            SecretSalt = salt,
            SecretHash = hash,
            IsActive = false // Inactive!
        };
        dbContext.Set<McpSecret>().Add(mcpSecret);
        await dbContext.SaveChangesAsync();

        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        mockDbContextFactory.Setup(f => f.CreateDbContextAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(() => new DocGenerationDbContext(dbOptions));

        var mockHashingService = new Mock<ISecretHashingService>();
        mockHashingService.Setup(h => h.Verify(plainSecret, salt, hash)).Returns(true);

        var calledNext = false;
        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => { calledNext = true; return Task.CompletedTask; },
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/mcp/sse");
        context.Request.Headers[options.SecretHeaderName!] = plainSecret;

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.Equal(StatusCodes.Status401Unauthorized, context.Response.StatusCode);
        Assert.False(calledNext);
    }

    [Fact]
    public async Task SecretAuth_DisabledAuth_AllowsAccessWithoutSecret()
    {
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true,
            DisableAuth = true
        };

        // Setup empty database
        var dbOptions = new DbContextOptionsBuilder<DocGenerationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        using var dbContext = new DocGenerationDbContext(dbOptions);
        await dbContext.Database.EnsureCreatedAsync();

        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        mockDbContextFactory.Setup(f => f.CreateDbContextAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(() => new DocGenerationDbContext(dbOptions));

        var mockHashingService = new Mock<ISecretHashingService>();

        var calledNext = false;
        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => { calledNext = true; return Task.CompletedTask; },
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/mcp/tools");
        // No secret header provided

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.Equal(StatusCodes.Status401Unauthorized, context.Response.StatusCode);
        Assert.False(calledNext);
    }

    [Fact]
    public async Task SecretAuth_NonMcpPath_SkipsAuthentication()
    {
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true
        };

        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        var mockHashingService = new Mock<ISecretHashingService>();

        var calledNext = false;
        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => { calledNext = true; return Task.CompletedTask; },
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/api/health");

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.True(calledNext);
        Assert.False(context.User?.Identity?.IsAuthenticated ?? false);
        mockDbContextFactory.Verify(f => f.CreateDbContextAsync(It.IsAny<CancellationToken>()), Times.Never);
    }

    [Fact]
    public async Task SecretAuth_InvalidSecret_Returns401_DoesNotCallNext()
    {
        var calledNext = false;
        var invalidSecret = "invalid-secret";
        var salt = "test-salt";
        var hash = "test-hash";
        
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true,
            SecretHeaderName = "X-MCP-Secret"
        };

        // Setup in-memory database
        var dbOptions = new DbContextOptionsBuilder<DocGenerationDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;

        using var dbContext = new DocGenerationDbContext(dbOptions);
        await dbContext.Database.EnsureCreatedAsync();
        
        var mcpSecret = new McpSecret
        {
            Name = "test-secret",
            ProviderSubjectId = "test-user-oid", 
            SecretSalt = salt,
            SecretHash = hash,
            IsActive = true
        };
        dbContext.Set<McpSecret>().Add(mcpSecret);
        await dbContext.SaveChangesAsync();

        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        mockDbContextFactory.Setup(f => f.CreateDbContextAsync(It.IsAny<CancellationToken>()))
            .ReturnsAsync(() => new DocGenerationDbContext(dbOptions));

        var mockHashingService = new Mock<ISecretHashingService>();
        // Invalid secret doesn't match any hash
        mockHashingService.Setup(h => h.Verify(invalidSecret, salt, hash)).Returns(false);

        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => { calledNext = true; return Task.CompletedTask; },
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/mcp/sse");
        context.Request.Headers[options.SecretHeaderName!] = invalidSecret;

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.Equal(StatusCodes.Status401Unauthorized, context.Response.StatusCode);
        Assert.False(calledNext);
    }

    [Fact]
    public async Task SecretAuth_DoesNotOverrideAuthenticatedUser()
    {
        var calledNext = false;
        var options = new ServiceConfigurationOptions.McpOptions
        {
            SecretEnabled = true,
            SecretHeaderName = "X-MCP-Secret"
        };

        // Setup mocks (they won't be called since user is already authenticated)
        var mockDbContextFactory = new Mock<IDbContextFactory<DocGenerationDbContext>>();
        var mockHashingService = new Mock<ISecretHashingService>();

        using var lf = LoggerFactory.Create(builder => { });
        var middleware = new McpSecretAuthenticationMiddleware(_ => { calledNext = true; return Task.CompletedTask; },
            lf.CreateLogger<McpSecretAuthenticationMiddleware>());

        var context = CreateContext("/mcp/tools");
        // Pre-authenticate user (e.g., via JWT)
        context.User = new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Name, "jwt-user") }, authenticationType: "Jwt"));
        context.Request.Headers[options.SecretHeaderName!] = "some-secret";

        var config = new ConfigurationBuilder().Build();
        var optMonitor = new TestOptionsMonitor(options);

        await middleware.InvokeAsync(context, config, optMonitor, mockDbContextFactory.Object, mockHashingService.Object);

        Assert.True(calledNext);
        Assert.Equal("Jwt", context.User?.Identity?.AuthenticationType);
        Assert.Null(context.User?.FindFirst("oid"));
    }
}
