@using Microsoft.AspNetCore.SignalR.Client
@using ProjectVico.V2.Shared.Contracts.Chat
@using ProjectVico.V2.Shared.Contracts.DTO
@using ProjectVico.V2.Shared.Contracts.Messages.Chat.Commands
@using ProjectVico.V2.Shared.Contracts.Messages.Chat.Events
@using ProjectVico.V2.Shared.Models.Enums
@using ProjectVico.V2.Web.Shared.Auth
@using ProjectVico.V2.Web.Shared.ServiceClients
@using Color = MudBlazor.Color

@inject IConfiguration Configuration
@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime

@implements IDisposable

@code {
    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public EventCallback<Guid?> ConversationIdChanged { get; set; }
    /// <summary>
    /// This sets the ExternalReferenceId for the conversation. This is used to link the conversation to an external reference.
    /// Used in combination with the ExternalReferenceType parameter. null by default.
    /// </summary>
    [Parameter] public Guid? ExternalReferenceId { get; set; }

    /// <summary>
    /// If this is set to true, a new ConversationId will be created by the component if not set.
    /// It is false by default.
    /// </summary>
    [Parameter] public bool InternalConversationIdCreate { get; set; } = false;

    [CascadingParameter] public AuthenticationState? AuthenticationState { get; set; }

    private string? apiSignalRAddressBase;
    private HubConnection? hubConnection;

    private MudTextField<string> _mudChatTextField;
    private ElementReference _messagesContainer;
    private MudList _mudMessageList;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private UserInfoDTO? CurrentUser { get; set; }

}

@if (ConversationId.HasValue)
{
    <MudGrid>
        <MudItem xs="12">
            <div @ref="_messagesContainer" style="border: 3px solid #ddd; padding: 10px; overflow-y: auto; height: 550px;">
                <MudList @ref="_mudMessageList" Dense="true" DisablePadding="true">
                    @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedAt))
                    {
                        <MudListItem>
                            @if (chatMessage.Source == ChatMessageSource.User)
                            {
                                var align = chatMessage.UserId == CurrentUser?.ProviderSubjectId ? Align.Right : Align.Left;

                                <MudText Typo="Typo.body2" Class="my-0" Align="@align" Color="@Color.Info">@chatMessage.CreatedAt.ToString("MM/dd/yyyy HH:mm:ss")</MudText>
                                if (!string.IsNullOrEmpty(chatMessage.UserFullName))
                                {
                                    <MudText Typo="Typo.body2" Class="my-0" Align="@align" Color="@Color.Info">@chatMessage.UserFullName</MudText>
                                }

                                <MudText Typo="Typo.body1" Class="my-0 mb-n1" Align="@align">@chatMessage.Message</MudText>
                            }
                            else
                            {
                                <MudText Typo="Typo.body2" Class="my-0" Align="Align.Left" Color="@Color.Info">@chatMessage.CreatedAt.ToString("MM/dd/yyyy HH:mm:ss")</MudText>
                                <MudText Typo="Typo.body2" Class="my-0" Align="Align.Left" Color="@Color.Info">Nuclear CoPilot</MudText>
                                <MudText Typo="Typo.body1" Class="my-0 mb-n1" Align="Align.Left">
                                    <RenderMultilineText Value="@chatMessage.Message"/>
                                </MudText>
                            }
                        </MudListItem>
                    }
                </MudList>
            </div>

            @if (CurrentUser == null)
            {
                <MudText>Waiting for user information to load...</MudText>
            }
            else
            {
                <MudTextField @ref="_mudChatTextField" T="string" ValueChanged="OnChatTextFieldUpdated"
                              AutoFocus="true" FullWidth="true" Placeholder="Type a message..."
                              AdornmentIcon="@Icons.Material.Filled.Send"
                              AdornmentColor="Color.Primary"
                              Adornment="Adornment.End"/>
            }

        </MudItem>
    </MudGrid>
}
else
{
    <MudText Typo="Typo.h6">No conversation loaded</MudText>
}

@code
{
    protected override async Task OnInitializedAsync()
    {
        if (!ConversationId.HasValue && InternalConversationIdCreate)
        {
            ConversationId = Guid.NewGuid();
        }
       
        if (ConversationId.HasValue)
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var userInfo = UserInfo.FromClaimsPrincipal(authState.User);
            CurrentUser = await AuthorizationApiClient.GetUserInfo(userInfo.UserId);
            ChatMessages = await ChatApiClient.GetChatMessages(ConversationId.Value);
            await StartHubConnections(await ChatApiClient.GetAccessTokenAsync());
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections(string token)
    {
        //TODO: This is a hack because SignalR can't use Service Discovery yet
        apiSignalRAddressBase = Configuration["services:api-main:0"];

        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri($"{apiSignalRAddressBase}/hubs/notification-hub"), options =>
            {
                options.AccessTokenProvider = () => Task.FromResult(token)!;
            })
            .WithStatefulReconnect()
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<ChatMessageResponseReceived>( // CorrelationId
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        hubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        await hubConnection.StartAsync();

        // Add this Hub Connection to a group matching the ConversationId
        await hubConnection.SendAsync("AddToGroup", ConversationId);
    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        // The message may originate from us. If so, we don't need to process it. Check if the message ID already exists in the conversation.
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        // If a message already exists in our ChatMessages list with the same Id, update it
        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            // In case we received messages out of order, only update the message if this message has longer content
            if (existingMessage.Message.Length < obj.ChatMessageDto.Message.Length)
            {
                existingMessage.Message = obj.ChatMessageDto.Message;
            }
        }
        else
        {
            // Insert the ChatMessage directly after the ChatMessage it is replying to
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);

                // If the replyToMessage is the last message in the list, just add the new message to the end
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();

    }

    private async Task OnChatTextFieldUpdated(string chatText)
    {
        if (string.IsNullOrWhiteSpace(chatText))
        {
            return;
        }

        var chatMessage = new ChatMessageDTO
            {
                ConversationId = ConversationId!.Value,
                Id = Guid.NewGuid(),
                Message = chatText,
                CreatedAt = DateTime.UtcNow,
                Source = ChatMessageSource.User,
                UserId = CurrentUser!.ProviderSubjectId,
                UserFullName = CurrentUser!.FullName
            };

        await ProcessMessage(chatMessage);
    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        // Append the message according to its CreatedAt date - directly following the message with a CreatedAt date lower than this message
        var index = ChatMessages.FindLastIndex(x => x.CreatedAt < chatMessageDto.CreatedAt);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            // If the message is the last message in the list, just add the new message to the end
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();

    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await ChatApiClient.SendChatMessage(chatMessageDto);

            await _mudChatTextField.FocusAsync();
            await _mudChatTextField.Clear();
        }

    }

    private async Task ScrollMessagesToBottom()
    {
        await JSRuntime.InvokeVoidAsyncIgnoreErrors("scrollToBottom", _messagesContainer);
    }

    private async Task OnConversationIdChanged(Guid? conversationId)
    {
        if (conversationId.HasValue)
        {
            ConversationId = conversationId;
            await ConversationIdChanged.InvokeAsync(conversationId);

            ChatMessages = await ChatApiClient.GetChatMessages(conversationId.Value);
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        if (hubConnection == null) return;

        hubConnection.SendAsync("RemoveFromGroup", ConversationId);
        hubConnection.DisposeAsync().AsTask();
    }
}
