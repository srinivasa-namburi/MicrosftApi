@inject IConfiguration Configuration
@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime

@using Microsoft.AspNetCore.SignalR.Client
@using ProjectVico.V2.Shared.Contracts.Chat
@using ProjectVico.V2.Shared.Contracts.Messages.Chat.Commands
@using ProjectVico.V2.Shared.Contracts.Messages.Chat.Events
@using ProjectVico.V2.Shared.Enums
@using ProjectVico.V2.Web.Shared.Auth
@implements IAsyncDisposable

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: calc(90vh - 120px); /* Adjust 20px based on your specific padding/margins */
        margin: 10px; /* Adjust based on your specific layout needs */
    }

    .messages-container {
        flex: 1 1 auto;
        border: 3px solid #ddd;
        padding: 10px;
        overflow-y: auto;
    }

    .input-container {
        flex: 0 0 auto;
        display: flex;
        align-items: center;
        padding-top: 10px;
    }
</style>

@code {
    [CascadingParameter] public AuthenticationState? AuthenticationState { get; set; }
    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    [Parameter] public Guid? ConversationId { get; set; }
    [Parameter] public string? DocumentProcessName { get; set; }

    /// <summary>
    /// This sets the ExternalReferenceId for the conversation. This is used to link the conversation to an external reference.
    /// Used in combination with the ExternalReferenceType parameter. null by default.
    /// </summary>
    [Parameter] public Guid? ExternalReferenceId { get; set; }

    /// <summary>
    /// If this is set to true, a new ConversationId will be created by the component if not set.
    /// It is false by default.
    /// </summary>
    [Parameter] public bool InternalConversationIdCreate { get; set; } = false;

    private MudTextField<string> _mudChatTextField;
    private string _chatTextInput = string.Empty;
    private bool _chatTextLastKeyWasEnter = false;
    private ElementReference _messagesContainer;
    private MudList _mudMessageList;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private UserInfoDTO? CurrentUser { get; set; }

}

@if (ConversationId.HasValue)
{
    <div class="chat-container">
        <div @ref="_messagesContainer" class="messages-container">
            <MudList @ref="_mudMessageList" Dense="true" DisablePadding="true">
                @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedAt))
                {
                    <MudListItem>
                        <ChatMessageDisplay ChatMessage="@chatMessage" CurrentUser="CurrentUser" />
                    </MudListItem>
                }
            </MudList>
        </div>

        @if (CurrentUser == null)
        {
            <MudText>Waiting for user information to load...</MudText>
        }
        else
        {
            <div class="input-container">
                <MudTextField @ref="_mudChatTextField" T="string"
                              OnKeyDown="OnChatTextKeyDown"
                              ValueChanged="OnChatTextFieldUpdated"
                              Immediate="false"
                              DebounceInterval="100"
                              Lines="2"
                              MaxLines="6"
                              AutoGrow="true"
                              AutoFocus="true" FullWidth="true" Placeholder="Type a message..."
                              AdornmentIcon="@Icons.Material.Filled.Send"
                              AdornmentColor="Color.Primary"
                              Adornment="Adornment.End" />
            </div>
        }
    </div>
}
else
{
    <MudText Typo="Typo.h6">No conversation loaded</MudText>
}

@code
{
    protected override async Task OnInitializedAsync()
    {
        if (!ConversationId.HasValue && InternalConversationIdCreate)
        {
            ConversationId = Guid.NewGuid();
        }

        if (ConversationId.HasValue && !string.IsNullOrEmpty(DocumentProcessName))
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var userInfo = UserInfo.FromClaimsPrincipal(authState.User);
            CurrentUser = await AuthorizationApiClient.GetUserInfoAsync(userInfo.UserId);
            ChatMessages = await ChatApiClient.GetChatMessagesAsync(ConversationId.Value, DocumentProcessName);
            await StartHubConnections();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            HubConnection = new HubConnectionBuilder()
                .WithUrl($"{apiAddress}/hubs/notification-hub", options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithStatefulReconnect()
                .WithAutomaticReconnect()
                .Build();
        }

        HubConnection.On<ChatMessageResponseReceived>( // CorrelationId
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        HubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

        // Add this Hub Connection to a group matching the ConversationId
        await HubConnection.SendAsync("AddToGroup", ConversationId);
    }

    // Called on component disposal
    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        HubConnection.Remove("ReceiveChatMessageResponseReceivedNotification");
        HubConnection.Remove("ReceiveProcessChatMessageReceivedNotification");

        await HubConnection.SendAsync("RemoveFromGroup", ConversationId);

    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        // The message may originate from us. If so, we don't need to process it. Check if the message ID already exists in the conversation.
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        // If a message already exists in our ChatMessages list with the same Id, update it
        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            existingMessage.State = obj.ChatMessageDto.State;
            // In case we received messages out of order, only update the message if this message has longer content
            if (existingMessage.Message.Length < obj.ChatMessageDto.Message.Length)
            {
                existingMessage.Message = obj.ChatMessageDto.Message;
            }
        }
        else
        {
            // Insert the ChatMessage directly after the ChatMessage it is replying to
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);

                // If the replyToMessage is the last message in the list, just add the new message to the end
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();

    }

    private void OnChatTextKeyDown(KeyboardEventArgs e)
    {
        _chatTextLastKeyWasEnter = e is { Key: "Enter", ShiftKey: false };

    }

    private async Task OnChatTextFieldUpdated(string chatText)
    {
        if (string.IsNullOrWhiteSpace(chatText))
        {
            return;
        }

        if (_chatTextLastKeyWasEnter)
        {
            var chatMessage = new ChatMessageDTO
                {
                    ConversationId = ConversationId!.Value,
                    Id = Guid.NewGuid(),
                    Message = chatText,
                    CreatedAt = DateTime.UtcNow,
                    Source = ChatMessageSource.User,
                    UserId = CurrentUser!.ProviderSubjectId,
                    UserFullName = CurrentUser!.FullName
                };

            await ProcessMessage(chatMessage);
        }

    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        // Append the message according to its CreatedAt date - directly following the message with a CreatedAt date lower than this message
        var index = ChatMessages.FindLastIndex(x => x.CreatedAt < chatMessageDto.CreatedAt);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            // If the message is the last message in the list, just add the new message to the end
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();

    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        _chatTextLastKeyWasEnter = false;
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            await _mudChatTextField.Clear();
            await _mudChatTextField.SetText("");
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await ChatApiClient.SendChatMessageAsync(chatMessageDto);
            await _mudChatTextField.FocusAsync();

        }

    }

    private async Task ScrollMessagesToBottom()
    {
        await JSRuntime.InvokeVoidAsyncIgnoreErrors("scrollToBottom", _messagesContainer);
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }
    }
}
