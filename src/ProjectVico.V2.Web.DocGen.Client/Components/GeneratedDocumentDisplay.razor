@implements IAsyncDisposable
@using Microsoft.AspNetCore.SignalR.Client
@using ProjectVico.V2.Shared.Contracts.Messages.DocumentGeneration.Events
@using ProjectVico.V2.Shared.Enums
@using ProjectVico.V2.Shared.Models
@using ProjectVico.V2.Web.Shared.Helpers

@inject IDocumentGenerationApiClient DocumentGenerationApiClient
@inject IContentNodeApiClient ContentNodeApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject IConfigurationApiClient ConfigurationApiClient
@inject IConfiguration Configuration
@inject NavigationManager Navigation

@code {
    [Parameter] public Guid DocumentId { get; set; }
    [Parameter] public bool LiveUpdated { get; set; } = true;
    [Parameter] public GeneratedDocument? Document { get; set; }
    [CascadingParameter] public HubConnection? HubConnection { get; set; }

    private bool receivedMessagesVisible = false;
    private bool areNodesGenerated = false;

    private List<string> messages = new List<string>();
}

@if (Document != null)
{
    <MudPaper Class="pa-4">
        <MudGrid>
            <MudItem xs="12" sm="9">
                <MudText Typo="Typo.h4" GutterBottom="true">@Document.Title</MudText>
            </MudItem>
            <MudItem xs="12" sm="3" Class="d-flex justify-end align-center">
                @if (areNodesGenerated)
                {
                    <DocumentDownloadLink DocumentId=@DocumentId.ToString() ExportDocumentDelegate=@(()=>ExportDocumentLink()) />
                }
            </MudItem>
        </MudGrid>

        <MudText Typo="Typo.body1" GutterBottom="true">Document ID: @Document.Id</MudText>
        <MudPaper Outlined="true" Class="border-dashed">
            @if (Document.ContentNodes.Any())
            {
                @foreach (var contentNode in Document.ContentNodes)
                {
                    <ContentNodeDisplay Node="@contentNode" Recursive="true" />
                }
            }
        </MudPaper>
    </MudPaper>
}
else
{
    <MudPaper Class="pa-4">
        <MudText Typo="Typo.h4" GutterBottom="true">Loading document...</MudText>
        <MudSkeleton />
    </MudPaper>
}


@code {
    protected override async Task OnInitializedAsync()
    {
        var token = await DocumentGenerationApiClient.GetAccessTokenAsync();
        Document = await GetDocumentAsync(DocumentId);
        ContentNodeSorter.SortContentNodes(Document.ContentNodes);
        areNodesGenerated = AllNodesGenerated(Document.ContentNodes);

        await StartHubConnections();
    }

    private async Task StartHubConnections()
    {
        if (HubConnection == null)
        {
            var apiAddress = await AuthorizationApiClient.GetApiAddressAsync();
            var url = $"{apiAddress}/hubs/notification-hub";

            HubConnection = new HubConnectionBuilder()
                .WithUrl(url, options =>
                {
                    options.AccessTokenProvider = async () => await ConfigurationApiClient.GetAccessTokenAsync();
                })
                .WithAutomaticReconnect()
                .Build();

        }

        HubConnection.On<string>( // CorrelationId
            "ReceiveDocumentOutlineNotification",
            HubReceiveDocumentOutlineNotificationHandler);

        HubConnection.On<ContentNodeGenerated>(
            "ReceiveContentNodeNotification",
            HubReceiveContentNodeNotificationHandler);

        HubConnection.On<ContentNodeGenerationStateChanged>(
            "ReceiveContentNodeGenerationStateChangedNotification",
            HubReceiveContentNodeGenerationStateChangedNotificationHandler);

        if (HubConnection.State == HubConnectionState.Disconnected)
        {
            await HubConnection.StartAsync();
        }

    }

    // Called on component disposal
    private async Task StopHubConnections()
    {
        if (HubConnection == null) return;

        HubConnection.Remove("ReceiveDocumentOutlineNotification");
        HubConnection.Remove("ReceiveContentNodeNotification");
        HubConnection.Remove("ReceiveContentNodeGenerationStateChangedNotification");
    }

    private async Task HubReceiveContentNodeGenerationStateChangedNotificationHandler(ContentNodeGenerationStateChanged message)
    {
        if (message.CorrelationId == DocumentId)
        {
            // This notification is for the document we are currently displaying - get the associated contentNode
            var contentNode = await ContentNodeApiClient.GetContentNodeAsync(message.ContentNodeId.ToString());
            if (contentNode is not null)
            {
                await UpdateContentNodeState(Document?.ContentNodes, contentNode);
                areNodesGenerated = AllNodesGenerated(Document.ContentNodes);
            }
        }
    }

    private async Task ExportDocument()
    {
        var stream = await DocumentGenerationApiClient.ExportDocumentAsync(DocumentId.ToString());
        using var memoryStream = new MemoryStream();
        await stream.CopyToAsync(memoryStream);
        var byteArray = memoryStream.ToArray();
        var base64 = Convert.ToBase64String(byteArray);
        var fileName = "exported_document.docx";
        var fileType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        var fileUrl = $"data:{fileType};base64,{base64}";
        Navigation.NavigateTo(fileUrl, true);
    }

    private async Task<string> ExportDocumentLink()
    {
        return await DocumentGenerationApiClient.ExportDocumentLinkAsync(DocumentId.ToString());
    }

    private async Task UpdateContentNodeState(List<ContentNode>? documentContentNodes, ContentNode updatedNodeFromEvent)
    {
        if (documentContentNodes is null || !documentContentNodes.Any()) return;

        // Apply the updates.
        documentContentNodes = UpdateNodes(documentContentNodes, updatedNodeFromEvent);
        ContentNodeSorter.SortContentNodes(documentContentNodes);
        await InvokeAsync(StateHasChanged);
        // Recursive method to search and update the node in the tree.
        List<ContentNode> UpdateNodes(List<ContentNode> nodes, ContentNode updatedNode)
        {
            for (int i = 0; i < nodes.Count; i++)
            {
                if (nodes[i].Id == updatedNode.Id)
                {

                    // Replace the node.
                    nodes[i] = updatedNode;
                    return nodes; // Return immediately since the node has been replaced.
                }

                // If the current node has children, attempt to update them.
                if (nodes[i].Children != null && nodes[i].Children.Any())
                {
                    nodes[i].Children = UpdateNodes(nodes[i].Children, updatedNode);
                }
            }

            return nodes; // Return the potentially modified list of nodes.
        }


    }

    private async Task HubReceiveDocumentOutlineNotificationHandler(string correlationId)
    {
        string encodedMsg;
        if (correlationId == DocumentId.ToString())
        {
            receivedMessagesVisible = true;
            encodedMsg = $"Received ReceiveDocumentOutlineNotification for GeneratedDocument with ID : {correlationId}";
            // Get the document using /api/documents/documentId and render it
            try
            {
                var document = await DocumentGenerationApiClient.GetDocumentAsync(correlationId);
                if (document is not null)
                {
                    Document = document;
                    // Sort the ContentNodes by their Text property in ascending order
                    ContentNodeSorter.SortContentNodes(document.ContentNodes);
                }
            }
            catch
            {
                encodedMsg = "Failed to retrieve document after receiving ReceiveDocumentOutlineNotification";
            }
        }
        else return;

        messages.Add(encodedMsg);
        await InvokeAsync(StateHasChanged);
    }

    private async Task HubReceiveContentNodeNotificationHandler(ContentNodeGenerated contentNodeGeneratedEvent)
    {
        string encodedMsg;
        if (contentNodeGeneratedEvent.CorrelationId == DocumentId)
        {
            var correlationIdString = contentNodeGeneratedEvent.CorrelationId.ToString();
            receivedMessagesVisible = true;
            encodedMsg = $"Received ReceiveContentNodeNotification for ContentNode with ID : {contentNodeGeneratedEvent.ContentNodeId}";
            try
            {
                if (this.Document == null)
                {
                    await HubReceiveDocumentOutlineNotificationHandler(correlationIdString);
                }

                var contentNode = await ContentNodeApiClient.GetContentNodeAsync(contentNodeGeneratedEvent.ContentNodeId.ToString());
                if (contentNode is not null)
                {
                    if (contentNode.ParentId is not null)
                    {
                        var parentNode = this.Document?.ContentNodes.FirstOrDefault(x => x.Id == contentNode.ParentId);
                        parentNode?.Children.Add(contentNode);
                    }
                    else
                    {
                        if (contentNode.Type == ContentNodeType.Heading || contentNode.Type == ContentNodeType.Title)
                        {
                            this.Document?.ContentNodes.Add(contentNode);
                        }
                        else
                        {
                            this.Document?.ContentNodes.Insert(0, contentNode);
                        }

                    }

                    if (Document?.ContentNodes != null) ContentNodeSorter.SortContentNodes(Document!.ContentNodes);
                }
                else
                {
                    encodedMsg = "Failed to retrieve ContentNode after receiving ReceiveContentNodeNotification - ignoring";
                }
            }
            catch
            {
                encodedMsg = "Failed to retrieve ContentNode after receiving ReceiveContentNodeNotification - ignoring";
            }
            messages.Add(encodedMsg);
        }
        else return;

        messages.Add(encodedMsg);
        await InvokeAsync(StateHasChanged);

    }

    private async Task<GeneratedDocument?> GetDocumentAsync(Guid? documentId)
    {
        if (documentId == null) return null;
        return await DocumentGenerationApiClient.GetDocumentAsync(documentId.ToString());
    }

    private bool AllNodesGenerated(List<ContentNode> contentNodes)
    {
        if (contentNodes is null || !contentNodes.Any()) return false;

        foreach (var contentNode in contentNodes)
        {
            if (contentNode.GenerationState != ContentNodeGenerationState.Completed && contentNode.GenerationState != ContentNodeGenerationState.Failed)
            {
                return false;
            }

            if (contentNode.Children != null && contentNode.Children.Any())
            {
                if (!AllNodesGenerated(contentNode.Children))
                {
                    return false;
                }
            }
        }

        return true;
    }

    public async ValueTask DisposeAsync()
    {
        if (HubConnection != null)
        {
            await StopHubConnections();
        }
    }

}
