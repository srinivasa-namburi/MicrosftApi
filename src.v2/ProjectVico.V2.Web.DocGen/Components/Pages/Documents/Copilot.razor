@attribute [Authorize]
@page "/copilot/{ConversationIdString}"
@page "/copilot"


@using Microsoft.AspNetCore.SignalR.Client
@using ProjectVico.V2.Shared.Contracts.Chat
@using ProjectVico.V2.Shared.Contracts.DTO
@using ProjectVico.V2.Shared.Contracts.Messages.Chat.Commands
@using ProjectVico.V2.Shared.Contracts.Messages.Chat.Events
@using ProjectVico.V2.Shared.Models.Enums
@using ProjectVico.V2.Web.Shared.Auth
@using ProjectVico.V2.Web.Shared.ServiceClients
@using Color = MudBlazor.Color

@inject IConfiguration Configuration
@inject IChatApiClient ChatApiClient
@inject IAuthorizationApiClient AuthorizationApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime


@implements IDisposable

@code {
    [Parameter] public string? ConversationIdString { get; set; }
    [Parameter] public Guid? ConversationId { get; set; }

    private string? apiSignalRAddressBase;
    private HubConnection? hubConnection;
    
    private MudTextField<string> _mudChatTextField;
    private ElementReference _messagesContainer;
    private MudList _mudMessageList;

    private List<ChatMessageDTO> ChatMessages { get; set; } = new List<ChatMessageDTO>();
    private UserInfoDTO? CurrentUser;

}

<MudGrid>
    <MudItem xs="12">
        <div @ref="_messagesContainer" style="border: 3px solid #ddd; padding: 10px; overflow-y: auto; height: 550px;">
            <MudList @ref="_mudMessageList" Dense="true" DisablePadding="true">
                @foreach (var chatMessage in ChatMessages.OrderBy(x => x.CreatedAt))
                {
                    <MudListItem>
                        @if (chatMessage.Source == ChatMessageSource.User)
                        {
                            var align = chatMessage.UserId == CurrentUser?.ProviderSubjectId ? Align.Right : Align.Left;
                            
                            <MudText Typo="Typo.body2" Class="my-0" Align="@align" Color="@Color.Info">@chatMessage.CreatedAt.ToString("MM/dd/yyyy HH:mm:ss")</MudText>
                            if (!string.IsNullOrEmpty(chatMessage.UserFullName))
                            {
                                <MudText Typo="Typo.body2" Class="my-0" Align="@align" Color="@Color.Info">@chatMessage.UserFullName</MudText>
                            }
                            <MudText Typo="Typo.body1" Class="my-0 mb-n1" Align="@align">@chatMessage.Message</MudText>
                        }
                        else
                        {
                            <MudText Typo="Typo.body2" Class="my-0" Align="Align.Left" Color="@Color.Info">@chatMessage.CreatedAt.ToString("MM/dd/yyyy HH:mm:ss")</MudText>
                            <MudText Typo="Typo.body2" Class="my-0" Align="Align.Left" Color="@Color.Info">Nuclear CoPilot</MudText>
                            <MudText Typo="Typo.body1" Class="my-0 mb-n1" Align="Align.Left">
                                <RenderMultilineText Value="@chatMessage.Message" />
                            </MudText>
                        }
                    </MudListItem>
                }
            </MudList>
        </div>
        <MudTextField @ref="_mudChatTextField" T="string" ValueChanged="OnChatTextFieldUpdated"
                      AutoFocus="true" FullWidth="true" Placeholder="Type a message..."
                      AdornmentIcon="@Icons.Material.Filled.Send"
                      AdornmentColor="Color.Primary"
                      Adornment="Adornment.End" />

    </MudItem>
    @*  <MudItem xs="6">
    <!-- This pane can contain your rich text area for HTML/Markdown content -->
    <div style="border: 1px solid #ddd; padding: 10px; overflow-y: scroll; height: 400px;">
    @{
    var contentMessage = ChatMessages.LastOrDefault(x => x.ContentText != null)?.ContentText;
    if (!string.IsNullOrWhiteSpace(contentMessage))
    {
    <RenderMultilineText Value="@contentMessage"></RenderMultilineText>
    }
    }
    </div>
    </MudItem> *@
</MudGrid>

@code
{


    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(ConversationIdString))
        {
            ConversationId = Guid.Parse(ConversationIdString);
        }
        else
        {
            ConversationId = Guid.NewGuid();
            Navigation.NavigateTo($"/copilot/{ConversationId}");
        }
        if (ConversationId.HasValue)
        {
            ConversationIdString = ConversationId.ToString();
            ChatMessages = await ChatApiClient.GetChatMessages(ConversationId.Value);

            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            var userInfo = UserInfo.FromClaimsPrincipal(authState.User);

            CurrentUser = await AuthorizationApiClient.GetUserInfo(userInfo.UserId);

        }


        await StartHubConnections(await ChatApiClient.GetAccessTokenAsync());

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && ChatMessages.Count > 0)
        {
            await ScrollMessagesToBottom();
        }
    }

    private async Task StartHubConnections(string token)
    {
        //TODO: This is a hack because SignalR can't use Service Discovery yet
        apiSignalRAddressBase = Configuration.GetValue<string>("services:api-main:0")!;
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri($"{apiSignalRAddressBase}/hubs/notification-hub"), options =>
            {
                options.AccessTokenProvider = () => Task.FromResult(token)!;
            })
            .WithStatefulReconnect()
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<ChatMessageResponseReceived>( // CorrelationId
            "ReceiveChatMessageResponseReceivedNotification",
            HubReceiveChatMessageResponseReceivedNotificationHandler);

        hubConnection.On<ProcessChatMessage>(
            "ReceiveProcessChatMessageReceivedNotification",
            HubReceiveProcessChatMessageReceivedNotificationHandler);

        await hubConnection.StartAsync();

        // Add this Hub Connection to a group matching the ConversationId
        await hubConnection.SendAsync("AddToGroup", ConversationId);
    }

    private async Task HubReceiveProcessChatMessageReceivedNotificationHandler(ProcessChatMessage obj)
    {
        // The message may originate from us. If so, we don't need to process it. Check if the message ID already exists in the conversation.
        if (ChatMessages.Any(x => x.Id == obj.ChatMessageDto.Id))
        {
            return;
        }

        await ProcessOtherUserMessage(obj.ChatMessageDto);
    }

    private async Task HubReceiveChatMessageResponseReceivedNotificationHandler(ChatMessageResponseReceived obj)
    {
        // If a message already exists in our ChatMessages list with the same Id, update it
        var existingMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.Id);
        if (existingMessage != null)
        {
            // In case we received messages out of order, only update the message if this message has longer content
            if (existingMessage.Message.Length < obj.ChatMessageDto.Message.Length)
            {
                existingMessage.Message = obj.ChatMessageDto.Message;
            }
        }
        else
        {
            // Insert the ChatMessage directly after the ChatMessage it is replying to
            var replyToMessage = ChatMessages.FirstOrDefault(x => x.Id == obj.ChatMessageDto.ReplyToId);
            if (replyToMessage != null)
            {
                var index = ChatMessages.IndexOf(replyToMessage);

                // If the replyToMessage is the last message in the list, just add the new message to the end
                if (index == ChatMessages.Count - 1)
                {
                    ChatMessages.Add(obj.ChatMessageDto);
                }
                else
                {
                    ChatMessages.Insert(index + 1, obj.ChatMessageDto);
                }
            }
            else
            {
                ChatMessages.Add(obj.ChatMessageDto);
            }
        }

        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();

    }

    private async Task OnChatTextFieldUpdated(string chatText)
    {
        if (string.IsNullOrWhiteSpace(chatText))
        {
            return;
        }

        var chatMessage = new ChatMessageDTO
            {
                ConversationId = ConversationId!.Value,
                Id = Guid.NewGuid(),
                Message = chatText,
                CreatedAt = DateTime.UtcNow,
                Source = ChatMessageSource.User,
                UserId = CurrentUser!.ProviderSubjectId,
                UserFullName = CurrentUser!.FullName
            };

        await ProcessMessage(chatMessage);
    }

    private async Task ProcessOtherUserMessage(ChatMessageDTO chatMessageDto)
    {
        // Append the message according to its CreatedAt date - directly following the message with a CreatedAt date lower than this message
        var index = ChatMessages.FindLastIndex(x => x.CreatedAt < chatMessageDto.CreatedAt);
        if (index == -1)
        {
            ChatMessages.Insert(0, chatMessageDto);
        }
        else
        {
            // If the message is the last message in the list, just add the new message to the end
            if (index == ChatMessages.Count - 1)
            {
                ChatMessages.Add(chatMessageDto);
            }
            else
            {
                ChatMessages.Insert(index + 1, chatMessageDto);
            }
        }
        
        await InvokeAsync(StateHasChanged);
        await ScrollMessagesToBottom();

    }

    private async Task ProcessMessage(ChatMessageDTO chatMessageDto)
    {
        if (chatMessageDto.Source == ChatMessageSource.User)
        {
            ChatMessages.Add(chatMessageDto);
            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();


            await ChatApiClient.SendChatMessage(chatMessageDto);

            await InvokeAsync(StateHasChanged);
            await ScrollMessagesToBottom();

            await _mudChatTextField.FocusAsync();
            await _mudChatTextField.Clear();
        }

    }

    private async Task ScrollMessagesToBottom()
    {
        await JSRuntime.InvokeVoidAsync("scrollToBottom", _messagesContainer);
    }

    public void Dispose()
    {
        if (hubConnection != null)
        {
            hubConnection.SendAsync("RemoveFromGroup", ConversationId);
            hubConnection.DisposeAsync().AsTask();
        }
    }
}
